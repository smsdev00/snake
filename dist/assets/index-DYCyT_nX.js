function iO(n,t){for(var e=0;e<t.length;e++){const s=t[e];if(typeof s!="string"&&!Array.isArray(s)){for(const o in s)if(o!=="default"&&!(o in n)){const i=Object.getOwnPropertyDescriptor(s,o);i&&Object.defineProperty(n,o,i.get?i:{enumerable:!0,get:()=>s[o]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const l of i.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&s(l)}).observe(document,{childList:!0,subtree:!0});function e(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(o){if(o.ep)return;o.ep=!0;const i=e(o);fetch(o.href,i)}})();function rO(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function lO(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var e=function s(){var o=!1;try{o=this instanceof s}catch{}return o?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var o=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,o.get?o:{enumerable:!0,get:function(){return n[s]}})}),e}var Sx={exports:{}},Iu={};var hC;function uO(){if(hC)return Iu;hC=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(s,o,i){var l=null;if(i!==void 0&&(l=""+i),o.key!==void 0&&(l=""+o.key),"key"in o){i={};for(var u in o)u!=="key"&&(i[u]=o[u])}else i=o;return o=i.ref,{$$typeof:n,type:s,key:l,ref:o!==void 0?o:null,props:i}}return Iu.Fragment=t,Iu.jsx=e,Iu.jsxs=e,Iu}var dC;function cO(){return dC||(dC=1,Sx.exports=uO()),Sx.exports}var $e=cO(),Cx={exports:{}},Bt={};var fC;function hO(){if(fC)return Bt;fC=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),g=Symbol.iterator;function x(M){return M===null||typeof M!="object"?null:(M=g&&M[g]||M["@@iterator"],typeof M=="function"?M:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},v=Object.assign,S={};function C(M,G,Q){this.props=M,this.context=G,this.refs=S,this.updater=Q||b}C.prototype.isReactComponent={},C.prototype.setState=function(M,G){if(typeof M!="object"&&typeof M!="function"&&M!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,M,G,"setState")},C.prototype.forceUpdate=function(M){this.updater.enqueueForceUpdate(this,M,"forceUpdate")};function $(){}$.prototype=C.prototype;function k(M,G,Q){this.props=M,this.context=G,this.refs=S,this.updater=Q||b}var T=k.prototype=new $;T.constructor=k,v(T,C.prototype),T.isPureReactComponent=!0;var N=Array.isArray;function R(){}var D={H:null,A:null,T:null,S:null},z=Object.prototype.hasOwnProperty;function O(M,G,Q){var ut=Q.ref;return{$$typeof:n,type:M,key:G,ref:ut!==void 0?ut:null,props:Q}}function F(M,G){return O(M.type,G,M.props)}function E(M){return typeof M=="object"&&M!==null&&M.$$typeof===n}function U(M){var G={"=":"=0",":":"=2"};return"$"+M.replace(/[=:]/g,function(Q){return G[Q]})}var Y=/\/+/g;function X(M,G){return typeof M=="object"&&M!==null&&M.key!=null?U(""+M.key):G.toString(36)}function q(M){switch(M.status){case"fulfilled":return M.value;case"rejected":throw M.reason;default:switch(typeof M.status=="string"?M.then(R,R):(M.status="pending",M.then(function(G){M.status==="pending"&&(M.status="fulfilled",M.value=G)},function(G){M.status==="pending"&&(M.status="rejected",M.reason=G)})),M.status){case"fulfilled":return M.value;case"rejected":throw M.reason}}throw M}function L(M,G,Q,ut,ft){var gt=typeof M;(gt==="undefined"||gt==="boolean")&&(M=null);var yt=!1;if(M===null)yt=!0;else switch(gt){case"bigint":case"string":case"number":yt=!0;break;case"object":switch(M.$$typeof){case n:case t:yt=!0;break;case f:return yt=M._init,L(yt(M._payload),G,Q,ut,ft)}}if(yt)return ft=ft(M),yt=ut===""?"."+X(M,0):ut,N(ft)?(Q="",yt!=null&&(Q=yt.replace(Y,"$&/")+"/"),L(ft,G,Q,"",function(zt){return zt})):ft!=null&&(E(ft)&&(ft=F(ft,Q+(ft.key==null||M&&M.key===ft.key?"":(""+ft.key).replace(Y,"$&/")+"/")+yt)),G.push(ft)),1;yt=0;var Tt=ut===""?".":ut+":";if(N(M))for(var St=0;St<M.length;St++)ut=M[St],gt=Tt+X(ut,St),yt+=L(ut,G,Q,gt,ft);else if(St=x(M),typeof St=="function")for(M=St.call(M),St=0;!(ut=M.next()).done;)ut=ut.value,gt=Tt+X(ut,St++),yt+=L(ut,G,Q,gt,ft);else if(gt==="object"){if(typeof M.then=="function")return L(q(M),G,Q,ut,ft);throw G=String(M),Error("Objects are not valid as a React child (found: "+(G==="[object Object]"?"object with keys {"+Object.keys(M).join(", ")+"}":G)+"). If you meant to render a collection of children, use an array instead.")}return yt}function P(M,G,Q){if(M==null)return M;var ut=[],ft=0;return L(M,ut,"","",function(gt){return G.call(Q,gt,ft++)}),ut}function W(M){if(M._status===-1){var G=M._result;G=G(),G.then(function(Q){(M._status===0||M._status===-1)&&(M._status=1,M._result=Q)},function(Q){(M._status===0||M._status===-1)&&(M._status=2,M._result=Q)}),M._status===-1&&(M._status=0,M._result=G)}if(M._status===1)return M._result.default;throw M._result}var nt=typeof reportError=="function"?reportError:function(M){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var G=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof M=="object"&&M!==null&&typeof M.message=="string"?String(M.message):String(M),error:M});if(!window.dispatchEvent(G))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",M);return}console.error(M)},it={map:P,forEach:function(M,G,Q){P(M,function(){G.apply(this,arguments)},Q)},count:function(M){var G=0;return P(M,function(){G++}),G},toArray:function(M){return P(M,function(G){return G})||[]},only:function(M){if(!E(M))throw Error("React.Children.only expected to receive a single React element child.");return M}};return Bt.Activity=p,Bt.Children=it,Bt.Component=C,Bt.Fragment=e,Bt.Profiler=o,Bt.PureComponent=k,Bt.StrictMode=s,Bt.Suspense=c,Bt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=D,Bt.__COMPILER_RUNTIME={__proto__:null,c:function(M){return D.H.useMemoCache(M)}},Bt.cache=function(M){return function(){return M.apply(null,arguments)}},Bt.cacheSignal=function(){return null},Bt.cloneElement=function(M,G,Q){if(M==null)throw Error("The argument must be a React element, but you passed "+M+".");var ut=v({},M.props),ft=M.key;if(G!=null)for(gt in G.key!==void 0&&(ft=""+G.key),G)!z.call(G,gt)||gt==="key"||gt==="__self"||gt==="__source"||gt==="ref"&&G.ref===void 0||(ut[gt]=G[gt]);var gt=arguments.length-2;if(gt===1)ut.children=Q;else if(1<gt){for(var yt=Array(gt),Tt=0;Tt<gt;Tt++)yt[Tt]=arguments[Tt+2];ut.children=yt}return O(M.type,ft,ut)},Bt.createContext=function(M){return M={$$typeof:l,_currentValue:M,_currentValue2:M,_threadCount:0,Provider:null,Consumer:null},M.Provider=M,M.Consumer={$$typeof:i,_context:M},M},Bt.createElement=function(M,G,Q){var ut,ft={},gt=null;if(G!=null)for(ut in G.key!==void 0&&(gt=""+G.key),G)z.call(G,ut)&&ut!=="key"&&ut!=="__self"&&ut!=="__source"&&(ft[ut]=G[ut]);var yt=arguments.length-2;if(yt===1)ft.children=Q;else if(1<yt){for(var Tt=Array(yt),St=0;St<yt;St++)Tt[St]=arguments[St+2];ft.children=Tt}if(M&&M.defaultProps)for(ut in yt=M.defaultProps,yt)ft[ut]===void 0&&(ft[ut]=yt[ut]);return O(M,gt,ft)},Bt.createRef=function(){return{current:null}},Bt.forwardRef=function(M){return{$$typeof:u,render:M}},Bt.isValidElement=E,Bt.lazy=function(M){return{$$typeof:f,_payload:{_status:-1,_result:M},_init:W}},Bt.memo=function(M,G){return{$$typeof:h,type:M,compare:G===void 0?null:G}},Bt.startTransition=function(M){var G=D.T,Q={};D.T=Q;try{var ut=M(),ft=D.S;ft!==null&&ft(Q,ut),typeof ut=="object"&&ut!==null&&typeof ut.then=="function"&&ut.then(R,nt)}catch(gt){nt(gt)}finally{G!==null&&Q.types!==null&&(G.types=Q.types),D.T=G}},Bt.unstable_useCacheRefresh=function(){return D.H.useCacheRefresh()},Bt.use=function(M){return D.H.use(M)},Bt.useActionState=function(M,G,Q){return D.H.useActionState(M,G,Q)},Bt.useCallback=function(M,G){return D.H.useCallback(M,G)},Bt.useContext=function(M){return D.H.useContext(M)},Bt.useDebugValue=function(){},Bt.useDeferredValue=function(M,G){return D.H.useDeferredValue(M,G)},Bt.useEffect=function(M,G){return D.H.useEffect(M,G)},Bt.useEffectEvent=function(M){return D.H.useEffectEvent(M)},Bt.useId=function(){return D.H.useId()},Bt.useImperativeHandle=function(M,G,Q){return D.H.useImperativeHandle(M,G,Q)},Bt.useInsertionEffect=function(M,G){return D.H.useInsertionEffect(M,G)},Bt.useLayoutEffect=function(M,G){return D.H.useLayoutEffect(M,G)},Bt.useMemo=function(M,G){return D.H.useMemo(M,G)},Bt.useOptimistic=function(M,G){return D.H.useOptimistic(M,G)},Bt.useReducer=function(M,G,Q){return D.H.useReducer(M,G,Q)},Bt.useRef=function(M){return D.H.useRef(M)},Bt.useState=function(M){return D.H.useState(M)},Bt.useSyncExternalStore=function(M,G,Q){return D.H.useSyncExternalStore(M,G,Q)},Bt.useTransition=function(){return D.H.useTransition()},Bt.version="19.2.4",Bt}var pC;function O0(){return pC||(pC=1,Cx.exports=hO()),Cx.exports}var ae=O0(),$x={exports:{}},Nu={},Tx={exports:{}},kx={};var mC;function dO(){return mC||(mC=1,(function(n){function t(L,P){var W=L.length;L.push(P);t:for(;0<W;){var nt=W-1>>>1,it=L[nt];if(0<o(it,P))L[nt]=P,L[W]=it,W=nt;else break t}}function e(L){return L.length===0?null:L[0]}function s(L){if(L.length===0)return null;var P=L[0],W=L.pop();if(W!==P){L[0]=W;t:for(var nt=0,it=L.length,M=it>>>1;nt<M;){var G=2*(nt+1)-1,Q=L[G],ut=G+1,ft=L[ut];if(0>o(Q,W))ut<it&&0>o(ft,Q)?(L[nt]=ft,L[ut]=W,nt=ut):(L[nt]=Q,L[G]=W,nt=G);else if(ut<it&&0>o(ft,W))L[nt]=ft,L[ut]=W,nt=ut;else break t}}return P}function o(L,P){var W=L.sortIndex-P.sortIndex;return W!==0?W:L.id-P.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var l=Date,u=l.now();n.unstable_now=function(){return l.now()-u}}var c=[],h=[],f=1,p=null,g=3,x=!1,b=!1,v=!1,S=!1,C=typeof setTimeout=="function"?setTimeout:null,$=typeof clearTimeout=="function"?clearTimeout:null,k=typeof setImmediate<"u"?setImmediate:null;function T(L){for(var P=e(h);P!==null;){if(P.callback===null)s(h);else if(P.startTime<=L)s(h),P.sortIndex=P.expirationTime,t(c,P);else break;P=e(h)}}function N(L){if(v=!1,T(L),!b)if(e(c)!==null)b=!0,R||(R=!0,U());else{var P=e(h);P!==null&&q(N,P.startTime-L)}}var R=!1,D=-1,z=5,O=-1;function F(){return S?!0:!(n.unstable_now()-O<z)}function E(){if(S=!1,R){var L=n.unstable_now();O=L;var P=!0;try{t:{b=!1,v&&(v=!1,$(D),D=-1),x=!0;var W=g;try{e:{for(T(L),p=e(c);p!==null&&!(p.expirationTime>L&&F());){var nt=p.callback;if(typeof nt=="function"){p.callback=null,g=p.priorityLevel;var it=nt(p.expirationTime<=L);if(L=n.unstable_now(),typeof it=="function"){p.callback=it,T(L),P=!0;break e}p===e(c)&&s(c),T(L)}else s(c);p=e(c)}if(p!==null)P=!0;else{var M=e(h);M!==null&&q(N,M.startTime-L),P=!1}}break t}finally{p=null,g=W,x=!1}P=void 0}}finally{P?U():R=!1}}}var U;if(typeof k=="function")U=function(){k(E)};else if(typeof MessageChannel<"u"){var Y=new MessageChannel,X=Y.port2;Y.port1.onmessage=E,U=function(){X.postMessage(null)}}else U=function(){C(E,0)};function q(L,P){D=C(function(){L(n.unstable_now())},P)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(L){L.callback=null},n.unstable_forceFrameRate=function(L){0>L||125<L?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<L?Math.floor(1e3/L):5},n.unstable_getCurrentPriorityLevel=function(){return g},n.unstable_next=function(L){switch(g){case 1:case 2:case 3:var P=3;break;default:P=g}var W=g;g=P;try{return L()}finally{g=W}},n.unstable_requestPaint=function(){S=!0},n.unstable_runWithPriority=function(L,P){switch(L){case 1:case 2:case 3:case 4:case 5:break;default:L=3}var W=g;g=L;try{return P()}finally{g=W}},n.unstable_scheduleCallback=function(L,P,W){var nt=n.unstable_now();switch(typeof W=="object"&&W!==null?(W=W.delay,W=typeof W=="number"&&0<W?nt+W:nt):W=nt,L){case 1:var it=-1;break;case 2:it=250;break;case 5:it=1073741823;break;case 4:it=1e4;break;default:it=5e3}return it=W+it,L={id:f++,callback:P,priorityLevel:L,startTime:W,expirationTime:it,sortIndex:-1},W>nt?(L.sortIndex=W,t(h,L),e(c)===null&&L===e(h)&&(v?($(D),D=-1):v=!0,q(N,W-nt))):(L.sortIndex=it,t(c,L),b||x||(b=!0,R||(R=!0,U()))),L},n.unstable_shouldYield=F,n.unstable_wrapCallback=function(L){var P=g;return function(){var W=g;g=P;try{return L.apply(this,arguments)}finally{g=W}}}})(kx)),kx}var gC;function fO(){return gC||(gC=1,Tx.exports=dO()),Tx.exports}var Ix={exports:{}},Fn={};var xC;function pO(){if(xC)return Fn;xC=1;var n=O0();function t(c){var h="https://react.dev/errors/"+c;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)h+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+c+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var s={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},o=Symbol.for("react.portal");function i(c,h,f){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:o,key:p==null?null:""+p,children:c,containerInfo:h,implementation:f}}var l=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function u(c,h){if(c==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return Fn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Fn.createPortal=function(c,h){var f=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(t(299));return i(c,h,null,f)},Fn.flushSync=function(c){var h=l.T,f=s.p;try{if(l.T=null,s.p=2,c)return c()}finally{l.T=h,s.p=f,s.d.f()}},Fn.preconnect=function(c,h){typeof c=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(c,h))},Fn.prefetchDNS=function(c){typeof c=="string"&&s.d.D(c)},Fn.preinit=function(c,h){if(typeof c=="string"&&h&&typeof h.as=="string"){var f=h.as,p=u(f,h.crossOrigin),g=typeof h.integrity=="string"?h.integrity:void 0,x=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;f==="style"?s.d.S(c,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:p,integrity:g,fetchPriority:x}):f==="script"&&s.d.X(c,{crossOrigin:p,integrity:g,fetchPriority:x,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},Fn.preinitModule=function(c,h){if(typeof c=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var f=u(h.as,h.crossOrigin);s.d.M(c,{crossOrigin:f,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(c)},Fn.preload=function(c,h){if(typeof c=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var f=h.as,p=u(f,h.crossOrigin);s.d.L(c,f,{crossOrigin:p,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},Fn.preloadModule=function(c,h){if(typeof c=="string")if(h){var f=u(h.as,h.crossOrigin);s.d.m(c,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:f,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(c)},Fn.requestFormReset=function(c){s.d.r(c)},Fn.unstable_batchedUpdates=function(c,h){return c(h)},Fn.useFormState=function(c,h,f){return l.H.useFormState(c,h,f)},Fn.useFormStatus=function(){return l.H.useHostTransitionStatus()},Fn.version="19.2.4",Fn}var bC;function mO(){if(bC)return Ix.exports;bC=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),Ix.exports=pO(),Ix.exports}var yC;function gO(){if(yC)return Nu;yC=1;var n=fO(),t=O0(),e=mO();function s(a){var r="https://react.dev/errors/"+a;if(1<arguments.length){r+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)r+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+a+"; visit "+r+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function o(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function i(a){var r=a,d=a;if(a.alternate)for(;r.return;)r=r.return;else{a=r;do r=a,(r.flags&4098)!==0&&(d=r.return),a=r.return;while(a)}return r.tag===3?d:null}function l(a){if(a.tag===13){var r=a.memoizedState;if(r===null&&(a=a.alternate,a!==null&&(r=a.memoizedState)),r!==null)return r.dehydrated}return null}function u(a){if(a.tag===31){var r=a.memoizedState;if(r===null&&(a=a.alternate,a!==null&&(r=a.memoizedState)),r!==null)return r.dehydrated}return null}function c(a){if(i(a)!==a)throw Error(s(188))}function h(a){var r=a.alternate;if(!r){if(r=i(a),r===null)throw Error(s(188));return r!==a?null:a}for(var d=a,m=r;;){var y=d.return;if(y===null)break;var w=y.alternate;if(w===null){if(m=y.return,m!==null){d=m;continue}break}if(y.child===w.child){for(w=y.child;w;){if(w===d)return c(y),a;if(w===m)return c(y),r;w=w.sibling}throw Error(s(188))}if(d.return!==m.return)d=y,m=w;else{for(var I=!1,A=y.child;A;){if(A===d){I=!0,d=y,m=w;break}if(A===m){I=!0,m=y,d=w;break}A=A.sibling}if(!I){for(A=w.child;A;){if(A===d){I=!0,d=w,m=y;break}if(A===m){I=!0,m=w,d=y;break}A=A.sibling}if(!I)throw Error(s(189))}}if(d.alternate!==m)throw Error(s(190))}if(d.tag!==3)throw Error(s(188));return d.stateNode.current===d?a:r}function f(a){var r=a.tag;if(r===5||r===26||r===27||r===6)return a;for(a=a.child;a!==null;){if(r=f(a),r!==null)return r;a=a.sibling}return null}var p=Object.assign,g=Symbol.for("react.element"),x=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),v=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),C=Symbol.for("react.profiler"),$=Symbol.for("react.consumer"),k=Symbol.for("react.context"),T=Symbol.for("react.forward_ref"),N=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),D=Symbol.for("react.memo"),z=Symbol.for("react.lazy"),O=Symbol.for("react.activity"),F=Symbol.for("react.memo_cache_sentinel"),E=Symbol.iterator;function U(a){return a===null||typeof a!="object"?null:(a=E&&a[E]||a["@@iterator"],typeof a=="function"?a:null)}var Y=Symbol.for("react.client.reference");function X(a){if(a==null)return null;if(typeof a=="function")return a.$$typeof===Y?null:a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case v:return"Fragment";case C:return"Profiler";case S:return"StrictMode";case N:return"Suspense";case R:return"SuspenseList";case O:return"Activity"}if(typeof a=="object")switch(a.$$typeof){case b:return"Portal";case k:return a.displayName||"Context";case $:return(a._context.displayName||"Context")+".Consumer";case T:var r=a.render;return a=a.displayName,a||(a=r.displayName||r.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case D:return r=a.displayName||null,r!==null?r:X(a.type)||"Memo";case z:r=a._payload,a=a._init;try{return X(a(r))}catch{}}return null}var q=Array.isArray,L=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,P=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,W={pending:!1,data:null,method:null,action:null},nt=[],it=-1;function M(a){return{current:a}}function G(a){0>it||(a.current=nt[it],nt[it]=null,it--)}function Q(a,r){it++,nt[it]=a.current,a.current=r}var ut=M(null),ft=M(null),gt=M(null),yt=M(null);function Tt(a,r){switch(Q(gt,r),Q(ft,a),Q(ut,null),r.nodeType){case 9:case 11:a=(a=r.documentElement)&&(a=a.namespaceURI)?_S(a):0;break;default:if(a=r.tagName,r=r.namespaceURI)r=_S(r),a=FS(r,a);else switch(a){case"svg":a=1;break;case"math":a=2;break;default:a=0}}G(ut),Q(ut,a)}function St(){G(ut),G(ft),G(gt)}function zt(a){a.memoizedState!==null&&Q(yt,a);var r=ut.current,d=FS(r,a.type);r!==d&&(Q(ft,a),Q(ut,d))}function Lt(a){ft.current===a&&(G(ut),G(ft)),yt.current===a&&(G(yt),Cu._currentValue=W)}var ne,pe;function he(a){if(ne===void 0)try{throw Error()}catch(d){var r=d.stack.trim().match(/\n( *(at )?)/);ne=r&&r[1]||"",pe=-1<d.stack.indexOf(`
    at`)?" (<anonymous>)":-1<d.stack.indexOf("@")?"@unknown:0:0":""}return`
`+ne+a+pe}var de=!1;function oe(a,r){if(!a||de)return"";de=!0;var d=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var m={DetermineComponentFrameRoot:function(){try{if(r){var xt=function(){throw Error()};if(Object.defineProperty(xt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(xt,[])}catch(ct){var rt=ct}Reflect.construct(a,[],xt)}else{try{xt.call()}catch(ct){rt=ct}a.call(xt.prototype)}}else{try{throw Error()}catch(ct){rt=ct}(xt=a())&&typeof xt.catch=="function"&&xt.catch(function(){})}}catch(ct){if(ct&&rt&&typeof ct.stack=="string")return[ct.stack,rt.stack]}return[null,null]}};m.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var y=Object.getOwnPropertyDescriptor(m.DetermineComponentFrameRoot,"name");y&&y.configurable&&Object.defineProperty(m.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var w=m.DetermineComponentFrameRoot(),I=w[0],A=w[1];if(I&&A){var V=I.split(`
`),at=A.split(`
`);for(y=m=0;m<V.length&&!V[m].includes("DetermineComponentFrameRoot");)m++;for(;y<at.length&&!at[y].includes("DetermineComponentFrameRoot");)y++;if(m===V.length||y===at.length)for(m=V.length-1,y=at.length-1;1<=m&&0<=y&&V[m]!==at[y];)y--;for(;1<=m&&0<=y;m--,y--)if(V[m]!==at[y]){if(m!==1||y!==1)do if(m--,y--,0>y||V[m]!==at[y]){var pt=`
`+V[m].replace(" at new "," at ");return a.displayName&&pt.includes("<anonymous>")&&(pt=pt.replace("<anonymous>",a.displayName)),pt}while(1<=m&&0<=y);break}}}finally{de=!1,Error.prepareStackTrace=d}return(d=a?a.displayName||a.name:"")?he(d):""}function Re(a,r){switch(a.tag){case 26:case 27:case 5:return he(a.type);case 16:return he("Lazy");case 13:return a.child!==r&&r!==null?he("Suspense Fallback"):he("Suspense");case 19:return he("SuspenseList");case 0:case 15:return oe(a.type,!1);case 11:return oe(a.type.render,!1);case 1:return oe(a.type,!0);case 31:return he("Activity");default:return""}}function ve(a){try{var r="",d=null;do r+=Re(a,d),d=a,a=a.return;while(a);return r}catch(m){return`
Error generating stack: `+m.message+`
`+m.stack}}var ds=Object.prototype.hasOwnProperty,Ue=n.unstable_scheduleCallback,Ns=n.unstable_cancelCallback,Pn=n.unstable_shouldYield,Bo=n.unstable_requestPaint,De=n.unstable_now,Ys=n.unstable_getCurrentPriorityLevel,Zs=n.unstable_ImmediatePriority,Qs=n.unstable_UserBlockingPriority,fs=n.unstable_NormalPriority,di=n.unstable_LowPriority,dr=n.unstable_IdlePriority,Fl=n.log,um=n.unstable_setDisableYieldValue,mo=null,Gn=null;function go(a){if(typeof Fl=="function"&&um(a),Gn&&typeof Gn.setStrictMode=="function")try{Gn.setStrictMode(mo,a)}catch{}}var ps=Math.clz32?Math.clz32:qR,WR=Math.log,HR=Math.LN2;function qR(a){return a>>>=0,a===0?32:31-(WR(a)/HR|0)|0}var bh=256,yh=262144,vh=4194304;function fi(a){var r=a&42;if(r!==0)return r;switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return a&261888;case 262144:case 524288:case 1048576:case 2097152:return a&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return a&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return a}}function wh(a,r,d){var m=a.pendingLanes;if(m===0)return 0;var y=0,w=a.suspendedLanes,I=a.pingedLanes;a=a.warmLanes;var A=m&134217727;return A!==0?(m=A&~w,m!==0?y=fi(m):(I&=A,I!==0?y=fi(I):d||(d=A&~a,d!==0&&(y=fi(d))))):(A=m&~w,A!==0?y=fi(A):I!==0?y=fi(I):d||(d=m&~a,d!==0&&(y=fi(d)))),y===0?0:r!==0&&r!==y&&(r&w)===0&&(w=y&-y,d=r&-r,w>=d||w===32&&(d&4194048)!==0)?r:y}function Ml(a,r){return(a.pendingLanes&~(a.suspendedLanes&~a.pingedLanes)&r)===0}function jR(a,r){switch(a){case 1:case 2:case 4:case 8:case 64:return r+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return r+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function m1(){var a=vh;return vh<<=1,(vh&62914560)===0&&(vh=4194304),a}function cm(a){for(var r=[],d=0;31>d;d++)r.push(a);return r}function zl(a,r){a.pendingLanes|=r,r!==268435456&&(a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0)}function XR(a,r,d,m,y,w){var I=a.pendingLanes;a.pendingLanes=d,a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0,a.expiredLanes&=d,a.entangledLanes&=d,a.errorRecoveryDisabledLanes&=d,a.shellSuspendCounter=0;var A=a.entanglements,V=a.expirationTimes,at=a.hiddenUpdates;for(d=I&~d;0<d;){var pt=31-ps(d),xt=1<<pt;A[pt]=0,V[pt]=-1;var rt=at[pt];if(rt!==null)for(at[pt]=null,pt=0;pt<rt.length;pt++){var ct=rt[pt];ct!==null&&(ct.lane&=-536870913)}d&=~xt}m!==0&&g1(a,m,0),w!==0&&y===0&&a.tag!==0&&(a.suspendedLanes|=w&~(I&~r))}function g1(a,r,d){a.pendingLanes|=r,a.suspendedLanes&=~r;var m=31-ps(r);a.entangledLanes|=r,a.entanglements[m]=a.entanglements[m]|1073741824|d&261930}function x1(a,r){var d=a.entangledLanes|=r;for(a=a.entanglements;d;){var m=31-ps(d),y=1<<m;y&r|a[m]&r&&(a[m]|=r),d&=~y}}function b1(a,r){var d=r&-r;return d=(d&42)!==0?1:hm(d),(d&(a.suspendedLanes|r))!==0?0:d}function hm(a){switch(a){case 2:a=1;break;case 8:a=4;break;case 32:a=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:a=128;break;case 268435456:a=134217728;break;default:a=0}return a}function dm(a){return a&=-a,2<a?8<a?(a&134217727)!==0?32:268435456:8:2}function y1(){var a=P.p;return a!==0?a:(a=window.event,a===void 0?32:oC(a.type))}function v1(a,r){var d=P.p;try{return P.p=a,r()}finally{P.p=d}}var ga=Math.random().toString(36).slice(2),$n="__reactFiber$"+ga,Qn="__reactProps$"+ga,fr="__reactContainer$"+ga,fm="__reactEvents$"+ga,KR="__reactListeners$"+ga,YR="__reactHandles$"+ga,w1="__reactResources$"+ga,Ll="__reactMarker$"+ga;function pm(a){delete a[$n],delete a[Qn],delete a[fm],delete a[KR],delete a[YR]}function pr(a){var r=a[$n];if(r)return r;for(var d=a.parentNode;d;){if(r=d[fr]||d[$n]){if(d=r.alternate,r.child!==null||d!==null&&d.child!==null)for(a=PS(a);a!==null;){if(d=a[$n])return d;a=PS(a)}return r}a=d,d=a.parentNode}return null}function mr(a){if(a=a[$n]||a[fr]){var r=a.tag;if(r===5||r===6||r===13||r===31||r===26||r===27||r===3)return a}return null}function Bl(a){var r=a.tag;if(r===5||r===26||r===27||r===6)return a.stateNode;throw Error(s(33))}function gr(a){var r=a[w1];return r||(r=a[w1]={hoistableStyles:new Map,hoistableScripts:new Map}),r}function xn(a){a[Ll]=!0}var S1=new Set,C1={};function pi(a,r){xr(a,r),xr(a+"Capture",r)}function xr(a,r){for(C1[a]=r,a=0;a<r.length;a++)S1.add(r[a])}var ZR=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),$1={},T1={};function QR(a){return ds.call(T1,a)?!0:ds.call($1,a)?!1:ZR.test(a)?T1[a]=!0:($1[a]=!0,!1)}function Sh(a,r,d){if(QR(r))if(d===null)a.removeAttribute(r);else{switch(typeof d){case"undefined":case"function":case"symbol":a.removeAttribute(r);return;case"boolean":var m=r.toLowerCase().slice(0,5);if(m!=="data-"&&m!=="aria-"){a.removeAttribute(r);return}}a.setAttribute(r,""+d)}}function Ch(a,r,d){if(d===null)a.removeAttribute(r);else{switch(typeof d){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(r);return}a.setAttribute(r,""+d)}}function Uo(a,r,d,m){if(m===null)a.removeAttribute(d);else{switch(typeof m){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(d);return}a.setAttributeNS(r,d,""+m)}}function Es(a){switch(typeof a){case"bigint":case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function k1(a){var r=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(r==="checkbox"||r==="radio")}function JR(a,r,d){var m=Object.getOwnPropertyDescriptor(a.constructor.prototype,r);if(!a.hasOwnProperty(r)&&typeof m<"u"&&typeof m.get=="function"&&typeof m.set=="function"){var y=m.get,w=m.set;return Object.defineProperty(a,r,{configurable:!0,get:function(){return y.call(this)},set:function(I){d=""+I,w.call(this,I)}}),Object.defineProperty(a,r,{enumerable:m.enumerable}),{getValue:function(){return d},setValue:function(I){d=""+I},stopTracking:function(){a._valueTracker=null,delete a[r]}}}}function mm(a){if(!a._valueTracker){var r=k1(a)?"checked":"value";a._valueTracker=JR(a,r,""+a[r])}}function I1(a){if(!a)return!1;var r=a._valueTracker;if(!r)return!0;var d=r.getValue(),m="";return a&&(m=k1(a)?a.checked?"true":"false":a.value),a=m,a!==d?(r.setValue(a),!0):!1}function $h(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}var tA=/[\n"\\]/g;function Rs(a){return a.replace(tA,function(r){return"\\"+r.charCodeAt(0).toString(16)+" "})}function gm(a,r,d,m,y,w,I,A){a.name="",I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"?a.type=I:a.removeAttribute("type"),r!=null?I==="number"?(r===0&&a.value===""||a.value!=r)&&(a.value=""+Es(r)):a.value!==""+Es(r)&&(a.value=""+Es(r)):I!=="submit"&&I!=="reset"||a.removeAttribute("value"),r!=null?xm(a,I,Es(r)):d!=null?xm(a,I,Es(d)):m!=null&&a.removeAttribute("value"),y==null&&w!=null&&(a.defaultChecked=!!w),y!=null&&(a.checked=y&&typeof y!="function"&&typeof y!="symbol"),A!=null&&typeof A!="function"&&typeof A!="symbol"&&typeof A!="boolean"?a.name=""+Es(A):a.removeAttribute("name")}function N1(a,r,d,m,y,w,I,A){if(w!=null&&typeof w!="function"&&typeof w!="symbol"&&typeof w!="boolean"&&(a.type=w),r!=null||d!=null){if(!(w!=="submit"&&w!=="reset"||r!=null)){mm(a);return}d=d!=null?""+Es(d):"",r=r!=null?""+Es(r):d,A||r===a.value||(a.value=r),a.defaultValue=r}m=m??y,m=typeof m!="function"&&typeof m!="symbol"&&!!m,a.checked=A?a.checked:!!m,a.defaultChecked=!!m,I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(a.name=I),mm(a)}function xm(a,r,d){r==="number"&&$h(a.ownerDocument)===a||a.defaultValue===""+d||(a.defaultValue=""+d)}function br(a,r,d,m){if(a=a.options,r){r={};for(var y=0;y<d.length;y++)r["$"+d[y]]=!0;for(d=0;d<a.length;d++)y=r.hasOwnProperty("$"+a[d].value),a[d].selected!==y&&(a[d].selected=y),y&&m&&(a[d].defaultSelected=!0)}else{for(d=""+Es(d),r=null,y=0;y<a.length;y++){if(a[y].value===d){a[y].selected=!0,m&&(a[y].defaultSelected=!0);return}r!==null||a[y].disabled||(r=a[y])}r!==null&&(r.selected=!0)}}function E1(a,r,d){if(r!=null&&(r=""+Es(r),r!==a.value&&(a.value=r),d==null)){a.defaultValue!==r&&(a.defaultValue=r);return}a.defaultValue=d!=null?""+Es(d):""}function R1(a,r,d,m){if(r==null){if(m!=null){if(d!=null)throw Error(s(92));if(q(m)){if(1<m.length)throw Error(s(93));m=m[0]}d=m}d==null&&(d=""),r=d}d=Es(r),a.defaultValue=d,m=a.textContent,m===d&&m!==""&&m!==null&&(a.value=m),mm(a)}function yr(a,r){if(r){var d=a.firstChild;if(d&&d===a.lastChild&&d.nodeType===3){d.nodeValue=r;return}}a.textContent=r}var eA=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function A1(a,r,d){var m=r.indexOf("--")===0;d==null||typeof d=="boolean"||d===""?m?a.setProperty(r,""):r==="float"?a.cssFloat="":a[r]="":m?a.setProperty(r,d):typeof d!="number"||d===0||eA.has(r)?r==="float"?a.cssFloat=d:a[r]=(""+d).trim():a[r]=d+"px"}function D1(a,r,d){if(r!=null&&typeof r!="object")throw Error(s(62));if(a=a.style,d!=null){for(var m in d)!d.hasOwnProperty(m)||r!=null&&r.hasOwnProperty(m)||(m.indexOf("--")===0?a.setProperty(m,""):m==="float"?a.cssFloat="":a[m]="");for(var y in r)m=r[y],r.hasOwnProperty(y)&&d[y]!==m&&A1(a,y,m)}else for(var w in r)r.hasOwnProperty(w)&&A1(a,w,r[w])}function bm(a){if(a.indexOf("-")===-1)return!1;switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var nA=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),sA=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Th(a){return sA.test(""+a)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":a}function Vo(){}var ym=null;function vm(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var vr=null,wr=null;function O1(a){var r=mr(a);if(r&&(a=r.stateNode)){var d=a[Qn]||null;t:switch(a=r.stateNode,r.type){case"input":if(gm(a,d.value,d.defaultValue,d.defaultValue,d.checked,d.defaultChecked,d.type,d.name),r=d.name,d.type==="radio"&&r!=null){for(d=a;d.parentNode;)d=d.parentNode;for(d=d.querySelectorAll('input[name="'+Rs(""+r)+'"][type="radio"]'),r=0;r<d.length;r++){var m=d[r];if(m!==a&&m.form===a.form){var y=m[Qn]||null;if(!y)throw Error(s(90));gm(m,y.value,y.defaultValue,y.defaultValue,y.checked,y.defaultChecked,y.type,y.name)}}for(r=0;r<d.length;r++)m=d[r],m.form===a.form&&I1(m)}break t;case"textarea":E1(a,d.value,d.defaultValue);break t;case"select":r=d.value,r!=null&&br(a,!!d.multiple,r,!1)}}}var wm=!1;function _1(a,r,d){if(wm)return a(r,d);wm=!0;try{var m=a(r);return m}finally{if(wm=!1,(vr!==null||wr!==null)&&(dd(),vr&&(r=vr,a=wr,wr=vr=null,O1(r),a)))for(r=0;r<a.length;r++)O1(a[r])}}function Ul(a,r){var d=a.stateNode;if(d===null)return null;var m=d[Qn]||null;if(m===null)return null;d=m[r];t:switch(r){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(m=!m.disabled)||(a=a.type,m=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!m;break t;default:a=!1}if(a)return null;if(d&&typeof d!="function")throw Error(s(231,r,typeof d));return d}var Po=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Sm=!1;if(Po)try{var Vl={};Object.defineProperty(Vl,"passive",{get:function(){Sm=!0}}),window.addEventListener("test",Vl,Vl),window.removeEventListener("test",Vl,Vl)}catch{Sm=!1}var xa=null,Cm=null,kh=null;function F1(){if(kh)return kh;var a,r=Cm,d=r.length,m,y="value"in xa?xa.value:xa.textContent,w=y.length;for(a=0;a<d&&r[a]===y[a];a++);var I=d-a;for(m=1;m<=I&&r[d-m]===y[w-m];m++);return kh=y.slice(a,1<m?1-m:void 0)}function Ih(a){var r=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&r===13&&(a=13)):a=r,a===10&&(a=13),32<=a||a===13?a:0}function Nh(){return!0}function M1(){return!1}function Jn(a){function r(d,m,y,w,I){this._reactName=d,this._targetInst=y,this.type=m,this.nativeEvent=w,this.target=I,this.currentTarget=null;for(var A in a)a.hasOwnProperty(A)&&(d=a[A],this[A]=d?d(w):w[A]);return this.isDefaultPrevented=(w.defaultPrevented!=null?w.defaultPrevented:w.returnValue===!1)?Nh:M1,this.isPropagationStopped=M1,this}return p(r.prototype,{preventDefault:function(){this.defaultPrevented=!0;var d=this.nativeEvent;d&&(d.preventDefault?d.preventDefault():typeof d.returnValue!="unknown"&&(d.returnValue=!1),this.isDefaultPrevented=Nh)},stopPropagation:function(){var d=this.nativeEvent;d&&(d.stopPropagation?d.stopPropagation():typeof d.cancelBubble!="unknown"&&(d.cancelBubble=!0),this.isPropagationStopped=Nh)},persist:function(){},isPersistent:Nh}),r}var mi={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Eh=Jn(mi),Pl=p({},mi,{view:0,detail:0}),oA=Jn(Pl),$m,Tm,Gl,Rh=p({},Pl,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Im,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==Gl&&(Gl&&a.type==="mousemove"?($m=a.screenX-Gl.screenX,Tm=a.screenY-Gl.screenY):Tm=$m=0,Gl=a),$m)},movementY:function(a){return"movementY"in a?a.movementY:Tm}}),z1=Jn(Rh),aA=p({},Rh,{dataTransfer:0}),iA=Jn(aA),rA=p({},Pl,{relatedTarget:0}),km=Jn(rA),lA=p({},mi,{animationName:0,elapsedTime:0,pseudoElement:0}),uA=Jn(lA),cA=p({},mi,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),hA=Jn(cA),dA=p({},mi,{data:0}),L1=Jn(dA),fA={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},pA={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},mA={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function gA(a){var r=this.nativeEvent;return r.getModifierState?r.getModifierState(a):(a=mA[a])?!!r[a]:!1}function Im(){return gA}var xA=p({},Pl,{key:function(a){if(a.key){var r=fA[a.key]||a.key;if(r!=="Unidentified")return r}return a.type==="keypress"?(a=Ih(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?pA[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Im,charCode:function(a){return a.type==="keypress"?Ih(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?Ih(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),bA=Jn(xA),yA=p({},Rh,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),B1=Jn(yA),vA=p({},Pl,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Im}),wA=Jn(vA),SA=p({},mi,{propertyName:0,elapsedTime:0,pseudoElement:0}),CA=Jn(SA),$A=p({},Rh,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),TA=Jn($A),kA=p({},mi,{newState:0,oldState:0}),IA=Jn(kA),NA=[9,13,27,32],Nm=Po&&"CompositionEvent"in window,Wl=null;Po&&"documentMode"in document&&(Wl=document.documentMode);var EA=Po&&"TextEvent"in window&&!Wl,U1=Po&&(!Nm||Wl&&8<Wl&&11>=Wl),V1=" ",P1=!1;function G1(a,r){switch(a){case"keyup":return NA.indexOf(r.keyCode)!==-1;case"keydown":return r.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function W1(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var Sr=!1;function RA(a,r){switch(a){case"compositionend":return W1(r);case"keypress":return r.which!==32?null:(P1=!0,V1);case"textInput":return a=r.data,a===V1&&P1?null:a;default:return null}}function AA(a,r){if(Sr)return a==="compositionend"||!Nm&&G1(a,r)?(a=F1(),kh=Cm=xa=null,Sr=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(r.ctrlKey||r.altKey||r.metaKey)||r.ctrlKey&&r.altKey){if(r.char&&1<r.char.length)return r.char;if(r.which)return String.fromCharCode(r.which)}return null;case"compositionend":return U1&&r.locale!=="ko"?null:r.data;default:return null}}var DA={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function H1(a){var r=a&&a.nodeName&&a.nodeName.toLowerCase();return r==="input"?!!DA[a.type]:r==="textarea"}function q1(a,r,d,m){vr?wr?wr.push(m):wr=[m]:vr=m,r=yd(r,"onChange"),0<r.length&&(d=new Eh("onChange","change",null,d,m),a.push({event:d,listeners:r}))}var Hl=null,ql=null;function OA(a){NS(a,0)}function Ah(a){var r=Bl(a);if(I1(r))return a}function j1(a,r){if(a==="change")return r}var X1=!1;if(Po){var Em;if(Po){var Rm="oninput"in document;if(!Rm){var K1=document.createElement("div");K1.setAttribute("oninput","return;"),Rm=typeof K1.oninput=="function"}Em=Rm}else Em=!1;X1=Em&&(!document.documentMode||9<document.documentMode)}function Y1(){Hl&&(Hl.detachEvent("onpropertychange",Z1),ql=Hl=null)}function Z1(a){if(a.propertyName==="value"&&Ah(ql)){var r=[];q1(r,ql,a,vm(a)),_1(OA,r)}}function _A(a,r,d){a==="focusin"?(Y1(),Hl=r,ql=d,Hl.attachEvent("onpropertychange",Z1)):a==="focusout"&&Y1()}function FA(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return Ah(ql)}function MA(a,r){if(a==="click")return Ah(r)}function zA(a,r){if(a==="input"||a==="change")return Ah(r)}function LA(a,r){return a===r&&(a!==0||1/a===1/r)||a!==a&&r!==r}var ms=typeof Object.is=="function"?Object.is:LA;function jl(a,r){if(ms(a,r))return!0;if(typeof a!="object"||a===null||typeof r!="object"||r===null)return!1;var d=Object.keys(a),m=Object.keys(r);if(d.length!==m.length)return!1;for(m=0;m<d.length;m++){var y=d[m];if(!ds.call(r,y)||!ms(a[y],r[y]))return!1}return!0}function Q1(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function J1(a,r){var d=Q1(a);a=0;for(var m;d;){if(d.nodeType===3){if(m=a+d.textContent.length,a<=r&&m>=r)return{node:d,offset:r-a};a=m}t:{for(;d;){if(d.nextSibling){d=d.nextSibling;break t}d=d.parentNode}d=void 0}d=Q1(d)}}function tv(a,r){return a&&r?a===r?!0:a&&a.nodeType===3?!1:r&&r.nodeType===3?tv(a,r.parentNode):"contains"in a?a.contains(r):a.compareDocumentPosition?!!(a.compareDocumentPosition(r)&16):!1:!1}function ev(a){a=a!=null&&a.ownerDocument!=null&&a.ownerDocument.defaultView!=null?a.ownerDocument.defaultView:window;for(var r=$h(a.document);r instanceof a.HTMLIFrameElement;){try{var d=typeof r.contentWindow.location.href=="string"}catch{d=!1}if(d)a=r.contentWindow;else break;r=$h(a.document)}return r}function Am(a){var r=a&&a.nodeName&&a.nodeName.toLowerCase();return r&&(r==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||r==="textarea"||a.contentEditable==="true")}var BA=Po&&"documentMode"in document&&11>=document.documentMode,Cr=null,Dm=null,Xl=null,Om=!1;function nv(a,r,d){var m=d.window===d?d.document:d.nodeType===9?d:d.ownerDocument;Om||Cr==null||Cr!==$h(m)||(m=Cr,"selectionStart"in m&&Am(m)?m={start:m.selectionStart,end:m.selectionEnd}:(m=(m.ownerDocument&&m.ownerDocument.defaultView||window).getSelection(),m={anchorNode:m.anchorNode,anchorOffset:m.anchorOffset,focusNode:m.focusNode,focusOffset:m.focusOffset}),Xl&&jl(Xl,m)||(Xl=m,m=yd(Dm,"onSelect"),0<m.length&&(r=new Eh("onSelect","select",null,r,d),a.push({event:r,listeners:m}),r.target=Cr)))}function gi(a,r){var d={};return d[a.toLowerCase()]=r.toLowerCase(),d["Webkit"+a]="webkit"+r,d["Moz"+a]="moz"+r,d}var $r={animationend:gi("Animation","AnimationEnd"),animationiteration:gi("Animation","AnimationIteration"),animationstart:gi("Animation","AnimationStart"),transitionrun:gi("Transition","TransitionRun"),transitionstart:gi("Transition","TransitionStart"),transitioncancel:gi("Transition","TransitionCancel"),transitionend:gi("Transition","TransitionEnd")},_m={},sv={};Po&&(sv=document.createElement("div").style,"AnimationEvent"in window||(delete $r.animationend.animation,delete $r.animationiteration.animation,delete $r.animationstart.animation),"TransitionEvent"in window||delete $r.transitionend.transition);function xi(a){if(_m[a])return _m[a];if(!$r[a])return a;var r=$r[a],d;for(d in r)if(r.hasOwnProperty(d)&&d in sv)return _m[a]=r[d];return a}var ov=xi("animationend"),av=xi("animationiteration"),iv=xi("animationstart"),UA=xi("transitionrun"),VA=xi("transitionstart"),PA=xi("transitioncancel"),rv=xi("transitionend"),lv=new Map,Fm="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Fm.push("scrollEnd");function Js(a,r){lv.set(a,r),pi(r,[a])}var Dh=typeof reportError=="function"?reportError:function(a){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var r=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof a=="object"&&a!==null&&typeof a.message=="string"?String(a.message):String(a),error:a});if(!window.dispatchEvent(r))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",a);return}console.error(a)},As=[],Tr=0,Mm=0;function Oh(){for(var a=Tr,r=Mm=Tr=0;r<a;){var d=As[r];As[r++]=null;var m=As[r];As[r++]=null;var y=As[r];As[r++]=null;var w=As[r];if(As[r++]=null,m!==null&&y!==null){var I=m.pending;I===null?y.next=y:(y.next=I.next,I.next=y),m.pending=y}w!==0&&uv(d,y,w)}}function _h(a,r,d,m){As[Tr++]=a,As[Tr++]=r,As[Tr++]=d,As[Tr++]=m,Mm|=m,a.lanes|=m,a=a.alternate,a!==null&&(a.lanes|=m)}function zm(a,r,d,m){return _h(a,r,d,m),Fh(a)}function bi(a,r){return _h(a,null,null,r),Fh(a)}function uv(a,r,d){a.lanes|=d;var m=a.alternate;m!==null&&(m.lanes|=d);for(var y=!1,w=a.return;w!==null;)w.childLanes|=d,m=w.alternate,m!==null&&(m.childLanes|=d),w.tag===22&&(a=w.stateNode,a===null||a._visibility&1||(y=!0)),a=w,w=w.return;return a.tag===3?(w=a.stateNode,y&&r!==null&&(y=31-ps(d),a=w.hiddenUpdates,m=a[y],m===null?a[y]=[r]:m.push(r),r.lane=d|536870912),w):null}function Fh(a){if(50<gu)throw gu=0,qg=null,Error(s(185));for(var r=a.return;r!==null;)a=r,r=a.return;return a.tag===3?a.stateNode:null}var kr={};function GA(a,r,d,m){this.tag=a,this.key=d,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=r,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=m,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function gs(a,r,d,m){return new GA(a,r,d,m)}function Lm(a){return a=a.prototype,!(!a||!a.isReactComponent)}function Go(a,r){var d=a.alternate;return d===null?(d=gs(a.tag,r,a.key,a.mode),d.elementType=a.elementType,d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.pendingProps=r,d.type=a.type,d.flags=0,d.subtreeFlags=0,d.deletions=null),d.flags=a.flags&65011712,d.childLanes=a.childLanes,d.lanes=a.lanes,d.child=a.child,d.memoizedProps=a.memoizedProps,d.memoizedState=a.memoizedState,d.updateQueue=a.updateQueue,r=a.dependencies,d.dependencies=r===null?null:{lanes:r.lanes,firstContext:r.firstContext},d.sibling=a.sibling,d.index=a.index,d.ref=a.ref,d.refCleanup=a.refCleanup,d}function cv(a,r){a.flags&=65011714;var d=a.alternate;return d===null?(a.childLanes=0,a.lanes=r,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=d.childLanes,a.lanes=d.lanes,a.child=d.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=d.memoizedProps,a.memoizedState=d.memoizedState,a.updateQueue=d.updateQueue,a.type=d.type,r=d.dependencies,a.dependencies=r===null?null:{lanes:r.lanes,firstContext:r.firstContext}),a}function Mh(a,r,d,m,y,w){var I=0;if(m=a,typeof a=="function")Lm(a)&&(I=1);else if(typeof a=="string")I=XD(a,d,ut.current)?26:a==="html"||a==="head"||a==="body"?27:5;else t:switch(a){case O:return a=gs(31,d,r,y),a.elementType=O,a.lanes=w,a;case v:return yi(d.children,y,w,r);case S:I=8,y|=24;break;case C:return a=gs(12,d,r,y|2),a.elementType=C,a.lanes=w,a;case N:return a=gs(13,d,r,y),a.elementType=N,a.lanes=w,a;case R:return a=gs(19,d,r,y),a.elementType=R,a.lanes=w,a;default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case k:I=10;break t;case $:I=9;break t;case T:I=11;break t;case D:I=14;break t;case z:I=16,m=null;break t}I=29,d=Error(s(130,a===null?"null":typeof a,"")),m=null}return r=gs(I,d,r,y),r.elementType=a,r.type=m,r.lanes=w,r}function yi(a,r,d,m){return a=gs(7,a,m,r),a.lanes=d,a}function Bm(a,r,d){return a=gs(6,a,null,r),a.lanes=d,a}function hv(a){var r=gs(18,null,null,0);return r.stateNode=a,r}function Um(a,r,d){return r=gs(4,a.children!==null?a.children:[],a.key,r),r.lanes=d,r.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},r}var dv=new WeakMap;function Ds(a,r){if(typeof a=="object"&&a!==null){var d=dv.get(a);return d!==void 0?d:(r={value:a,source:r,stack:ve(r)},dv.set(a,r),r)}return{value:a,source:r,stack:ve(r)}}var Ir=[],Nr=0,zh=null,Kl=0,Os=[],_s=0,ba=null,xo=1,bo="";function Wo(a,r){Ir[Nr++]=Kl,Ir[Nr++]=zh,zh=a,Kl=r}function fv(a,r,d){Os[_s++]=xo,Os[_s++]=bo,Os[_s++]=ba,ba=a;var m=xo;a=bo;var y=32-ps(m)-1;m&=~(1<<y),d+=1;var w=32-ps(r)+y;if(30<w){var I=y-y%5;w=(m&(1<<I)-1).toString(32),m>>=I,y-=I,xo=1<<32-ps(r)+y|d<<y|m,bo=w+a}else xo=1<<w|d<<y|m,bo=a}function Vm(a){a.return!==null&&(Wo(a,1),fv(a,1,0))}function Pm(a){for(;a===zh;)zh=Ir[--Nr],Ir[Nr]=null,Kl=Ir[--Nr],Ir[Nr]=null;for(;a===ba;)ba=Os[--_s],Os[_s]=null,bo=Os[--_s],Os[_s]=null,xo=Os[--_s],Os[_s]=null}function pv(a,r){Os[_s++]=xo,Os[_s++]=bo,Os[_s++]=ba,xo=r.id,bo=r.overflow,ba=a}var Tn=null,Oe=null,Qt=!1,ya=null,Fs=!1,Gm=Error(s(519));function va(a){var r=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Yl(Ds(r,a)),Gm}function mv(a){var r=a.stateNode,d=a.type,m=a.memoizedProps;switch(r[$n]=a,r[Qn]=m,d){case"dialog":Kt("cancel",r),Kt("close",r);break;case"iframe":case"object":case"embed":Kt("load",r);break;case"video":case"audio":for(d=0;d<bu.length;d++)Kt(bu[d],r);break;case"source":Kt("error",r);break;case"img":case"image":case"link":Kt("error",r),Kt("load",r);break;case"details":Kt("toggle",r);break;case"input":Kt("invalid",r),N1(r,m.value,m.defaultValue,m.checked,m.defaultChecked,m.type,m.name,!0);break;case"select":Kt("invalid",r);break;case"textarea":Kt("invalid",r),R1(r,m.value,m.defaultValue,m.children)}d=m.children,typeof d!="string"&&typeof d!="number"&&typeof d!="bigint"||r.textContent===""+d||m.suppressHydrationWarning===!0||DS(r.textContent,d)?(m.popover!=null&&(Kt("beforetoggle",r),Kt("toggle",r)),m.onScroll!=null&&Kt("scroll",r),m.onScrollEnd!=null&&Kt("scrollend",r),m.onClick!=null&&(r.onclick=Vo),r=!0):r=!1,r||va(a,!0)}function gv(a){for(Tn=a.return;Tn;)switch(Tn.tag){case 5:case 31:case 13:Fs=!1;return;case 27:case 3:Fs=!0;return;default:Tn=Tn.return}}function Er(a){if(a!==Tn)return!1;if(!Qt)return gv(a),Qt=!0,!1;var r=a.tag,d;if((d=r!==3&&r!==27)&&((d=r===5)&&(d=a.type,d=!(d!=="form"&&d!=="button")||rx(a.type,a.memoizedProps)),d=!d),d&&Oe&&va(a),gv(a),r===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));Oe=VS(a)}else if(r===31){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));Oe=VS(a)}else r===27?(r=Oe,_a(a.type)?(a=dx,dx=null,Oe=a):Oe=r):Oe=Tn?zs(a.stateNode.nextSibling):null;return!0}function vi(){Oe=Tn=null,Qt=!1}function Wm(){var a=ya;return a!==null&&(ss===null?ss=a:ss.push.apply(ss,a),ya=null),a}function Yl(a){ya===null?ya=[a]:ya.push(a)}var Hm=M(null),wi=null,Ho=null;function wa(a,r,d){Q(Hm,r._currentValue),r._currentValue=d}function qo(a){a._currentValue=Hm.current,G(Hm)}function qm(a,r,d){for(;a!==null;){var m=a.alternate;if((a.childLanes&r)!==r?(a.childLanes|=r,m!==null&&(m.childLanes|=r)):m!==null&&(m.childLanes&r)!==r&&(m.childLanes|=r),a===d)break;a=a.return}}function jm(a,r,d,m){var y=a.child;for(y!==null&&(y.return=a);y!==null;){var w=y.dependencies;if(w!==null){var I=y.child;w=w.firstContext;t:for(;w!==null;){var A=w;w=y;for(var V=0;V<r.length;V++)if(A.context===r[V]){w.lanes|=d,A=w.alternate,A!==null&&(A.lanes|=d),qm(w.return,d,a),m||(I=null);break t}w=A.next}}else if(y.tag===18){if(I=y.return,I===null)throw Error(s(341));I.lanes|=d,w=I.alternate,w!==null&&(w.lanes|=d),qm(I,d,a),I=null}else I=y.child;if(I!==null)I.return=y;else for(I=y;I!==null;){if(I===a){I=null;break}if(y=I.sibling,y!==null){y.return=I.return,I=y;break}I=I.return}y=I}}function Rr(a,r,d,m){a=null;for(var y=r,w=!1;y!==null;){if(!w){if((y.flags&524288)!==0)w=!0;else if((y.flags&262144)!==0)break}if(y.tag===10){var I=y.alternate;if(I===null)throw Error(s(387));if(I=I.memoizedProps,I!==null){var A=y.type;ms(y.pendingProps.value,I.value)||(a!==null?a.push(A):a=[A])}}else if(y===yt.current){if(I=y.alternate,I===null)throw Error(s(387));I.memoizedState.memoizedState!==y.memoizedState.memoizedState&&(a!==null?a.push(Cu):a=[Cu])}y=y.return}a!==null&&jm(r,a,d,m),r.flags|=262144}function Lh(a){for(a=a.firstContext;a!==null;){if(!ms(a.context._currentValue,a.memoizedValue))return!0;a=a.next}return!1}function Si(a){wi=a,Ho=null,a=a.dependencies,a!==null&&(a.firstContext=null)}function kn(a){return xv(wi,a)}function Bh(a,r){return wi===null&&Si(a),xv(a,r)}function xv(a,r){var d=r._currentValue;if(r={context:r,memoizedValue:d,next:null},Ho===null){if(a===null)throw Error(s(308));Ho=r,a.dependencies={lanes:0,firstContext:r},a.flags|=524288}else Ho=Ho.next=r;return d}var WA=typeof AbortController<"u"?AbortController:function(){var a=[],r=this.signal={aborted:!1,addEventListener:function(d,m){a.push(m)}};this.abort=function(){r.aborted=!0,a.forEach(function(d){return d()})}},HA=n.unstable_scheduleCallback,qA=n.unstable_NormalPriority,Je={$$typeof:k,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Xm(){return{controller:new WA,data:new Map,refCount:0}}function Zl(a){a.refCount--,a.refCount===0&&HA(qA,function(){a.controller.abort()})}var Ql=null,Km=0,Ar=0,Dr=null;function jA(a,r){if(Ql===null){var d=Ql=[];Km=0,Ar=Qg(),Dr={status:"pending",value:void 0,then:function(m){d.push(m)}}}return Km++,r.then(bv,bv),r}function bv(){if(--Km===0&&Ql!==null){Dr!==null&&(Dr.status="fulfilled");var a=Ql;Ql=null,Ar=0,Dr=null;for(var r=0;r<a.length;r++)(0,a[r])()}}function XA(a,r){var d=[],m={status:"pending",value:null,reason:null,then:function(y){d.push(y)}};return a.then(function(){m.status="fulfilled",m.value=r;for(var y=0;y<d.length;y++)(0,d[y])(r)},function(y){for(m.status="rejected",m.reason=y,y=0;y<d.length;y++)(0,d[y])(void 0)}),m}var yv=L.S;L.S=function(a,r){nS=De(),typeof r=="object"&&r!==null&&typeof r.then=="function"&&jA(a,r),yv!==null&&yv(a,r)};var Ci=M(null);function Ym(){var a=Ci.current;return a!==null?a:ke.pooledCache}function Uh(a,r){r===null?Q(Ci,Ci.current):Q(Ci,r.pool)}function vv(){var a=Ym();return a===null?null:{parent:Je._currentValue,pool:a}}var Or=Error(s(460)),Zm=Error(s(474)),Vh=Error(s(542)),Ph={then:function(){}};function wv(a){return a=a.status,a==="fulfilled"||a==="rejected"}function Sv(a,r,d){switch(d=a[d],d===void 0?a.push(r):d!==r&&(r.then(Vo,Vo),r=d),r.status){case"fulfilled":return r.value;case"rejected":throw a=r.reason,$v(a),a;default:if(typeof r.status=="string")r.then(Vo,Vo);else{if(a=ke,a!==null&&100<a.shellSuspendCounter)throw Error(s(482));a=r,a.status="pending",a.then(function(m){if(r.status==="pending"){var y=r;y.status="fulfilled",y.value=m}},function(m){if(r.status==="pending"){var y=r;y.status="rejected",y.reason=m}})}switch(r.status){case"fulfilled":return r.value;case"rejected":throw a=r.reason,$v(a),a}throw Ti=r,Or}}function $i(a){try{var r=a._init;return r(a._payload)}catch(d){throw d!==null&&typeof d=="object"&&typeof d.then=="function"?(Ti=d,Or):d}}var Ti=null;function Cv(){if(Ti===null)throw Error(s(459));var a=Ti;return Ti=null,a}function $v(a){if(a===Or||a===Vh)throw Error(s(483))}var _r=null,Jl=0;function Gh(a){var r=Jl;return Jl+=1,_r===null&&(_r=[]),Sv(_r,a,r)}function tu(a,r){r=r.props.ref,a.ref=r!==void 0?r:null}function Wh(a,r){throw r.$$typeof===g?Error(s(525)):(a=Object.prototype.toString.call(r),Error(s(31,a==="[object Object]"?"object with keys {"+Object.keys(r).join(", ")+"}":a)))}function Tv(a){function r(et,j){if(a){var ot=et.deletions;ot===null?(et.deletions=[j],et.flags|=16):ot.push(j)}}function d(et,j){if(!a)return null;for(;j!==null;)r(et,j),j=j.sibling;return null}function m(et){for(var j=new Map;et!==null;)et.key!==null?j.set(et.key,et):j.set(et.index,et),et=et.sibling;return j}function y(et,j){return et=Go(et,j),et.index=0,et.sibling=null,et}function w(et,j,ot){return et.index=ot,a?(ot=et.alternate,ot!==null?(ot=ot.index,ot<j?(et.flags|=67108866,j):ot):(et.flags|=67108866,j)):(et.flags|=1048576,j)}function I(et){return a&&et.alternate===null&&(et.flags|=67108866),et}function A(et,j,ot,mt){return j===null||j.tag!==6?(j=Bm(ot,et.mode,mt),j.return=et,j):(j=y(j,ot),j.return=et,j)}function V(et,j,ot,mt){var Dt=ot.type;return Dt===v?pt(et,j,ot.props.children,mt,ot.key):j!==null&&(j.elementType===Dt||typeof Dt=="object"&&Dt!==null&&Dt.$$typeof===z&&$i(Dt)===j.type)?(j=y(j,ot.props),tu(j,ot),j.return=et,j):(j=Mh(ot.type,ot.key,ot.props,null,et.mode,mt),tu(j,ot),j.return=et,j)}function at(et,j,ot,mt){return j===null||j.tag!==4||j.stateNode.containerInfo!==ot.containerInfo||j.stateNode.implementation!==ot.implementation?(j=Um(ot,et.mode,mt),j.return=et,j):(j=y(j,ot.children||[]),j.return=et,j)}function pt(et,j,ot,mt,Dt){return j===null||j.tag!==7?(j=yi(ot,et.mode,mt,Dt),j.return=et,j):(j=y(j,ot),j.return=et,j)}function xt(et,j,ot){if(typeof j=="string"&&j!==""||typeof j=="number"||typeof j=="bigint")return j=Bm(""+j,et.mode,ot),j.return=et,j;if(typeof j=="object"&&j!==null){switch(j.$$typeof){case x:return ot=Mh(j.type,j.key,j.props,null,et.mode,ot),tu(ot,j),ot.return=et,ot;case b:return j=Um(j,et.mode,ot),j.return=et,j;case z:return j=$i(j),xt(et,j,ot)}if(q(j)||U(j))return j=yi(j,et.mode,ot,null),j.return=et,j;if(typeof j.then=="function")return xt(et,Gh(j),ot);if(j.$$typeof===k)return xt(et,Bh(et,j),ot);Wh(et,j)}return null}function rt(et,j,ot,mt){var Dt=j!==null?j.key:null;if(typeof ot=="string"&&ot!==""||typeof ot=="number"||typeof ot=="bigint")return Dt!==null?null:A(et,j,""+ot,mt);if(typeof ot=="object"&&ot!==null){switch(ot.$$typeof){case x:return ot.key===Dt?V(et,j,ot,mt):null;case b:return ot.key===Dt?at(et,j,ot,mt):null;case z:return ot=$i(ot),rt(et,j,ot,mt)}if(q(ot)||U(ot))return Dt!==null?null:pt(et,j,ot,mt,null);if(typeof ot.then=="function")return rt(et,j,Gh(ot),mt);if(ot.$$typeof===k)return rt(et,j,Bh(et,ot),mt);Wh(et,ot)}return null}function ct(et,j,ot,mt,Dt){if(typeof mt=="string"&&mt!==""||typeof mt=="number"||typeof mt=="bigint")return et=et.get(ot)||null,A(j,et,""+mt,Dt);if(typeof mt=="object"&&mt!==null){switch(mt.$$typeof){case x:return et=et.get(mt.key===null?ot:mt.key)||null,V(j,et,mt,Dt);case b:return et=et.get(mt.key===null?ot:mt.key)||null,at(j,et,mt,Dt);case z:return mt=$i(mt),ct(et,j,ot,mt,Dt)}if(q(mt)||U(mt))return et=et.get(ot)||null,pt(j,et,mt,Dt,null);if(typeof mt.then=="function")return ct(et,j,ot,Gh(mt),Dt);if(mt.$$typeof===k)return ct(et,j,ot,Bh(j,mt),Dt);Wh(j,mt)}return null}function kt(et,j,ot,mt){for(var Dt=null,ie=null,Et=j,Gt=j=0,Zt=null;Et!==null&&Gt<ot.length;Gt++){Et.index>Gt?(Zt=Et,Et=null):Zt=Et.sibling;var re=rt(et,Et,ot[Gt],mt);if(re===null){Et===null&&(Et=Zt);break}a&&Et&&re.alternate===null&&r(et,Et),j=w(re,j,Gt),ie===null?Dt=re:ie.sibling=re,ie=re,Et=Zt}if(Gt===ot.length)return d(et,Et),Qt&&Wo(et,Gt),Dt;if(Et===null){for(;Gt<ot.length;Gt++)Et=xt(et,ot[Gt],mt),Et!==null&&(j=w(Et,j,Gt),ie===null?Dt=Et:ie.sibling=Et,ie=Et);return Qt&&Wo(et,Gt),Dt}for(Et=m(Et);Gt<ot.length;Gt++)Zt=ct(Et,et,Gt,ot[Gt],mt),Zt!==null&&(a&&Zt.alternate!==null&&Et.delete(Zt.key===null?Gt:Zt.key),j=w(Zt,j,Gt),ie===null?Dt=Zt:ie.sibling=Zt,ie=Zt);return a&&Et.forEach(function(Ba){return r(et,Ba)}),Qt&&Wo(et,Gt),Dt}function _t(et,j,ot,mt){if(ot==null)throw Error(s(151));for(var Dt=null,ie=null,Et=j,Gt=j=0,Zt=null,re=ot.next();Et!==null&&!re.done;Gt++,re=ot.next()){Et.index>Gt?(Zt=Et,Et=null):Zt=Et.sibling;var Ba=rt(et,Et,re.value,mt);if(Ba===null){Et===null&&(Et=Zt);break}a&&Et&&Ba.alternate===null&&r(et,Et),j=w(Ba,j,Gt),ie===null?Dt=Ba:ie.sibling=Ba,ie=Ba,Et=Zt}if(re.done)return d(et,Et),Qt&&Wo(et,Gt),Dt;if(Et===null){for(;!re.done;Gt++,re=ot.next())re=xt(et,re.value,mt),re!==null&&(j=w(re,j,Gt),ie===null?Dt=re:ie.sibling=re,ie=re);return Qt&&Wo(et,Gt),Dt}for(Et=m(Et);!re.done;Gt++,re=ot.next())re=ct(Et,et,Gt,re.value,mt),re!==null&&(a&&re.alternate!==null&&Et.delete(re.key===null?Gt:re.key),j=w(re,j,Gt),ie===null?Dt=re:ie.sibling=re,ie=re);return a&&Et.forEach(function(aO){return r(et,aO)}),Qt&&Wo(et,Gt),Dt}function Ce(et,j,ot,mt){if(typeof ot=="object"&&ot!==null&&ot.type===v&&ot.key===null&&(ot=ot.props.children),typeof ot=="object"&&ot!==null){switch(ot.$$typeof){case x:t:{for(var Dt=ot.key;j!==null;){if(j.key===Dt){if(Dt=ot.type,Dt===v){if(j.tag===7){d(et,j.sibling),mt=y(j,ot.props.children),mt.return=et,et=mt;break t}}else if(j.elementType===Dt||typeof Dt=="object"&&Dt!==null&&Dt.$$typeof===z&&$i(Dt)===j.type){d(et,j.sibling),mt=y(j,ot.props),tu(mt,ot),mt.return=et,et=mt;break t}d(et,j);break}else r(et,j);j=j.sibling}ot.type===v?(mt=yi(ot.props.children,et.mode,mt,ot.key),mt.return=et,et=mt):(mt=Mh(ot.type,ot.key,ot.props,null,et.mode,mt),tu(mt,ot),mt.return=et,et=mt)}return I(et);case b:t:{for(Dt=ot.key;j!==null;){if(j.key===Dt)if(j.tag===4&&j.stateNode.containerInfo===ot.containerInfo&&j.stateNode.implementation===ot.implementation){d(et,j.sibling),mt=y(j,ot.children||[]),mt.return=et,et=mt;break t}else{d(et,j);break}else r(et,j);j=j.sibling}mt=Um(ot,et.mode,mt),mt.return=et,et=mt}return I(et);case z:return ot=$i(ot),Ce(et,j,ot,mt)}if(q(ot))return kt(et,j,ot,mt);if(U(ot)){if(Dt=U(ot),typeof Dt!="function")throw Error(s(150));return ot=Dt.call(ot),_t(et,j,ot,mt)}if(typeof ot.then=="function")return Ce(et,j,Gh(ot),mt);if(ot.$$typeof===k)return Ce(et,j,Bh(et,ot),mt);Wh(et,ot)}return typeof ot=="string"&&ot!==""||typeof ot=="number"||typeof ot=="bigint"?(ot=""+ot,j!==null&&j.tag===6?(d(et,j.sibling),mt=y(j,ot),mt.return=et,et=mt):(d(et,j),mt=Bm(ot,et.mode,mt),mt.return=et,et=mt),I(et)):d(et,j)}return function(et,j,ot,mt){try{Jl=0;var Dt=Ce(et,j,ot,mt);return _r=null,Dt}catch(Et){if(Et===Or||Et===Vh)throw Et;var ie=gs(29,Et,null,et.mode);return ie.lanes=mt,ie.return=et,ie}}}var ki=Tv(!0),kv=Tv(!1),Sa=!1;function Qm(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Jm(a,r){a=a.updateQueue,r.updateQueue===a&&(r.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,callbacks:null})}function Ca(a){return{lane:a,tag:0,payload:null,callback:null,next:null}}function $a(a,r,d){var m=a.updateQueue;if(m===null)return null;if(m=m.shared,(fe&2)!==0){var y=m.pending;return y===null?r.next=r:(r.next=y.next,y.next=r),m.pending=r,r=Fh(a),uv(a,null,d),r}return _h(a,m,r,d),Fh(a)}function eu(a,r,d){if(r=r.updateQueue,r!==null&&(r=r.shared,(d&4194048)!==0)){var m=r.lanes;m&=a.pendingLanes,d|=m,r.lanes=d,x1(a,d)}}function tg(a,r){var d=a.updateQueue,m=a.alternate;if(m!==null&&(m=m.updateQueue,d===m)){var y=null,w=null;if(d=d.firstBaseUpdate,d!==null){do{var I={lane:d.lane,tag:d.tag,payload:d.payload,callback:null,next:null};w===null?y=w=I:w=w.next=I,d=d.next}while(d!==null);w===null?y=w=r:w=w.next=r}else y=w=r;d={baseState:m.baseState,firstBaseUpdate:y,lastBaseUpdate:w,shared:m.shared,callbacks:m.callbacks},a.updateQueue=d;return}a=d.lastBaseUpdate,a===null?d.firstBaseUpdate=r:a.next=r,d.lastBaseUpdate=r}var eg=!1;function nu(){if(eg){var a=Dr;if(a!==null)throw a}}function su(a,r,d,m){eg=!1;var y=a.updateQueue;Sa=!1;var w=y.firstBaseUpdate,I=y.lastBaseUpdate,A=y.shared.pending;if(A!==null){y.shared.pending=null;var V=A,at=V.next;V.next=null,I===null?w=at:I.next=at,I=V;var pt=a.alternate;pt!==null&&(pt=pt.updateQueue,A=pt.lastBaseUpdate,A!==I&&(A===null?pt.firstBaseUpdate=at:A.next=at,pt.lastBaseUpdate=V))}if(w!==null){var xt=y.baseState;I=0,pt=at=V=null,A=w;do{var rt=A.lane&-536870913,ct=rt!==A.lane;if(ct?(Yt&rt)===rt:(m&rt)===rt){rt!==0&&rt===Ar&&(eg=!0),pt!==null&&(pt=pt.next={lane:0,tag:A.tag,payload:A.payload,callback:null,next:null});t:{var kt=a,_t=A;rt=r;var Ce=d;switch(_t.tag){case 1:if(kt=_t.payload,typeof kt=="function"){xt=kt.call(Ce,xt,rt);break t}xt=kt;break t;case 3:kt.flags=kt.flags&-65537|128;case 0:if(kt=_t.payload,rt=typeof kt=="function"?kt.call(Ce,xt,rt):kt,rt==null)break t;xt=p({},xt,rt);break t;case 2:Sa=!0}}rt=A.callback,rt!==null&&(a.flags|=64,ct&&(a.flags|=8192),ct=y.callbacks,ct===null?y.callbacks=[rt]:ct.push(rt))}else ct={lane:rt,tag:A.tag,payload:A.payload,callback:A.callback,next:null},pt===null?(at=pt=ct,V=xt):pt=pt.next=ct,I|=rt;if(A=A.next,A===null){if(A=y.shared.pending,A===null)break;ct=A,A=ct.next,ct.next=null,y.lastBaseUpdate=ct,y.shared.pending=null}}while(!0);pt===null&&(V=xt),y.baseState=V,y.firstBaseUpdate=at,y.lastBaseUpdate=pt,w===null&&(y.shared.lanes=0),Ea|=I,a.lanes=I,a.memoizedState=xt}}function Iv(a,r){if(typeof a!="function")throw Error(s(191,a));a.call(r)}function Nv(a,r){var d=a.callbacks;if(d!==null)for(a.callbacks=null,a=0;a<d.length;a++)Iv(d[a],r)}var Fr=M(null),Hh=M(0);function Ev(a,r){a=ea,Q(Hh,a),Q(Fr,r),ea=a|r.baseLanes}function ng(){Q(Hh,ea),Q(Fr,Fr.current)}function sg(){ea=Hh.current,G(Fr),G(Hh)}var xs=M(null),Ms=null;function Ta(a){var r=a.alternate;Q(Ke,Ke.current&1),Q(xs,a),Ms===null&&(r===null||Fr.current!==null||r.memoizedState!==null)&&(Ms=a)}function og(a){Q(Ke,Ke.current),Q(xs,a),Ms===null&&(Ms=a)}function Rv(a){a.tag===22?(Q(Ke,Ke.current),Q(xs,a),Ms===null&&(Ms=a)):ka()}function ka(){Q(Ke,Ke.current),Q(xs,xs.current)}function bs(a){G(xs),Ms===a&&(Ms=null),G(Ke)}var Ke=M(0);function qh(a){for(var r=a;r!==null;){if(r.tag===13){var d=r.memoizedState;if(d!==null&&(d=d.dehydrated,d===null||cx(d)||hx(d)))return r}else if(r.tag===19&&(r.memoizedProps.revealOrder==="forwards"||r.memoizedProps.revealOrder==="backwards"||r.memoizedProps.revealOrder==="unstable_legacy-backwards"||r.memoizedProps.revealOrder==="together")){if((r.flags&128)!==0)return r}else if(r.child!==null){r.child.return=r,r=r.child;continue}if(r===a)break;for(;r.sibling===null;){if(r.return===null||r.return===a)return null;r=r.return}r.sibling.return=r.return,r=r.sibling}return null}var jo=0,Vt=null,we=null,tn=null,jh=!1,Mr=!1,Ii=!1,Xh=0,ou=0,zr=null,KA=0;function Ve(){throw Error(s(321))}function ag(a,r){if(r===null)return!1;for(var d=0;d<r.length&&d<a.length;d++)if(!ms(a[d],r[d]))return!1;return!0}function ig(a,r,d,m,y,w){return jo=w,Vt=r,r.memoizedState=null,r.updateQueue=null,r.lanes=0,L.H=a===null||a.memoizedState===null?fw:wg,Ii=!1,w=d(m,y),Ii=!1,Mr&&(w=Dv(r,d,m,y)),Av(a),w}function Av(a){L.H=ru;var r=we!==null&&we.next!==null;if(jo=0,tn=we=Vt=null,jh=!1,ou=0,zr=null,r)throw Error(s(300));a===null||en||(a=a.dependencies,a!==null&&Lh(a)&&(en=!0))}function Dv(a,r,d,m){Vt=a;var y=0;do{if(Mr&&(zr=null),ou=0,Mr=!1,25<=y)throw Error(s(301));if(y+=1,tn=we=null,a.updateQueue!=null){var w=a.updateQueue;w.lastEffect=null,w.events=null,w.stores=null,w.memoCache!=null&&(w.memoCache.index=0)}L.H=pw,w=r(d,m)}while(Mr);return w}function YA(){var a=L.H,r=a.useState()[0];return r=typeof r.then=="function"?au(r):r,a=a.useState()[0],(we!==null?we.memoizedState:null)!==a&&(Vt.flags|=1024),r}function rg(){var a=Xh!==0;return Xh=0,a}function lg(a,r,d){r.updateQueue=a.updateQueue,r.flags&=-2053,a.lanes&=~d}function ug(a){if(jh){for(a=a.memoizedState;a!==null;){var r=a.queue;r!==null&&(r.pending=null),a=a.next}jh=!1}jo=0,tn=we=Vt=null,Mr=!1,ou=Xh=0,zr=null}function Wn(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return tn===null?Vt.memoizedState=tn=a:tn=tn.next=a,tn}function Ye(){if(we===null){var a=Vt.alternate;a=a!==null?a.memoizedState:null}else a=we.next;var r=tn===null?Vt.memoizedState:tn.next;if(r!==null)tn=r,we=a;else{if(a===null)throw Vt.alternate===null?Error(s(467)):Error(s(310));we=a,a={memoizedState:we.memoizedState,baseState:we.baseState,baseQueue:we.baseQueue,queue:we.queue,next:null},tn===null?Vt.memoizedState=tn=a:tn=tn.next=a}return tn}function Kh(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function au(a){var r=ou;return ou+=1,zr===null&&(zr=[]),a=Sv(zr,a,r),r=Vt,(tn===null?r.memoizedState:tn.next)===null&&(r=r.alternate,L.H=r===null||r.memoizedState===null?fw:wg),a}function Yh(a){if(a!==null&&typeof a=="object"){if(typeof a.then=="function")return au(a);if(a.$$typeof===k)return kn(a)}throw Error(s(438,String(a)))}function cg(a){var r=null,d=Vt.updateQueue;if(d!==null&&(r=d.memoCache),r==null){var m=Vt.alternate;m!==null&&(m=m.updateQueue,m!==null&&(m=m.memoCache,m!=null&&(r={data:m.data.map(function(y){return y.slice()}),index:0})))}if(r==null&&(r={data:[],index:0}),d===null&&(d=Kh(),Vt.updateQueue=d),d.memoCache=r,d=r.data[r.index],d===void 0)for(d=r.data[r.index]=Array(a),m=0;m<a;m++)d[m]=F;return r.index++,d}function Xo(a,r){return typeof r=="function"?r(a):r}function Zh(a){var r=Ye();return hg(r,we,a)}function hg(a,r,d){var m=a.queue;if(m===null)throw Error(s(311));m.lastRenderedReducer=d;var y=a.baseQueue,w=m.pending;if(w!==null){if(y!==null){var I=y.next;y.next=w.next,w.next=I}r.baseQueue=y=w,m.pending=null}if(w=a.baseState,y===null)a.memoizedState=w;else{r=y.next;var A=I=null,V=null,at=r,pt=!1;do{var xt=at.lane&-536870913;if(xt!==at.lane?(Yt&xt)===xt:(jo&xt)===xt){var rt=at.revertLane;if(rt===0)V!==null&&(V=V.next={lane:0,revertLane:0,gesture:null,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null}),xt===Ar&&(pt=!0);else if((jo&rt)===rt){at=at.next,rt===Ar&&(pt=!0);continue}else xt={lane:0,revertLane:at.revertLane,gesture:null,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null},V===null?(A=V=xt,I=w):V=V.next=xt,Vt.lanes|=rt,Ea|=rt;xt=at.action,Ii&&d(w,xt),w=at.hasEagerState?at.eagerState:d(w,xt)}else rt={lane:xt,revertLane:at.revertLane,gesture:at.gesture,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null},V===null?(A=V=rt,I=w):V=V.next=rt,Vt.lanes|=xt,Ea|=xt;at=at.next}while(at!==null&&at!==r);if(V===null?I=w:V.next=A,!ms(w,a.memoizedState)&&(en=!0,pt&&(d=Dr,d!==null)))throw d;a.memoizedState=w,a.baseState=I,a.baseQueue=V,m.lastRenderedState=w}return y===null&&(m.lanes=0),[a.memoizedState,m.dispatch]}function dg(a){var r=Ye(),d=r.queue;if(d===null)throw Error(s(311));d.lastRenderedReducer=a;var m=d.dispatch,y=d.pending,w=r.memoizedState;if(y!==null){d.pending=null;var I=y=y.next;do w=a(w,I.action),I=I.next;while(I!==y);ms(w,r.memoizedState)||(en=!0),r.memoizedState=w,r.baseQueue===null&&(r.baseState=w),d.lastRenderedState=w}return[w,m]}function Ov(a,r,d){var m=Vt,y=Ye(),w=Qt;if(w){if(d===void 0)throw Error(s(407));d=d()}else d=r();var I=!ms((we||y).memoizedState,d);if(I&&(y.memoizedState=d,en=!0),y=y.queue,mg(Mv.bind(null,m,y,a),[a]),y.getSnapshot!==r||I||tn!==null&&tn.memoizedState.tag&1){if(m.flags|=2048,Lr(9,{destroy:void 0},Fv.bind(null,m,y,d,r),null),ke===null)throw Error(s(349));w||(jo&127)!==0||_v(m,r,d)}return d}function _v(a,r,d){a.flags|=16384,a={getSnapshot:r,value:d},r=Vt.updateQueue,r===null?(r=Kh(),Vt.updateQueue=r,r.stores=[a]):(d=r.stores,d===null?r.stores=[a]:d.push(a))}function Fv(a,r,d,m){r.value=d,r.getSnapshot=m,zv(r)&&Lv(a)}function Mv(a,r,d){return d(function(){zv(r)&&Lv(a)})}function zv(a){var r=a.getSnapshot;a=a.value;try{var d=r();return!ms(a,d)}catch{return!0}}function Lv(a){var r=bi(a,2);r!==null&&os(r,a,2)}function fg(a){var r=Wn();if(typeof a=="function"){var d=a;if(a=d(),Ii){go(!0);try{d()}finally{go(!1)}}}return r.memoizedState=r.baseState=a,r.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Xo,lastRenderedState:a},r}function Bv(a,r,d,m){return a.baseState=d,hg(a,we,typeof m=="function"?m:Xo)}function ZA(a,r,d,m,y){if(td(a))throw Error(s(485));if(a=r.action,a!==null){var w={payload:y,action:a,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(I){w.listeners.push(I)}};L.T!==null?d(!0):w.isTransition=!1,m(w),d=r.pending,d===null?(w.next=r.pending=w,Uv(r,w)):(w.next=d.next,r.pending=d.next=w)}}function Uv(a,r){var d=r.action,m=r.payload,y=a.state;if(r.isTransition){var w=L.T,I={};L.T=I;try{var A=d(y,m),V=L.S;V!==null&&V(I,A),Vv(a,r,A)}catch(at){pg(a,r,at)}finally{w!==null&&I.types!==null&&(w.types=I.types),L.T=w}}else try{w=d(y,m),Vv(a,r,w)}catch(at){pg(a,r,at)}}function Vv(a,r,d){d!==null&&typeof d=="object"&&typeof d.then=="function"?d.then(function(m){Pv(a,r,m)},function(m){return pg(a,r,m)}):Pv(a,r,d)}function Pv(a,r,d){r.status="fulfilled",r.value=d,Gv(r),a.state=d,r=a.pending,r!==null&&(d=r.next,d===r?a.pending=null:(d=d.next,r.next=d,Uv(a,d)))}function pg(a,r,d){var m=a.pending;if(a.pending=null,m!==null){m=m.next;do r.status="rejected",r.reason=d,Gv(r),r=r.next;while(r!==m)}a.action=null}function Gv(a){a=a.listeners;for(var r=0;r<a.length;r++)(0,a[r])()}function Wv(a,r){return r}function Hv(a,r){if(Qt){var d=ke.formState;if(d!==null){t:{var m=Vt;if(Qt){if(Oe){e:{for(var y=Oe,w=Fs;y.nodeType!==8;){if(!w){y=null;break e}if(y=zs(y.nextSibling),y===null){y=null;break e}}w=y.data,y=w==="F!"||w==="F"?y:null}if(y){Oe=zs(y.nextSibling),m=y.data==="F!";break t}}va(m)}m=!1}m&&(r=d[0])}}return d=Wn(),d.memoizedState=d.baseState=r,m={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Wv,lastRenderedState:r},d.queue=m,d=cw.bind(null,Vt,m),m.dispatch=d,m=fg(!1),w=vg.bind(null,Vt,!1,m.queue),m=Wn(),y={state:r,dispatch:null,action:a,pending:null},m.queue=y,d=ZA.bind(null,Vt,y,w,d),y.dispatch=d,m.memoizedState=a,[r,d,!1]}function qv(a){var r=Ye();return jv(r,we,a)}function jv(a,r,d){if(r=hg(a,r,Wv)[0],a=Zh(Xo)[0],typeof r=="object"&&r!==null&&typeof r.then=="function")try{var m=au(r)}catch(I){throw I===Or?Vh:I}else m=r;r=Ye();var y=r.queue,w=y.dispatch;return d!==r.memoizedState&&(Vt.flags|=2048,Lr(9,{destroy:void 0},QA.bind(null,y,d),null)),[m,w,a]}function QA(a,r){a.action=r}function Xv(a){var r=Ye(),d=we;if(d!==null)return jv(r,d,a);Ye(),r=r.memoizedState,d=Ye();var m=d.queue.dispatch;return d.memoizedState=a,[r,m,!1]}function Lr(a,r,d,m){return a={tag:a,create:d,deps:m,inst:r,next:null},r=Vt.updateQueue,r===null&&(r=Kh(),Vt.updateQueue=r),d=r.lastEffect,d===null?r.lastEffect=a.next=a:(m=d.next,d.next=a,a.next=m,r.lastEffect=a),a}function Kv(){return Ye().memoizedState}function Qh(a,r,d,m){var y=Wn();Vt.flags|=a,y.memoizedState=Lr(1|r,{destroy:void 0},d,m===void 0?null:m)}function Jh(a,r,d,m){var y=Ye();m=m===void 0?null:m;var w=y.memoizedState.inst;we!==null&&m!==null&&ag(m,we.memoizedState.deps)?y.memoizedState=Lr(r,w,d,m):(Vt.flags|=a,y.memoizedState=Lr(1|r,w,d,m))}function Yv(a,r){Qh(8390656,8,a,r)}function mg(a,r){Jh(2048,8,a,r)}function JA(a){Vt.flags|=4;var r=Vt.updateQueue;if(r===null)r=Kh(),Vt.updateQueue=r,r.events=[a];else{var d=r.events;d===null?r.events=[a]:d.push(a)}}function Zv(a){var r=Ye().memoizedState;return JA({ref:r,nextImpl:a}),function(){if((fe&2)!==0)throw Error(s(440));return r.impl.apply(void 0,arguments)}}function Qv(a,r){return Jh(4,2,a,r)}function Jv(a,r){return Jh(4,4,a,r)}function tw(a,r){if(typeof r=="function"){a=a();var d=r(a);return function(){typeof d=="function"?d():r(null)}}if(r!=null)return a=a(),r.current=a,function(){r.current=null}}function ew(a,r,d){d=d!=null?d.concat([a]):null,Jh(4,4,tw.bind(null,r,a),d)}function gg(){}function nw(a,r){var d=Ye();r=r===void 0?null:r;var m=d.memoizedState;return r!==null&&ag(r,m[1])?m[0]:(d.memoizedState=[a,r],a)}function sw(a,r){var d=Ye();r=r===void 0?null:r;var m=d.memoizedState;if(r!==null&&ag(r,m[1]))return m[0];if(m=a(),Ii){go(!0);try{a()}finally{go(!1)}}return d.memoizedState=[m,r],m}function xg(a,r,d){return d===void 0||(jo&1073741824)!==0&&(Yt&261930)===0?a.memoizedState=r:(a.memoizedState=d,a=oS(),Vt.lanes|=a,Ea|=a,d)}function ow(a,r,d,m){return ms(d,r)?d:Fr.current!==null?(a=xg(a,d,m),ms(a,r)||(en=!0),a):(jo&42)===0||(jo&1073741824)!==0&&(Yt&261930)===0?(en=!0,a.memoizedState=d):(a=oS(),Vt.lanes|=a,Ea|=a,r)}function aw(a,r,d,m,y){var w=P.p;P.p=w!==0&&8>w?w:8;var I=L.T,A={};L.T=A,vg(a,!1,r,d);try{var V=y(),at=L.S;if(at!==null&&at(A,V),V!==null&&typeof V=="object"&&typeof V.then=="function"){var pt=XA(V,m);iu(a,r,pt,ws(a))}else iu(a,r,m,ws(a))}catch(xt){iu(a,r,{then:function(){},status:"rejected",reason:xt},ws())}finally{P.p=w,I!==null&&A.types!==null&&(I.types=A.types),L.T=I}}function tD(){}function bg(a,r,d,m){if(a.tag!==5)throw Error(s(476));var y=iw(a).queue;aw(a,y,r,W,d===null?tD:function(){return rw(a),d(m)})}function iw(a){var r=a.memoizedState;if(r!==null)return r;r={memoizedState:W,baseState:W,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Xo,lastRenderedState:W},next:null};var d={};return r.next={memoizedState:d,baseState:d,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Xo,lastRenderedState:d},next:null},a.memoizedState=r,a=a.alternate,a!==null&&(a.memoizedState=r),r}function rw(a){var r=iw(a);r.next===null&&(r=a.alternate.memoizedState),iu(a,r.next.queue,{},ws())}function yg(){return kn(Cu)}function lw(){return Ye().memoizedState}function uw(){return Ye().memoizedState}function eD(a){for(var r=a.return;r!==null;){switch(r.tag){case 24:case 3:var d=ws();a=Ca(d);var m=$a(r,a,d);m!==null&&(os(m,r,d),eu(m,r,d)),r={cache:Xm()},a.payload=r;return}r=r.return}}function nD(a,r,d){var m=ws();d={lane:m,revertLane:0,gesture:null,action:d,hasEagerState:!1,eagerState:null,next:null},td(a)?hw(r,d):(d=zm(a,r,d,m),d!==null&&(os(d,a,m),dw(d,r,m)))}function cw(a,r,d){var m=ws();iu(a,r,d,m)}function iu(a,r,d,m){var y={lane:m,revertLane:0,gesture:null,action:d,hasEagerState:!1,eagerState:null,next:null};if(td(a))hw(r,y);else{var w=a.alternate;if(a.lanes===0&&(w===null||w.lanes===0)&&(w=r.lastRenderedReducer,w!==null))try{var I=r.lastRenderedState,A=w(I,d);if(y.hasEagerState=!0,y.eagerState=A,ms(A,I))return _h(a,r,y,0),ke===null&&Oh(),!1}catch{}if(d=zm(a,r,y,m),d!==null)return os(d,a,m),dw(d,r,m),!0}return!1}function vg(a,r,d,m){if(m={lane:2,revertLane:Qg(),gesture:null,action:m,hasEagerState:!1,eagerState:null,next:null},td(a)){if(r)throw Error(s(479))}else r=zm(a,d,m,2),r!==null&&os(r,a,2)}function td(a){var r=a.alternate;return a===Vt||r!==null&&r===Vt}function hw(a,r){Mr=jh=!0;var d=a.pending;d===null?r.next=r:(r.next=d.next,d.next=r),a.pending=r}function dw(a,r,d){if((d&4194048)!==0){var m=r.lanes;m&=a.pendingLanes,d|=m,r.lanes=d,x1(a,d)}}var ru={readContext:kn,use:Yh,useCallback:Ve,useContext:Ve,useEffect:Ve,useImperativeHandle:Ve,useLayoutEffect:Ve,useInsertionEffect:Ve,useMemo:Ve,useReducer:Ve,useRef:Ve,useState:Ve,useDebugValue:Ve,useDeferredValue:Ve,useTransition:Ve,useSyncExternalStore:Ve,useId:Ve,useHostTransitionStatus:Ve,useFormState:Ve,useActionState:Ve,useOptimistic:Ve,useMemoCache:Ve,useCacheRefresh:Ve};ru.useEffectEvent=Ve;var fw={readContext:kn,use:Yh,useCallback:function(a,r){return Wn().memoizedState=[a,r===void 0?null:r],a},useContext:kn,useEffect:Yv,useImperativeHandle:function(a,r,d){d=d!=null?d.concat([a]):null,Qh(4194308,4,tw.bind(null,r,a),d)},useLayoutEffect:function(a,r){return Qh(4194308,4,a,r)},useInsertionEffect:function(a,r){Qh(4,2,a,r)},useMemo:function(a,r){var d=Wn();r=r===void 0?null:r;var m=a();if(Ii){go(!0);try{a()}finally{go(!1)}}return d.memoizedState=[m,r],m},useReducer:function(a,r,d){var m=Wn();if(d!==void 0){var y=d(r);if(Ii){go(!0);try{d(r)}finally{go(!1)}}}else y=r;return m.memoizedState=m.baseState=y,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:y},m.queue=a,a=a.dispatch=nD.bind(null,Vt,a),[m.memoizedState,a]},useRef:function(a){var r=Wn();return a={current:a},r.memoizedState=a},useState:function(a){a=fg(a);var r=a.queue,d=cw.bind(null,Vt,r);return r.dispatch=d,[a.memoizedState,d]},useDebugValue:gg,useDeferredValue:function(a,r){var d=Wn();return xg(d,a,r)},useTransition:function(){var a=fg(!1);return a=aw.bind(null,Vt,a.queue,!0,!1),Wn().memoizedState=a,[!1,a]},useSyncExternalStore:function(a,r,d){var m=Vt,y=Wn();if(Qt){if(d===void 0)throw Error(s(407));d=d()}else{if(d=r(),ke===null)throw Error(s(349));(Yt&127)!==0||_v(m,r,d)}y.memoizedState=d;var w={value:d,getSnapshot:r};return y.queue=w,Yv(Mv.bind(null,m,w,a),[a]),m.flags|=2048,Lr(9,{destroy:void 0},Fv.bind(null,m,w,d,r),null),d},useId:function(){var a=Wn(),r=ke.identifierPrefix;if(Qt){var d=bo,m=xo;d=(m&~(1<<32-ps(m)-1)).toString(32)+d,r="_"+r+"R_"+d,d=Xh++,0<d&&(r+="H"+d.toString(32)),r+="_"}else d=KA++,r="_"+r+"r_"+d.toString(32)+"_";return a.memoizedState=r},useHostTransitionStatus:yg,useFormState:Hv,useActionState:Hv,useOptimistic:function(a){var r=Wn();r.memoizedState=r.baseState=a;var d={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return r.queue=d,r=vg.bind(null,Vt,!0,d),d.dispatch=r,[a,r]},useMemoCache:cg,useCacheRefresh:function(){return Wn().memoizedState=eD.bind(null,Vt)},useEffectEvent:function(a){var r=Wn(),d={impl:a};return r.memoizedState=d,function(){if((fe&2)!==0)throw Error(s(440));return d.impl.apply(void 0,arguments)}}},wg={readContext:kn,use:Yh,useCallback:nw,useContext:kn,useEffect:mg,useImperativeHandle:ew,useInsertionEffect:Qv,useLayoutEffect:Jv,useMemo:sw,useReducer:Zh,useRef:Kv,useState:function(){return Zh(Xo)},useDebugValue:gg,useDeferredValue:function(a,r){var d=Ye();return ow(d,we.memoizedState,a,r)},useTransition:function(){var a=Zh(Xo)[0],r=Ye().memoizedState;return[typeof a=="boolean"?a:au(a),r]},useSyncExternalStore:Ov,useId:lw,useHostTransitionStatus:yg,useFormState:qv,useActionState:qv,useOptimistic:function(a,r){var d=Ye();return Bv(d,we,a,r)},useMemoCache:cg,useCacheRefresh:uw};wg.useEffectEvent=Zv;var pw={readContext:kn,use:Yh,useCallback:nw,useContext:kn,useEffect:mg,useImperativeHandle:ew,useInsertionEffect:Qv,useLayoutEffect:Jv,useMemo:sw,useReducer:dg,useRef:Kv,useState:function(){return dg(Xo)},useDebugValue:gg,useDeferredValue:function(a,r){var d=Ye();return we===null?xg(d,a,r):ow(d,we.memoizedState,a,r)},useTransition:function(){var a=dg(Xo)[0],r=Ye().memoizedState;return[typeof a=="boolean"?a:au(a),r]},useSyncExternalStore:Ov,useId:lw,useHostTransitionStatus:yg,useFormState:Xv,useActionState:Xv,useOptimistic:function(a,r){var d=Ye();return we!==null?Bv(d,we,a,r):(d.baseState=a,[a,d.queue.dispatch])},useMemoCache:cg,useCacheRefresh:uw};pw.useEffectEvent=Zv;function Sg(a,r,d,m){r=a.memoizedState,d=d(m,r),d=d==null?r:p({},r,d),a.memoizedState=d,a.lanes===0&&(a.updateQueue.baseState=d)}var Cg={enqueueSetState:function(a,r,d){a=a._reactInternals;var m=ws(),y=Ca(m);y.payload=r,d!=null&&(y.callback=d),r=$a(a,y,m),r!==null&&(os(r,a,m),eu(r,a,m))},enqueueReplaceState:function(a,r,d){a=a._reactInternals;var m=ws(),y=Ca(m);y.tag=1,y.payload=r,d!=null&&(y.callback=d),r=$a(a,y,m),r!==null&&(os(r,a,m),eu(r,a,m))},enqueueForceUpdate:function(a,r){a=a._reactInternals;var d=ws(),m=Ca(d);m.tag=2,r!=null&&(m.callback=r),r=$a(a,m,d),r!==null&&(os(r,a,d),eu(r,a,d))}};function mw(a,r,d,m,y,w,I){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(m,w,I):r.prototype&&r.prototype.isPureReactComponent?!jl(d,m)||!jl(y,w):!0}function gw(a,r,d,m){a=r.state,typeof r.componentWillReceiveProps=="function"&&r.componentWillReceiveProps(d,m),typeof r.UNSAFE_componentWillReceiveProps=="function"&&r.UNSAFE_componentWillReceiveProps(d,m),r.state!==a&&Cg.enqueueReplaceState(r,r.state,null)}function Ni(a,r){var d=r;if("ref"in r){d={};for(var m in r)m!=="ref"&&(d[m]=r[m])}if(a=a.defaultProps){d===r&&(d=p({},d));for(var y in a)d[y]===void 0&&(d[y]=a[y])}return d}function xw(a){Dh(a)}function bw(a){console.error(a)}function yw(a){Dh(a)}function ed(a,r){try{var d=a.onUncaughtError;d(r.value,{componentStack:r.stack})}catch(m){setTimeout(function(){throw m})}}function vw(a,r,d){try{var m=a.onCaughtError;m(d.value,{componentStack:d.stack,errorBoundary:r.tag===1?r.stateNode:null})}catch(y){setTimeout(function(){throw y})}}function $g(a,r,d){return d=Ca(d),d.tag=3,d.payload={element:null},d.callback=function(){ed(a,r)},d}function ww(a){return a=Ca(a),a.tag=3,a}function Sw(a,r,d,m){var y=d.type.getDerivedStateFromError;if(typeof y=="function"){var w=m.value;a.payload=function(){return y(w)},a.callback=function(){vw(r,d,m)}}var I=d.stateNode;I!==null&&typeof I.componentDidCatch=="function"&&(a.callback=function(){vw(r,d,m),typeof y!="function"&&(Ra===null?Ra=new Set([this]):Ra.add(this));var A=m.stack;this.componentDidCatch(m.value,{componentStack:A!==null?A:""})})}function sD(a,r,d,m,y){if(d.flags|=32768,m!==null&&typeof m=="object"&&typeof m.then=="function"){if(r=d.alternate,r!==null&&Rr(r,d,y,!0),d=xs.current,d!==null){switch(d.tag){case 31:case 13:return Ms===null?fd():d.alternate===null&&Pe===0&&(Pe=3),d.flags&=-257,d.flags|=65536,d.lanes=y,m===Ph?d.flags|=16384:(r=d.updateQueue,r===null?d.updateQueue=new Set([m]):r.add(m),Kg(a,m,y)),!1;case 22:return d.flags|=65536,m===Ph?d.flags|=16384:(r=d.updateQueue,r===null?(r={transitions:null,markerInstances:null,retryQueue:new Set([m])},d.updateQueue=r):(d=r.retryQueue,d===null?r.retryQueue=new Set([m]):d.add(m)),Kg(a,m,y)),!1}throw Error(s(435,d.tag))}return Kg(a,m,y),fd(),!1}if(Qt)return r=xs.current,r!==null?((r.flags&65536)===0&&(r.flags|=256),r.flags|=65536,r.lanes=y,m!==Gm&&(a=Error(s(422),{cause:m}),Yl(Ds(a,d)))):(m!==Gm&&(r=Error(s(423),{cause:m}),Yl(Ds(r,d))),a=a.current.alternate,a.flags|=65536,y&=-y,a.lanes|=y,m=Ds(m,d),y=$g(a.stateNode,m,y),tg(a,y),Pe!==4&&(Pe=2)),!1;var w=Error(s(520),{cause:m});if(w=Ds(w,d),mu===null?mu=[w]:mu.push(w),Pe!==4&&(Pe=2),r===null)return!0;m=Ds(m,d),d=r;do{switch(d.tag){case 3:return d.flags|=65536,a=y&-y,d.lanes|=a,a=$g(d.stateNode,m,a),tg(d,a),!1;case 1:if(r=d.type,w=d.stateNode,(d.flags&128)===0&&(typeof r.getDerivedStateFromError=="function"||w!==null&&typeof w.componentDidCatch=="function"&&(Ra===null||!Ra.has(w))))return d.flags|=65536,y&=-y,d.lanes|=y,y=ww(y),Sw(y,a,d,m),tg(d,y),!1}d=d.return}while(d!==null);return!1}var Tg=Error(s(461)),en=!1;function In(a,r,d,m){r.child=a===null?kv(r,null,d,m):ki(r,a.child,d,m)}function Cw(a,r,d,m,y){d=d.render;var w=r.ref;if("ref"in m){var I={};for(var A in m)A!=="ref"&&(I[A]=m[A])}else I=m;return Si(r),m=ig(a,r,d,I,w,y),A=rg(),a!==null&&!en?(lg(a,r,y),Ko(a,r,y)):(Qt&&A&&Vm(r),r.flags|=1,In(a,r,m,y),r.child)}function $w(a,r,d,m,y){if(a===null){var w=d.type;return typeof w=="function"&&!Lm(w)&&w.defaultProps===void 0&&d.compare===null?(r.tag=15,r.type=w,Tw(a,r,w,m,y)):(a=Mh(d.type,null,m,r,r.mode,y),a.ref=r.ref,a.return=r,r.child=a)}if(w=a.child,!Og(a,y)){var I=w.memoizedProps;if(d=d.compare,d=d!==null?d:jl,d(I,m)&&a.ref===r.ref)return Ko(a,r,y)}return r.flags|=1,a=Go(w,m),a.ref=r.ref,a.return=r,r.child=a}function Tw(a,r,d,m,y){if(a!==null){var w=a.memoizedProps;if(jl(w,m)&&a.ref===r.ref)if(en=!1,r.pendingProps=m=w,Og(a,y))(a.flags&131072)!==0&&(en=!0);else return r.lanes=a.lanes,Ko(a,r,y)}return kg(a,r,d,m,y)}function kw(a,r,d,m){var y=m.children,w=a!==null?a.memoizedState:null;if(a===null&&r.stateNode===null&&(r.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),m.mode==="hidden"){if((r.flags&128)!==0){if(w=w!==null?w.baseLanes|d:d,a!==null){for(m=r.child=a.child,y=0;m!==null;)y=y|m.lanes|m.childLanes,m=m.sibling;m=y&~w}else m=0,r.child=null;return Iw(a,r,w,d,m)}if((d&536870912)!==0)r.memoizedState={baseLanes:0,cachePool:null},a!==null&&Uh(r,w!==null?w.cachePool:null),w!==null?Ev(r,w):ng(),Rv(r);else return m=r.lanes=536870912,Iw(a,r,w!==null?w.baseLanes|d:d,d,m)}else w!==null?(Uh(r,w.cachePool),Ev(r,w),ka(),r.memoizedState=null):(a!==null&&Uh(r,null),ng(),ka());return In(a,r,y,d),r.child}function lu(a,r){return a!==null&&a.tag===22||r.stateNode!==null||(r.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),r.sibling}function Iw(a,r,d,m,y){var w=Ym();return w=w===null?null:{parent:Je._currentValue,pool:w},r.memoizedState={baseLanes:d,cachePool:w},a!==null&&Uh(r,null),ng(),Rv(r),a!==null&&Rr(a,r,m,!0),r.childLanes=y,null}function nd(a,r){return r=od({mode:r.mode,children:r.children},a.mode),r.ref=a.ref,a.child=r,r.return=a,r}function Nw(a,r,d){return ki(r,a.child,null,d),a=nd(r,r.pendingProps),a.flags|=2,bs(r),r.memoizedState=null,a}function oD(a,r,d){var m=r.pendingProps,y=(r.flags&128)!==0;if(r.flags&=-129,a===null){if(Qt){if(m.mode==="hidden")return a=nd(r,m),r.lanes=536870912,lu(null,a);if(og(r),(a=Oe)?(a=US(a,Fs),a=a!==null&&a.data==="&"?a:null,a!==null&&(r.memoizedState={dehydrated:a,treeContext:ba!==null?{id:xo,overflow:bo}:null,retryLane:536870912,hydrationErrors:null},d=hv(a),d.return=r,r.child=d,Tn=r,Oe=null)):a=null,a===null)throw va(r);return r.lanes=536870912,null}return nd(r,m)}var w=a.memoizedState;if(w!==null){var I=w.dehydrated;if(og(r),y)if(r.flags&256)r.flags&=-257,r=Nw(a,r,d);else if(r.memoizedState!==null)r.child=a.child,r.flags|=128,r=null;else throw Error(s(558));else if(en||Rr(a,r,d,!1),y=(d&a.childLanes)!==0,en||y){if(m=ke,m!==null&&(I=b1(m,d),I!==0&&I!==w.retryLane))throw w.retryLane=I,bi(a,I),os(m,a,I),Tg;fd(),r=Nw(a,r,d)}else a=w.treeContext,Oe=zs(I.nextSibling),Tn=r,Qt=!0,ya=null,Fs=!1,a!==null&&pv(r,a),r=nd(r,m),r.flags|=4096;return r}return a=Go(a.child,{mode:m.mode,children:m.children}),a.ref=r.ref,r.child=a,a.return=r,a}function sd(a,r){var d=r.ref;if(d===null)a!==null&&a.ref!==null&&(r.flags|=4194816);else{if(typeof d!="function"&&typeof d!="object")throw Error(s(284));(a===null||a.ref!==d)&&(r.flags|=4194816)}}function kg(a,r,d,m,y){return Si(r),d=ig(a,r,d,m,void 0,y),m=rg(),a!==null&&!en?(lg(a,r,y),Ko(a,r,y)):(Qt&&m&&Vm(r),r.flags|=1,In(a,r,d,y),r.child)}function Ew(a,r,d,m,y,w){return Si(r),r.updateQueue=null,d=Dv(r,m,d,y),Av(a),m=rg(),a!==null&&!en?(lg(a,r,w),Ko(a,r,w)):(Qt&&m&&Vm(r),r.flags|=1,In(a,r,d,w),r.child)}function Rw(a,r,d,m,y){if(Si(r),r.stateNode===null){var w=kr,I=d.contextType;typeof I=="object"&&I!==null&&(w=kn(I)),w=new d(m,w),r.memoizedState=w.state!==null&&w.state!==void 0?w.state:null,w.updater=Cg,r.stateNode=w,w._reactInternals=r,w=r.stateNode,w.props=m,w.state=r.memoizedState,w.refs={},Qm(r),I=d.contextType,w.context=typeof I=="object"&&I!==null?kn(I):kr,w.state=r.memoizedState,I=d.getDerivedStateFromProps,typeof I=="function"&&(Sg(r,d,I,m),w.state=r.memoizedState),typeof d.getDerivedStateFromProps=="function"||typeof w.getSnapshotBeforeUpdate=="function"||typeof w.UNSAFE_componentWillMount!="function"&&typeof w.componentWillMount!="function"||(I=w.state,typeof w.componentWillMount=="function"&&w.componentWillMount(),typeof w.UNSAFE_componentWillMount=="function"&&w.UNSAFE_componentWillMount(),I!==w.state&&Cg.enqueueReplaceState(w,w.state,null),su(r,m,w,y),nu(),w.state=r.memoizedState),typeof w.componentDidMount=="function"&&(r.flags|=4194308),m=!0}else if(a===null){w=r.stateNode;var A=r.memoizedProps,V=Ni(d,A);w.props=V;var at=w.context,pt=d.contextType;I=kr,typeof pt=="object"&&pt!==null&&(I=kn(pt));var xt=d.getDerivedStateFromProps;pt=typeof xt=="function"||typeof w.getSnapshotBeforeUpdate=="function",A=r.pendingProps!==A,pt||typeof w.UNSAFE_componentWillReceiveProps!="function"&&typeof w.componentWillReceiveProps!="function"||(A||at!==I)&&gw(r,w,m,I),Sa=!1;var rt=r.memoizedState;w.state=rt,su(r,m,w,y),nu(),at=r.memoizedState,A||rt!==at||Sa?(typeof xt=="function"&&(Sg(r,d,xt,m),at=r.memoizedState),(V=Sa||mw(r,d,V,m,rt,at,I))?(pt||typeof w.UNSAFE_componentWillMount!="function"&&typeof w.componentWillMount!="function"||(typeof w.componentWillMount=="function"&&w.componentWillMount(),typeof w.UNSAFE_componentWillMount=="function"&&w.UNSAFE_componentWillMount()),typeof w.componentDidMount=="function"&&(r.flags|=4194308)):(typeof w.componentDidMount=="function"&&(r.flags|=4194308),r.memoizedProps=m,r.memoizedState=at),w.props=m,w.state=at,w.context=I,m=V):(typeof w.componentDidMount=="function"&&(r.flags|=4194308),m=!1)}else{w=r.stateNode,Jm(a,r),I=r.memoizedProps,pt=Ni(d,I),w.props=pt,xt=r.pendingProps,rt=w.context,at=d.contextType,V=kr,typeof at=="object"&&at!==null&&(V=kn(at)),A=d.getDerivedStateFromProps,(at=typeof A=="function"||typeof w.getSnapshotBeforeUpdate=="function")||typeof w.UNSAFE_componentWillReceiveProps!="function"&&typeof w.componentWillReceiveProps!="function"||(I!==xt||rt!==V)&&gw(r,w,m,V),Sa=!1,rt=r.memoizedState,w.state=rt,su(r,m,w,y),nu();var ct=r.memoizedState;I!==xt||rt!==ct||Sa||a!==null&&a.dependencies!==null&&Lh(a.dependencies)?(typeof A=="function"&&(Sg(r,d,A,m),ct=r.memoizedState),(pt=Sa||mw(r,d,pt,m,rt,ct,V)||a!==null&&a.dependencies!==null&&Lh(a.dependencies))?(at||typeof w.UNSAFE_componentWillUpdate!="function"&&typeof w.componentWillUpdate!="function"||(typeof w.componentWillUpdate=="function"&&w.componentWillUpdate(m,ct,V),typeof w.UNSAFE_componentWillUpdate=="function"&&w.UNSAFE_componentWillUpdate(m,ct,V)),typeof w.componentDidUpdate=="function"&&(r.flags|=4),typeof w.getSnapshotBeforeUpdate=="function"&&(r.flags|=1024)):(typeof w.componentDidUpdate!="function"||I===a.memoizedProps&&rt===a.memoizedState||(r.flags|=4),typeof w.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&rt===a.memoizedState||(r.flags|=1024),r.memoizedProps=m,r.memoizedState=ct),w.props=m,w.state=ct,w.context=V,m=pt):(typeof w.componentDidUpdate!="function"||I===a.memoizedProps&&rt===a.memoizedState||(r.flags|=4),typeof w.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&rt===a.memoizedState||(r.flags|=1024),m=!1)}return w=m,sd(a,r),m=(r.flags&128)!==0,w||m?(w=r.stateNode,d=m&&typeof d.getDerivedStateFromError!="function"?null:w.render(),r.flags|=1,a!==null&&m?(r.child=ki(r,a.child,null,y),r.child=ki(r,null,d,y)):In(a,r,d,y),r.memoizedState=w.state,a=r.child):a=Ko(a,r,y),a}function Aw(a,r,d,m){return vi(),r.flags|=256,In(a,r,d,m),r.child}var Ig={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Ng(a){return{baseLanes:a,cachePool:vv()}}function Eg(a,r,d){return a=a!==null?a.childLanes&~d:0,r&&(a|=vs),a}function Dw(a,r,d){var m=r.pendingProps,y=!1,w=(r.flags&128)!==0,I;if((I=w)||(I=a!==null&&a.memoizedState===null?!1:(Ke.current&2)!==0),I&&(y=!0,r.flags&=-129),I=(r.flags&32)!==0,r.flags&=-33,a===null){if(Qt){if(y?Ta(r):ka(),(a=Oe)?(a=US(a,Fs),a=a!==null&&a.data!=="&"?a:null,a!==null&&(r.memoizedState={dehydrated:a,treeContext:ba!==null?{id:xo,overflow:bo}:null,retryLane:536870912,hydrationErrors:null},d=hv(a),d.return=r,r.child=d,Tn=r,Oe=null)):a=null,a===null)throw va(r);return hx(a)?r.lanes=32:r.lanes=536870912,null}var A=m.children;return m=m.fallback,y?(ka(),y=r.mode,A=od({mode:"hidden",children:A},y),m=yi(m,y,d,null),A.return=r,m.return=r,A.sibling=m,r.child=A,m=r.child,m.memoizedState=Ng(d),m.childLanes=Eg(a,I,d),r.memoizedState=Ig,lu(null,m)):(Ta(r),Rg(r,A))}var V=a.memoizedState;if(V!==null&&(A=V.dehydrated,A!==null)){if(w)r.flags&256?(Ta(r),r.flags&=-257,r=Ag(a,r,d)):r.memoizedState!==null?(ka(),r.child=a.child,r.flags|=128,r=null):(ka(),A=m.fallback,y=r.mode,m=od({mode:"visible",children:m.children},y),A=yi(A,y,d,null),A.flags|=2,m.return=r,A.return=r,m.sibling=A,r.child=m,ki(r,a.child,null,d),m=r.child,m.memoizedState=Ng(d),m.childLanes=Eg(a,I,d),r.memoizedState=Ig,r=lu(null,m));else if(Ta(r),hx(A)){if(I=A.nextSibling&&A.nextSibling.dataset,I)var at=I.dgst;I=at,m=Error(s(419)),m.stack="",m.digest=I,Yl({value:m,source:null,stack:null}),r=Ag(a,r,d)}else if(en||Rr(a,r,d,!1),I=(d&a.childLanes)!==0,en||I){if(I=ke,I!==null&&(m=b1(I,d),m!==0&&m!==V.retryLane))throw V.retryLane=m,bi(a,m),os(I,a,m),Tg;cx(A)||fd(),r=Ag(a,r,d)}else cx(A)?(r.flags|=192,r.child=a.child,r=null):(a=V.treeContext,Oe=zs(A.nextSibling),Tn=r,Qt=!0,ya=null,Fs=!1,a!==null&&pv(r,a),r=Rg(r,m.children),r.flags|=4096);return r}return y?(ka(),A=m.fallback,y=r.mode,V=a.child,at=V.sibling,m=Go(V,{mode:"hidden",children:m.children}),m.subtreeFlags=V.subtreeFlags&65011712,at!==null?A=Go(at,A):(A=yi(A,y,d,null),A.flags|=2),A.return=r,m.return=r,m.sibling=A,r.child=m,lu(null,m),m=r.child,A=a.child.memoizedState,A===null?A=Ng(d):(y=A.cachePool,y!==null?(V=Je._currentValue,y=y.parent!==V?{parent:V,pool:V}:y):y=vv(),A={baseLanes:A.baseLanes|d,cachePool:y}),m.memoizedState=A,m.childLanes=Eg(a,I,d),r.memoizedState=Ig,lu(a.child,m)):(Ta(r),d=a.child,a=d.sibling,d=Go(d,{mode:"visible",children:m.children}),d.return=r,d.sibling=null,a!==null&&(I=r.deletions,I===null?(r.deletions=[a],r.flags|=16):I.push(a)),r.child=d,r.memoizedState=null,d)}function Rg(a,r){return r=od({mode:"visible",children:r},a.mode),r.return=a,a.child=r}function od(a,r){return a=gs(22,a,null,r),a.lanes=0,a}function Ag(a,r,d){return ki(r,a.child,null,d),a=Rg(r,r.pendingProps.children),a.flags|=2,r.memoizedState=null,a}function Ow(a,r,d){a.lanes|=r;var m=a.alternate;m!==null&&(m.lanes|=r),qm(a.return,r,d)}function Dg(a,r,d,m,y,w){var I=a.memoizedState;I===null?a.memoizedState={isBackwards:r,rendering:null,renderingStartTime:0,last:m,tail:d,tailMode:y,treeForkCount:w}:(I.isBackwards=r,I.rendering=null,I.renderingStartTime=0,I.last=m,I.tail=d,I.tailMode=y,I.treeForkCount=w)}function _w(a,r,d){var m=r.pendingProps,y=m.revealOrder,w=m.tail;m=m.children;var I=Ke.current,A=(I&2)!==0;if(A?(I=I&1|2,r.flags|=128):I&=1,Q(Ke,I),In(a,r,m,d),m=Qt?Kl:0,!A&&a!==null&&(a.flags&128)!==0)t:for(a=r.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&Ow(a,d,r);else if(a.tag===19)Ow(a,d,r);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===r)break t;for(;a.sibling===null;){if(a.return===null||a.return===r)break t;a=a.return}a.sibling.return=a.return,a=a.sibling}switch(y){case"forwards":for(d=r.child,y=null;d!==null;)a=d.alternate,a!==null&&qh(a)===null&&(y=d),d=d.sibling;d=y,d===null?(y=r.child,r.child=null):(y=d.sibling,d.sibling=null),Dg(r,!1,y,d,w,m);break;case"backwards":case"unstable_legacy-backwards":for(d=null,y=r.child,r.child=null;y!==null;){if(a=y.alternate,a!==null&&qh(a)===null){r.child=y;break}a=y.sibling,y.sibling=d,d=y,y=a}Dg(r,!0,d,null,w,m);break;case"together":Dg(r,!1,null,null,void 0,m);break;default:r.memoizedState=null}return r.child}function Ko(a,r,d){if(a!==null&&(r.dependencies=a.dependencies),Ea|=r.lanes,(d&r.childLanes)===0)if(a!==null){if(Rr(a,r,d,!1),(d&r.childLanes)===0)return null}else return null;if(a!==null&&r.child!==a.child)throw Error(s(153));if(r.child!==null){for(a=r.child,d=Go(a,a.pendingProps),r.child=d,d.return=r;a.sibling!==null;)a=a.sibling,d=d.sibling=Go(a,a.pendingProps),d.return=r;d.sibling=null}return r.child}function Og(a,r){return(a.lanes&r)!==0?!0:(a=a.dependencies,!!(a!==null&&Lh(a)))}function aD(a,r,d){switch(r.tag){case 3:Tt(r,r.stateNode.containerInfo),wa(r,Je,a.memoizedState.cache),vi();break;case 27:case 5:zt(r);break;case 4:Tt(r,r.stateNode.containerInfo);break;case 10:wa(r,r.type,r.memoizedProps.value);break;case 31:if(r.memoizedState!==null)return r.flags|=128,og(r),null;break;case 13:var m=r.memoizedState;if(m!==null)return m.dehydrated!==null?(Ta(r),r.flags|=128,null):(d&r.child.childLanes)!==0?Dw(a,r,d):(Ta(r),a=Ko(a,r,d),a!==null?a.sibling:null);Ta(r);break;case 19:var y=(a.flags&128)!==0;if(m=(d&r.childLanes)!==0,m||(Rr(a,r,d,!1),m=(d&r.childLanes)!==0),y){if(m)return _w(a,r,d);r.flags|=128}if(y=r.memoizedState,y!==null&&(y.rendering=null,y.tail=null,y.lastEffect=null),Q(Ke,Ke.current),m)break;return null;case 22:return r.lanes=0,kw(a,r,d,r.pendingProps);case 24:wa(r,Je,a.memoizedState.cache)}return Ko(a,r,d)}function Fw(a,r,d){if(a!==null)if(a.memoizedProps!==r.pendingProps)en=!0;else{if(!Og(a,d)&&(r.flags&128)===0)return en=!1,aD(a,r,d);en=(a.flags&131072)!==0}else en=!1,Qt&&(r.flags&1048576)!==0&&fv(r,Kl,r.index);switch(r.lanes=0,r.tag){case 16:t:{var m=r.pendingProps;if(a=$i(r.elementType),r.type=a,typeof a=="function")Lm(a)?(m=Ni(a,m),r.tag=1,r=Rw(null,r,a,m,d)):(r.tag=0,r=kg(null,r,a,m,d));else{if(a!=null){var y=a.$$typeof;if(y===T){r.tag=11,r=Cw(null,r,a,m,d);break t}else if(y===D){r.tag=14,r=$w(null,r,a,m,d);break t}}throw r=X(a)||a,Error(s(306,r,""))}}return r;case 0:return kg(a,r,r.type,r.pendingProps,d);case 1:return m=r.type,y=Ni(m,r.pendingProps),Rw(a,r,m,y,d);case 3:t:{if(Tt(r,r.stateNode.containerInfo),a===null)throw Error(s(387));m=r.pendingProps;var w=r.memoizedState;y=w.element,Jm(a,r),su(r,m,null,d);var I=r.memoizedState;if(m=I.cache,wa(r,Je,m),m!==w.cache&&jm(r,[Je],d,!0),nu(),m=I.element,w.isDehydrated)if(w={element:m,isDehydrated:!1,cache:I.cache},r.updateQueue.baseState=w,r.memoizedState=w,r.flags&256){r=Aw(a,r,m,d);break t}else if(m!==y){y=Ds(Error(s(424)),r),Yl(y),r=Aw(a,r,m,d);break t}else for(a=r.stateNode.containerInfo,a.nodeType===9?a=a.body:a=a.nodeName==="HTML"?a.ownerDocument.body:a,Oe=zs(a.firstChild),Tn=r,Qt=!0,ya=null,Fs=!0,d=kv(r,null,m,d),r.child=d;d;)d.flags=d.flags&-3|4096,d=d.sibling;else{if(vi(),m===y){r=Ko(a,r,d);break t}In(a,r,m,d)}r=r.child}return r;case 26:return sd(a,r),a===null?(d=qS(r.type,null,r.pendingProps,null))?r.memoizedState=d:Qt||(d=r.type,a=r.pendingProps,m=vd(gt.current).createElement(d),m[$n]=r,m[Qn]=a,Nn(m,d,a),xn(m),r.stateNode=m):r.memoizedState=qS(r.type,a.memoizedProps,r.pendingProps,a.memoizedState),null;case 27:return zt(r),a===null&&Qt&&(m=r.stateNode=GS(r.type,r.pendingProps,gt.current),Tn=r,Fs=!0,y=Oe,_a(r.type)?(dx=y,Oe=zs(m.firstChild)):Oe=y),In(a,r,r.pendingProps.children,d),sd(a,r),a===null&&(r.flags|=4194304),r.child;case 5:return a===null&&Qt&&((y=m=Oe)&&(m=FD(m,r.type,r.pendingProps,Fs),m!==null?(r.stateNode=m,Tn=r,Oe=zs(m.firstChild),Fs=!1,y=!0):y=!1),y||va(r)),zt(r),y=r.type,w=r.pendingProps,I=a!==null?a.memoizedProps:null,m=w.children,rx(y,w)?m=null:I!==null&&rx(y,I)&&(r.flags|=32),r.memoizedState!==null&&(y=ig(a,r,YA,null,null,d),Cu._currentValue=y),sd(a,r),In(a,r,m,d),r.child;case 6:return a===null&&Qt&&((a=d=Oe)&&(d=MD(d,r.pendingProps,Fs),d!==null?(r.stateNode=d,Tn=r,Oe=null,a=!0):a=!1),a||va(r)),null;case 13:return Dw(a,r,d);case 4:return Tt(r,r.stateNode.containerInfo),m=r.pendingProps,a===null?r.child=ki(r,null,m,d):In(a,r,m,d),r.child;case 11:return Cw(a,r,r.type,r.pendingProps,d);case 7:return In(a,r,r.pendingProps,d),r.child;case 8:return In(a,r,r.pendingProps.children,d),r.child;case 12:return In(a,r,r.pendingProps.children,d),r.child;case 10:return m=r.pendingProps,wa(r,r.type,m.value),In(a,r,m.children,d),r.child;case 9:return y=r.type._context,m=r.pendingProps.children,Si(r),y=kn(y),m=m(y),r.flags|=1,In(a,r,m,d),r.child;case 14:return $w(a,r,r.type,r.pendingProps,d);case 15:return Tw(a,r,r.type,r.pendingProps,d);case 19:return _w(a,r,d);case 31:return oD(a,r,d);case 22:return kw(a,r,d,r.pendingProps);case 24:return Si(r),m=kn(Je),a===null?(y=Ym(),y===null&&(y=ke,w=Xm(),y.pooledCache=w,w.refCount++,w!==null&&(y.pooledCacheLanes|=d),y=w),r.memoizedState={parent:m,cache:y},Qm(r),wa(r,Je,y)):((a.lanes&d)!==0&&(Jm(a,r),su(r,null,null,d),nu()),y=a.memoizedState,w=r.memoizedState,y.parent!==m?(y={parent:m,cache:m},r.memoizedState=y,r.lanes===0&&(r.memoizedState=r.updateQueue.baseState=y),wa(r,Je,m)):(m=w.cache,wa(r,Je,m),m!==y.cache&&jm(r,[Je],d,!0))),In(a,r,r.pendingProps.children,d),r.child;case 29:throw r.pendingProps}throw Error(s(156,r.tag))}function Yo(a){a.flags|=4}function _g(a,r,d,m,y){if((r=(a.mode&32)!==0)&&(r=!1),r){if(a.flags|=16777216,(y&335544128)===y)if(a.stateNode.complete)a.flags|=8192;else if(lS())a.flags|=8192;else throw Ti=Ph,Zm}else a.flags&=-16777217}function Mw(a,r){if(r.type!=="stylesheet"||(r.state.loading&4)!==0)a.flags&=-16777217;else if(a.flags|=16777216,!ZS(r))if(lS())a.flags|=8192;else throw Ti=Ph,Zm}function ad(a,r){r!==null&&(a.flags|=4),a.flags&16384&&(r=a.tag!==22?m1():536870912,a.lanes|=r,Pr|=r)}function uu(a,r){if(!Qt)switch(a.tailMode){case"hidden":r=a.tail;for(var d=null;r!==null;)r.alternate!==null&&(d=r),r=r.sibling;d===null?a.tail=null:d.sibling=null;break;case"collapsed":d=a.tail;for(var m=null;d!==null;)d.alternate!==null&&(m=d),d=d.sibling;m===null?r||a.tail===null?a.tail=null:a.tail.sibling=null:m.sibling=null}}function _e(a){var r=a.alternate!==null&&a.alternate.child===a.child,d=0,m=0;if(r)for(var y=a.child;y!==null;)d|=y.lanes|y.childLanes,m|=y.subtreeFlags&65011712,m|=y.flags&65011712,y.return=a,y=y.sibling;else for(y=a.child;y!==null;)d|=y.lanes|y.childLanes,m|=y.subtreeFlags,m|=y.flags,y.return=a,y=y.sibling;return a.subtreeFlags|=m,a.childLanes=d,r}function iD(a,r,d){var m=r.pendingProps;switch(Pm(r),r.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return _e(r),null;case 1:return _e(r),null;case 3:return d=r.stateNode,m=null,a!==null&&(m=a.memoizedState.cache),r.memoizedState.cache!==m&&(r.flags|=2048),qo(Je),St(),d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null),(a===null||a.child===null)&&(Er(r)?Yo(r):a===null||a.memoizedState.isDehydrated&&(r.flags&256)===0||(r.flags|=1024,Wm())),_e(r),null;case 26:var y=r.type,w=r.memoizedState;return a===null?(Yo(r),w!==null?(_e(r),Mw(r,w)):(_e(r),_g(r,y,null,m,d))):w?w!==a.memoizedState?(Yo(r),_e(r),Mw(r,w)):(_e(r),r.flags&=-16777217):(a=a.memoizedProps,a!==m&&Yo(r),_e(r),_g(r,y,a,m,d)),null;case 27:if(Lt(r),d=gt.current,y=r.type,a!==null&&r.stateNode!=null)a.memoizedProps!==m&&Yo(r);else{if(!m){if(r.stateNode===null)throw Error(s(166));return _e(r),null}a=ut.current,Er(r)?mv(r):(a=GS(y,m,d),r.stateNode=a,Yo(r))}return _e(r),null;case 5:if(Lt(r),y=r.type,a!==null&&r.stateNode!=null)a.memoizedProps!==m&&Yo(r);else{if(!m){if(r.stateNode===null)throw Error(s(166));return _e(r),null}if(w=ut.current,Er(r))mv(r);else{var I=vd(gt.current);switch(w){case 1:w=I.createElementNS("http://www.w3.org/2000/svg",y);break;case 2:w=I.createElementNS("http://www.w3.org/1998/Math/MathML",y);break;default:switch(y){case"svg":w=I.createElementNS("http://www.w3.org/2000/svg",y);break;case"math":w=I.createElementNS("http://www.w3.org/1998/Math/MathML",y);break;case"script":w=I.createElement("div"),w.innerHTML="<script><\/script>",w=w.removeChild(w.firstChild);break;case"select":w=typeof m.is=="string"?I.createElement("select",{is:m.is}):I.createElement("select"),m.multiple?w.multiple=!0:m.size&&(w.size=m.size);break;default:w=typeof m.is=="string"?I.createElement(y,{is:m.is}):I.createElement(y)}}w[$n]=r,w[Qn]=m;t:for(I=r.child;I!==null;){if(I.tag===5||I.tag===6)w.appendChild(I.stateNode);else if(I.tag!==4&&I.tag!==27&&I.child!==null){I.child.return=I,I=I.child;continue}if(I===r)break t;for(;I.sibling===null;){if(I.return===null||I.return===r)break t;I=I.return}I.sibling.return=I.return,I=I.sibling}r.stateNode=w;t:switch(Nn(w,y,m),y){case"button":case"input":case"select":case"textarea":m=!!m.autoFocus;break t;case"img":m=!0;break t;default:m=!1}m&&Yo(r)}}return _e(r),_g(r,r.type,a===null?null:a.memoizedProps,r.pendingProps,d),null;case 6:if(a&&r.stateNode!=null)a.memoizedProps!==m&&Yo(r);else{if(typeof m!="string"&&r.stateNode===null)throw Error(s(166));if(a=gt.current,Er(r)){if(a=r.stateNode,d=r.memoizedProps,m=null,y=Tn,y!==null)switch(y.tag){case 27:case 5:m=y.memoizedProps}a[$n]=r,a=!!(a.nodeValue===d||m!==null&&m.suppressHydrationWarning===!0||DS(a.nodeValue,d)),a||va(r,!0)}else a=vd(a).createTextNode(m),a[$n]=r,r.stateNode=a}return _e(r),null;case 31:if(d=r.memoizedState,a===null||a.memoizedState!==null){if(m=Er(r),d!==null){if(a===null){if(!m)throw Error(s(318));if(a=r.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(557));a[$n]=r}else vi(),(r.flags&128)===0&&(r.memoizedState=null),r.flags|=4;_e(r),a=!1}else d=Wm(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=d),a=!0;if(!a)return r.flags&256?(bs(r),r):(bs(r),null);if((r.flags&128)!==0)throw Error(s(558))}return _e(r),null;case 13:if(m=r.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(y=Er(r),m!==null&&m.dehydrated!==null){if(a===null){if(!y)throw Error(s(318));if(y=r.memoizedState,y=y!==null?y.dehydrated:null,!y)throw Error(s(317));y[$n]=r}else vi(),(r.flags&128)===0&&(r.memoizedState=null),r.flags|=4;_e(r),y=!1}else y=Wm(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=y),y=!0;if(!y)return r.flags&256?(bs(r),r):(bs(r),null)}return bs(r),(r.flags&128)!==0?(r.lanes=d,r):(d=m!==null,a=a!==null&&a.memoizedState!==null,d&&(m=r.child,y=null,m.alternate!==null&&m.alternate.memoizedState!==null&&m.alternate.memoizedState.cachePool!==null&&(y=m.alternate.memoizedState.cachePool.pool),w=null,m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(w=m.memoizedState.cachePool.pool),w!==y&&(m.flags|=2048)),d!==a&&d&&(r.child.flags|=8192),ad(r,r.updateQueue),_e(r),null);case 4:return St(),a===null&&nx(r.stateNode.containerInfo),_e(r),null;case 10:return qo(r.type),_e(r),null;case 19:if(G(Ke),m=r.memoizedState,m===null)return _e(r),null;if(y=(r.flags&128)!==0,w=m.rendering,w===null)if(y)uu(m,!1);else{if(Pe!==0||a!==null&&(a.flags&128)!==0)for(a=r.child;a!==null;){if(w=qh(a),w!==null){for(r.flags|=128,uu(m,!1),a=w.updateQueue,r.updateQueue=a,ad(r,a),r.subtreeFlags=0,a=d,d=r.child;d!==null;)cv(d,a),d=d.sibling;return Q(Ke,Ke.current&1|2),Qt&&Wo(r,m.treeForkCount),r.child}a=a.sibling}m.tail!==null&&De()>cd&&(r.flags|=128,y=!0,uu(m,!1),r.lanes=4194304)}else{if(!y)if(a=qh(w),a!==null){if(r.flags|=128,y=!0,a=a.updateQueue,r.updateQueue=a,ad(r,a),uu(m,!0),m.tail===null&&m.tailMode==="hidden"&&!w.alternate&&!Qt)return _e(r),null}else 2*De()-m.renderingStartTime>cd&&d!==536870912&&(r.flags|=128,y=!0,uu(m,!1),r.lanes=4194304);m.isBackwards?(w.sibling=r.child,r.child=w):(a=m.last,a!==null?a.sibling=w:r.child=w,m.last=w)}return m.tail!==null?(a=m.tail,m.rendering=a,m.tail=a.sibling,m.renderingStartTime=De(),a.sibling=null,d=Ke.current,Q(Ke,y?d&1|2:d&1),Qt&&Wo(r,m.treeForkCount),a):(_e(r),null);case 22:case 23:return bs(r),sg(),m=r.memoizedState!==null,a!==null?a.memoizedState!==null!==m&&(r.flags|=8192):m&&(r.flags|=8192),m?(d&536870912)!==0&&(r.flags&128)===0&&(_e(r),r.subtreeFlags&6&&(r.flags|=8192)):_e(r),d=r.updateQueue,d!==null&&ad(r,d.retryQueue),d=null,a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(d=a.memoizedState.cachePool.pool),m=null,r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(m=r.memoizedState.cachePool.pool),m!==d&&(r.flags|=2048),a!==null&&G(Ci),null;case 24:return d=null,a!==null&&(d=a.memoizedState.cache),r.memoizedState.cache!==d&&(r.flags|=2048),qo(Je),_e(r),null;case 25:return null;case 30:return null}throw Error(s(156,r.tag))}function rD(a,r){switch(Pm(r),r.tag){case 1:return a=r.flags,a&65536?(r.flags=a&-65537|128,r):null;case 3:return qo(Je),St(),a=r.flags,(a&65536)!==0&&(a&128)===0?(r.flags=a&-65537|128,r):null;case 26:case 27:case 5:return Lt(r),null;case 31:if(r.memoizedState!==null){if(bs(r),r.alternate===null)throw Error(s(340));vi()}return a=r.flags,a&65536?(r.flags=a&-65537|128,r):null;case 13:if(bs(r),a=r.memoizedState,a!==null&&a.dehydrated!==null){if(r.alternate===null)throw Error(s(340));vi()}return a=r.flags,a&65536?(r.flags=a&-65537|128,r):null;case 19:return G(Ke),null;case 4:return St(),null;case 10:return qo(r.type),null;case 22:case 23:return bs(r),sg(),a!==null&&G(Ci),a=r.flags,a&65536?(r.flags=a&-65537|128,r):null;case 24:return qo(Je),null;case 25:return null;default:return null}}function zw(a,r){switch(Pm(r),r.tag){case 3:qo(Je),St();break;case 26:case 27:case 5:Lt(r);break;case 4:St();break;case 31:r.memoizedState!==null&&bs(r);break;case 13:bs(r);break;case 19:G(Ke);break;case 10:qo(r.type);break;case 22:case 23:bs(r),sg(),a!==null&&G(Ci);break;case 24:qo(Je)}}function cu(a,r){try{var d=r.updateQueue,m=d!==null?d.lastEffect:null;if(m!==null){var y=m.next;d=y;do{if((d.tag&a)===a){m=void 0;var w=d.create,I=d.inst;m=w(),I.destroy=m}d=d.next}while(d!==y)}}catch(A){be(r,r.return,A)}}function Ia(a,r,d){try{var m=r.updateQueue,y=m!==null?m.lastEffect:null;if(y!==null){var w=y.next;m=w;do{if((m.tag&a)===a){var I=m.inst,A=I.destroy;if(A!==void 0){I.destroy=void 0,y=r;var V=d,at=A;try{at()}catch(pt){be(y,V,pt)}}}m=m.next}while(m!==w)}}catch(pt){be(r,r.return,pt)}}function Lw(a){var r=a.updateQueue;if(r!==null){var d=a.stateNode;try{Nv(r,d)}catch(m){be(a,a.return,m)}}}function Bw(a,r,d){d.props=Ni(a.type,a.memoizedProps),d.state=a.memoizedState;try{d.componentWillUnmount()}catch(m){be(a,r,m)}}function hu(a,r){try{var d=a.ref;if(d!==null){switch(a.tag){case 26:case 27:case 5:var m=a.stateNode;break;case 30:m=a.stateNode;break;default:m=a.stateNode}typeof d=="function"?a.refCleanup=d(m):d.current=m}}catch(y){be(a,r,y)}}function yo(a,r){var d=a.ref,m=a.refCleanup;if(d!==null)if(typeof m=="function")try{m()}catch(y){be(a,r,y)}finally{a.refCleanup=null,a=a.alternate,a!=null&&(a.refCleanup=null)}else if(typeof d=="function")try{d(null)}catch(y){be(a,r,y)}else d.current=null}function Uw(a){var r=a.type,d=a.memoizedProps,m=a.stateNode;try{t:switch(r){case"button":case"input":case"select":case"textarea":d.autoFocus&&m.focus();break t;case"img":d.src?m.src=d.src:d.srcSet&&(m.srcset=d.srcSet)}}catch(y){be(a,a.return,y)}}function Fg(a,r,d){try{var m=a.stateNode;ED(m,a.type,d,r),m[Qn]=r}catch(y){be(a,a.return,y)}}function Vw(a){return a.tag===5||a.tag===3||a.tag===26||a.tag===27&&_a(a.type)||a.tag===4}function Mg(a){t:for(;;){for(;a.sibling===null;){if(a.return===null||Vw(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.tag===27&&_a(a.type)||a.flags&2||a.child===null||a.tag===4)continue t;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function zg(a,r,d){var m=a.tag;if(m===5||m===6)a=a.stateNode,r?(d.nodeType===9?d.body:d.nodeName==="HTML"?d.ownerDocument.body:d).insertBefore(a,r):(r=d.nodeType===9?d.body:d.nodeName==="HTML"?d.ownerDocument.body:d,r.appendChild(a),d=d._reactRootContainer,d!=null||r.onclick!==null||(r.onclick=Vo));else if(m!==4&&(m===27&&_a(a.type)&&(d=a.stateNode,r=null),a=a.child,a!==null))for(zg(a,r,d),a=a.sibling;a!==null;)zg(a,r,d),a=a.sibling}function id(a,r,d){var m=a.tag;if(m===5||m===6)a=a.stateNode,r?d.insertBefore(a,r):d.appendChild(a);else if(m!==4&&(m===27&&_a(a.type)&&(d=a.stateNode),a=a.child,a!==null))for(id(a,r,d),a=a.sibling;a!==null;)id(a,r,d),a=a.sibling}function Pw(a){var r=a.stateNode,d=a.memoizedProps;try{for(var m=a.type,y=r.attributes;y.length;)r.removeAttributeNode(y[0]);Nn(r,m,d),r[$n]=a,r[Qn]=d}catch(w){be(a,a.return,w)}}var Zo=!1,nn=!1,Lg=!1,Gw=typeof WeakSet=="function"?WeakSet:Set,bn=null;function lD(a,r){if(a=a.containerInfo,ax=Id,a=ev(a),Am(a)){if("selectionStart"in a)var d={start:a.selectionStart,end:a.selectionEnd};else t:{d=(d=a.ownerDocument)&&d.defaultView||window;var m=d.getSelection&&d.getSelection();if(m&&m.rangeCount!==0){d=m.anchorNode;var y=m.anchorOffset,w=m.focusNode;m=m.focusOffset;try{d.nodeType,w.nodeType}catch{d=null;break t}var I=0,A=-1,V=-1,at=0,pt=0,xt=a,rt=null;e:for(;;){for(var ct;xt!==d||y!==0&&xt.nodeType!==3||(A=I+y),xt!==w||m!==0&&xt.nodeType!==3||(V=I+m),xt.nodeType===3&&(I+=xt.nodeValue.length),(ct=xt.firstChild)!==null;)rt=xt,xt=ct;for(;;){if(xt===a)break e;if(rt===d&&++at===y&&(A=I),rt===w&&++pt===m&&(V=I),(ct=xt.nextSibling)!==null)break;xt=rt,rt=xt.parentNode}xt=ct}d=A===-1||V===-1?null:{start:A,end:V}}else d=null}d=d||{start:0,end:0}}else d=null;for(ix={focusedElem:a,selectionRange:d},Id=!1,bn=r;bn!==null;)if(r=bn,a=r.child,(r.subtreeFlags&1028)!==0&&a!==null)a.return=r,bn=a;else for(;bn!==null;){switch(r=bn,w=r.alternate,a=r.flags,r.tag){case 0:if((a&4)!==0&&(a=r.updateQueue,a=a!==null?a.events:null,a!==null))for(d=0;d<a.length;d++)y=a[d],y.ref.impl=y.nextImpl;break;case 11:case 15:break;case 1:if((a&1024)!==0&&w!==null){a=void 0,d=r,y=w.memoizedProps,w=w.memoizedState,m=d.stateNode;try{var kt=Ni(d.type,y);a=m.getSnapshotBeforeUpdate(kt,w),m.__reactInternalSnapshotBeforeUpdate=a}catch(_t){be(d,d.return,_t)}}break;case 3:if((a&1024)!==0){if(a=r.stateNode.containerInfo,d=a.nodeType,d===9)ux(a);else if(d===1)switch(a.nodeName){case"HEAD":case"HTML":case"BODY":ux(a);break;default:a.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((a&1024)!==0)throw Error(s(163))}if(a=r.sibling,a!==null){a.return=r.return,bn=a;break}bn=r.return}}function Ww(a,r,d){var m=d.flags;switch(d.tag){case 0:case 11:case 15:Jo(a,d),m&4&&cu(5,d);break;case 1:if(Jo(a,d),m&4)if(a=d.stateNode,r===null)try{a.componentDidMount()}catch(I){be(d,d.return,I)}else{var y=Ni(d.type,r.memoizedProps);r=r.memoizedState;try{a.componentDidUpdate(y,r,a.__reactInternalSnapshotBeforeUpdate)}catch(I){be(d,d.return,I)}}m&64&&Lw(d),m&512&&hu(d,d.return);break;case 3:if(Jo(a,d),m&64&&(a=d.updateQueue,a!==null)){if(r=null,d.child!==null)switch(d.child.tag){case 27:case 5:r=d.child.stateNode;break;case 1:r=d.child.stateNode}try{Nv(a,r)}catch(I){be(d,d.return,I)}}break;case 27:r===null&&m&4&&Pw(d);case 26:case 5:Jo(a,d),r===null&&m&4&&Uw(d),m&512&&hu(d,d.return);break;case 12:Jo(a,d);break;case 31:Jo(a,d),m&4&&jw(a,d);break;case 13:Jo(a,d),m&4&&Xw(a,d),m&64&&(a=d.memoizedState,a!==null&&(a=a.dehydrated,a!==null&&(d=xD.bind(null,d),zD(a,d))));break;case 22:if(m=d.memoizedState!==null||Zo,!m){r=r!==null&&r.memoizedState!==null||nn,y=Zo;var w=nn;Zo=m,(nn=r)&&!w?ta(a,d,(d.subtreeFlags&8772)!==0):Jo(a,d),Zo=y,nn=w}break;case 30:break;default:Jo(a,d)}}function Hw(a){var r=a.alternate;r!==null&&(a.alternate=null,Hw(r)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(r=a.stateNode,r!==null&&pm(r)),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}var ze=null,ts=!1;function Qo(a,r,d){for(d=d.child;d!==null;)qw(a,r,d),d=d.sibling}function qw(a,r,d){if(Gn&&typeof Gn.onCommitFiberUnmount=="function")try{Gn.onCommitFiberUnmount(mo,d)}catch{}switch(d.tag){case 26:nn||yo(d,r),Qo(a,r,d),d.memoizedState?d.memoizedState.count--:d.stateNode&&(d=d.stateNode,d.parentNode.removeChild(d));break;case 27:nn||yo(d,r);var m=ze,y=ts;_a(d.type)&&(ze=d.stateNode,ts=!1),Qo(a,r,d),vu(d.stateNode),ze=m,ts=y;break;case 5:nn||yo(d,r);case 6:if(m=ze,y=ts,ze=null,Qo(a,r,d),ze=m,ts=y,ze!==null)if(ts)try{(ze.nodeType===9?ze.body:ze.nodeName==="HTML"?ze.ownerDocument.body:ze).removeChild(d.stateNode)}catch(w){be(d,r,w)}else try{ze.removeChild(d.stateNode)}catch(w){be(d,r,w)}break;case 18:ze!==null&&(ts?(a=ze,LS(a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a,d.stateNode),Yr(a)):LS(ze,d.stateNode));break;case 4:m=ze,y=ts,ze=d.stateNode.containerInfo,ts=!0,Qo(a,r,d),ze=m,ts=y;break;case 0:case 11:case 14:case 15:Ia(2,d,r),nn||Ia(4,d,r),Qo(a,r,d);break;case 1:nn||(yo(d,r),m=d.stateNode,typeof m.componentWillUnmount=="function"&&Bw(d,r,m)),Qo(a,r,d);break;case 21:Qo(a,r,d);break;case 22:nn=(m=nn)||d.memoizedState!==null,Qo(a,r,d),nn=m;break;default:Qo(a,r,d)}}function jw(a,r){if(r.memoizedState===null&&(a=r.alternate,a!==null&&(a=a.memoizedState,a!==null))){a=a.dehydrated;try{Yr(a)}catch(d){be(r,r.return,d)}}}function Xw(a,r){if(r.memoizedState===null&&(a=r.alternate,a!==null&&(a=a.memoizedState,a!==null&&(a=a.dehydrated,a!==null))))try{Yr(a)}catch(d){be(r,r.return,d)}}function uD(a){switch(a.tag){case 31:case 13:case 19:var r=a.stateNode;return r===null&&(r=a.stateNode=new Gw),r;case 22:return a=a.stateNode,r=a._retryCache,r===null&&(r=a._retryCache=new Gw),r;default:throw Error(s(435,a.tag))}}function rd(a,r){var d=uD(a);r.forEach(function(m){if(!d.has(m)){d.add(m);var y=bD.bind(null,a,m);m.then(y,y)}})}function es(a,r){var d=r.deletions;if(d!==null)for(var m=0;m<d.length;m++){var y=d[m],w=a,I=r,A=I;t:for(;A!==null;){switch(A.tag){case 27:if(_a(A.type)){ze=A.stateNode,ts=!1;break t}break;case 5:ze=A.stateNode,ts=!1;break t;case 3:case 4:ze=A.stateNode.containerInfo,ts=!0;break t}A=A.return}if(ze===null)throw Error(s(160));qw(w,I,y),ze=null,ts=!1,w=y.alternate,w!==null&&(w.return=null),y.return=null}if(r.subtreeFlags&13886)for(r=r.child;r!==null;)Kw(r,a),r=r.sibling}var to=null;function Kw(a,r){var d=a.alternate,m=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:es(r,a),ns(a),m&4&&(Ia(3,a,a.return),cu(3,a),Ia(5,a,a.return));break;case 1:es(r,a),ns(a),m&512&&(nn||d===null||yo(d,d.return)),m&64&&Zo&&(a=a.updateQueue,a!==null&&(m=a.callbacks,m!==null&&(d=a.shared.hiddenCallbacks,a.shared.hiddenCallbacks=d===null?m:d.concat(m))));break;case 26:var y=to;if(es(r,a),ns(a),m&512&&(nn||d===null||yo(d,d.return)),m&4){var w=d!==null?d.memoizedState:null;if(m=a.memoizedState,d===null)if(m===null)if(a.stateNode===null){t:{m=a.type,d=a.memoizedProps,y=y.ownerDocument||y;e:switch(m){case"title":w=y.getElementsByTagName("title")[0],(!w||w[Ll]||w[$n]||w.namespaceURI==="http://www.w3.org/2000/svg"||w.hasAttribute("itemprop"))&&(w=y.createElement(m),y.head.insertBefore(w,y.querySelector("head > title"))),Nn(w,m,d),w[$n]=a,xn(w),m=w;break t;case"link":var I=KS("link","href",y).get(m+(d.href||""));if(I){for(var A=0;A<I.length;A++)if(w=I[A],w.getAttribute("href")===(d.href==null||d.href===""?null:d.href)&&w.getAttribute("rel")===(d.rel==null?null:d.rel)&&w.getAttribute("title")===(d.title==null?null:d.title)&&w.getAttribute("crossorigin")===(d.crossOrigin==null?null:d.crossOrigin)){I.splice(A,1);break e}}w=y.createElement(m),Nn(w,m,d),y.head.appendChild(w);break;case"meta":if(I=KS("meta","content",y).get(m+(d.content||""))){for(A=0;A<I.length;A++)if(w=I[A],w.getAttribute("content")===(d.content==null?null:""+d.content)&&w.getAttribute("name")===(d.name==null?null:d.name)&&w.getAttribute("property")===(d.property==null?null:d.property)&&w.getAttribute("http-equiv")===(d.httpEquiv==null?null:d.httpEquiv)&&w.getAttribute("charset")===(d.charSet==null?null:d.charSet)){I.splice(A,1);break e}}w=y.createElement(m),Nn(w,m,d),y.head.appendChild(w);break;default:throw Error(s(468,m))}w[$n]=a,xn(w),m=w}a.stateNode=m}else YS(y,a.type,a.stateNode);else a.stateNode=XS(y,m,a.memoizedProps);else w!==m?(w===null?d.stateNode!==null&&(d=d.stateNode,d.parentNode.removeChild(d)):w.count--,m===null?YS(y,a.type,a.stateNode):XS(y,m,a.memoizedProps)):m===null&&a.stateNode!==null&&Fg(a,a.memoizedProps,d.memoizedProps)}break;case 27:es(r,a),ns(a),m&512&&(nn||d===null||yo(d,d.return)),d!==null&&m&4&&Fg(a,a.memoizedProps,d.memoizedProps);break;case 5:if(es(r,a),ns(a),m&512&&(nn||d===null||yo(d,d.return)),a.flags&32){y=a.stateNode;try{yr(y,"")}catch(kt){be(a,a.return,kt)}}m&4&&a.stateNode!=null&&(y=a.memoizedProps,Fg(a,y,d!==null?d.memoizedProps:y)),m&1024&&(Lg=!0);break;case 6:if(es(r,a),ns(a),m&4){if(a.stateNode===null)throw Error(s(162));m=a.memoizedProps,d=a.stateNode;try{d.nodeValue=m}catch(kt){be(a,a.return,kt)}}break;case 3:if(Cd=null,y=to,to=wd(r.containerInfo),es(r,a),to=y,ns(a),m&4&&d!==null&&d.memoizedState.isDehydrated)try{Yr(r.containerInfo)}catch(kt){be(a,a.return,kt)}Lg&&(Lg=!1,Yw(a));break;case 4:m=to,to=wd(a.stateNode.containerInfo),es(r,a),ns(a),to=m;break;case 12:es(r,a),ns(a);break;case 31:es(r,a),ns(a),m&4&&(m=a.updateQueue,m!==null&&(a.updateQueue=null,rd(a,m)));break;case 13:es(r,a),ns(a),a.child.flags&8192&&a.memoizedState!==null!=(d!==null&&d.memoizedState!==null)&&(ud=De()),m&4&&(m=a.updateQueue,m!==null&&(a.updateQueue=null,rd(a,m)));break;case 22:y=a.memoizedState!==null;var V=d!==null&&d.memoizedState!==null,at=Zo,pt=nn;if(Zo=at||y,nn=pt||V,es(r,a),nn=pt,Zo=at,ns(a),m&8192)t:for(r=a.stateNode,r._visibility=y?r._visibility&-2:r._visibility|1,y&&(d===null||V||Zo||nn||Ei(a)),d=null,r=a;;){if(r.tag===5||r.tag===26){if(d===null){V=d=r;try{if(w=V.stateNode,y)I=w.style,typeof I.setProperty=="function"?I.setProperty("display","none","important"):I.display="none";else{A=V.stateNode;var xt=V.memoizedProps.style,rt=xt!=null&&xt.hasOwnProperty("display")?xt.display:null;A.style.display=rt==null||typeof rt=="boolean"?"":(""+rt).trim()}}catch(kt){be(V,V.return,kt)}}}else if(r.tag===6){if(d===null){V=r;try{V.stateNode.nodeValue=y?"":V.memoizedProps}catch(kt){be(V,V.return,kt)}}}else if(r.tag===18){if(d===null){V=r;try{var ct=V.stateNode;y?BS(ct,!0):BS(V.stateNode,!1)}catch(kt){be(V,V.return,kt)}}}else if((r.tag!==22&&r.tag!==23||r.memoizedState===null||r===a)&&r.child!==null){r.child.return=r,r=r.child;continue}if(r===a)break t;for(;r.sibling===null;){if(r.return===null||r.return===a)break t;d===r&&(d=null),r=r.return}d===r&&(d=null),r.sibling.return=r.return,r=r.sibling}m&4&&(m=a.updateQueue,m!==null&&(d=m.retryQueue,d!==null&&(m.retryQueue=null,rd(a,d))));break;case 19:es(r,a),ns(a),m&4&&(m=a.updateQueue,m!==null&&(a.updateQueue=null,rd(a,m)));break;case 30:break;case 21:break;default:es(r,a),ns(a)}}function ns(a){var r=a.flags;if(r&2){try{for(var d,m=a.return;m!==null;){if(Vw(m)){d=m;break}m=m.return}if(d==null)throw Error(s(160));switch(d.tag){case 27:var y=d.stateNode,w=Mg(a);id(a,w,y);break;case 5:var I=d.stateNode;d.flags&32&&(yr(I,""),d.flags&=-33);var A=Mg(a);id(a,A,I);break;case 3:case 4:var V=d.stateNode.containerInfo,at=Mg(a);zg(a,at,V);break;default:throw Error(s(161))}}catch(pt){be(a,a.return,pt)}a.flags&=-3}r&4096&&(a.flags&=-4097)}function Yw(a){if(a.subtreeFlags&1024)for(a=a.child;a!==null;){var r=a;Yw(r),r.tag===5&&r.flags&1024&&r.stateNode.reset(),a=a.sibling}}function Jo(a,r){if(r.subtreeFlags&8772)for(r=r.child;r!==null;)Ww(a,r.alternate,r),r=r.sibling}function Ei(a){for(a=a.child;a!==null;){var r=a;switch(r.tag){case 0:case 11:case 14:case 15:Ia(4,r,r.return),Ei(r);break;case 1:yo(r,r.return);var d=r.stateNode;typeof d.componentWillUnmount=="function"&&Bw(r,r.return,d),Ei(r);break;case 27:vu(r.stateNode);case 26:case 5:yo(r,r.return),Ei(r);break;case 22:r.memoizedState===null&&Ei(r);break;case 30:Ei(r);break;default:Ei(r)}a=a.sibling}}function ta(a,r,d){for(d=d&&(r.subtreeFlags&8772)!==0,r=r.child;r!==null;){var m=r.alternate,y=a,w=r,I=w.flags;switch(w.tag){case 0:case 11:case 15:ta(y,w,d),cu(4,w);break;case 1:if(ta(y,w,d),m=w,y=m.stateNode,typeof y.componentDidMount=="function")try{y.componentDidMount()}catch(at){be(m,m.return,at)}if(m=w,y=m.updateQueue,y!==null){var A=m.stateNode;try{var V=y.shared.hiddenCallbacks;if(V!==null)for(y.shared.hiddenCallbacks=null,y=0;y<V.length;y++)Iv(V[y],A)}catch(at){be(m,m.return,at)}}d&&I&64&&Lw(w),hu(w,w.return);break;case 27:Pw(w);case 26:case 5:ta(y,w,d),d&&m===null&&I&4&&Uw(w),hu(w,w.return);break;case 12:ta(y,w,d);break;case 31:ta(y,w,d),d&&I&4&&jw(y,w);break;case 13:ta(y,w,d),d&&I&4&&Xw(y,w);break;case 22:w.memoizedState===null&&ta(y,w,d),hu(w,w.return);break;case 30:break;default:ta(y,w,d)}r=r.sibling}}function Bg(a,r){var d=null;a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(d=a.memoizedState.cachePool.pool),a=null,r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(a=r.memoizedState.cachePool.pool),a!==d&&(a!=null&&a.refCount++,d!=null&&Zl(d))}function Ug(a,r){a=null,r.alternate!==null&&(a=r.alternate.memoizedState.cache),r=r.memoizedState.cache,r!==a&&(r.refCount++,a!=null&&Zl(a))}function eo(a,r,d,m){if(r.subtreeFlags&10256)for(r=r.child;r!==null;)Zw(a,r,d,m),r=r.sibling}function Zw(a,r,d,m){var y=r.flags;switch(r.tag){case 0:case 11:case 15:eo(a,r,d,m),y&2048&&cu(9,r);break;case 1:eo(a,r,d,m);break;case 3:eo(a,r,d,m),y&2048&&(a=null,r.alternate!==null&&(a=r.alternate.memoizedState.cache),r=r.memoizedState.cache,r!==a&&(r.refCount++,a!=null&&Zl(a)));break;case 12:if(y&2048){eo(a,r,d,m),a=r.stateNode;try{var w=r.memoizedProps,I=w.id,A=w.onPostCommit;typeof A=="function"&&A(I,r.alternate===null?"mount":"update",a.passiveEffectDuration,-0)}catch(V){be(r,r.return,V)}}else eo(a,r,d,m);break;case 31:eo(a,r,d,m);break;case 13:eo(a,r,d,m);break;case 23:break;case 22:w=r.stateNode,I=r.alternate,r.memoizedState!==null?w._visibility&2?eo(a,r,d,m):du(a,r):w._visibility&2?eo(a,r,d,m):(w._visibility|=2,Br(a,r,d,m,(r.subtreeFlags&10256)!==0||!1)),y&2048&&Bg(I,r);break;case 24:eo(a,r,d,m),y&2048&&Ug(r.alternate,r);break;default:eo(a,r,d,m)}}function Br(a,r,d,m,y){for(y=y&&((r.subtreeFlags&10256)!==0||!1),r=r.child;r!==null;){var w=a,I=r,A=d,V=m,at=I.flags;switch(I.tag){case 0:case 11:case 15:Br(w,I,A,V,y),cu(8,I);break;case 23:break;case 22:var pt=I.stateNode;I.memoizedState!==null?pt._visibility&2?Br(w,I,A,V,y):du(w,I):(pt._visibility|=2,Br(w,I,A,V,y)),y&&at&2048&&Bg(I.alternate,I);break;case 24:Br(w,I,A,V,y),y&&at&2048&&Ug(I.alternate,I);break;default:Br(w,I,A,V,y)}r=r.sibling}}function du(a,r){if(r.subtreeFlags&10256)for(r=r.child;r!==null;){var d=a,m=r,y=m.flags;switch(m.tag){case 22:du(d,m),y&2048&&Bg(m.alternate,m);break;case 24:du(d,m),y&2048&&Ug(m.alternate,m);break;default:du(d,m)}r=r.sibling}}var fu=8192;function Ur(a,r,d){if(a.subtreeFlags&fu)for(a=a.child;a!==null;)Qw(a,r,d),a=a.sibling}function Qw(a,r,d){switch(a.tag){case 26:Ur(a,r,d),a.flags&fu&&a.memoizedState!==null&&KD(d,to,a.memoizedState,a.memoizedProps);break;case 5:Ur(a,r,d);break;case 3:case 4:var m=to;to=wd(a.stateNode.containerInfo),Ur(a,r,d),to=m;break;case 22:a.memoizedState===null&&(m=a.alternate,m!==null&&m.memoizedState!==null?(m=fu,fu=16777216,Ur(a,r,d),fu=m):Ur(a,r,d));break;default:Ur(a,r,d)}}function Jw(a){var r=a.alternate;if(r!==null&&(a=r.child,a!==null)){r.child=null;do r=a.sibling,a.sibling=null,a=r;while(a!==null)}}function pu(a){var r=a.deletions;if((a.flags&16)!==0){if(r!==null)for(var d=0;d<r.length;d++){var m=r[d];bn=m,eS(m,a)}Jw(a)}if(a.subtreeFlags&10256)for(a=a.child;a!==null;)tS(a),a=a.sibling}function tS(a){switch(a.tag){case 0:case 11:case 15:pu(a),a.flags&2048&&Ia(9,a,a.return);break;case 3:pu(a);break;case 12:pu(a);break;case 22:var r=a.stateNode;a.memoizedState!==null&&r._visibility&2&&(a.return===null||a.return.tag!==13)?(r._visibility&=-3,ld(a)):pu(a);break;default:pu(a)}}function ld(a){var r=a.deletions;if((a.flags&16)!==0){if(r!==null)for(var d=0;d<r.length;d++){var m=r[d];bn=m,eS(m,a)}Jw(a)}for(a=a.child;a!==null;){switch(r=a,r.tag){case 0:case 11:case 15:Ia(8,r,r.return),ld(r);break;case 22:d=r.stateNode,d._visibility&2&&(d._visibility&=-3,ld(r));break;default:ld(r)}a=a.sibling}}function eS(a,r){for(;bn!==null;){var d=bn;switch(d.tag){case 0:case 11:case 15:Ia(8,d,r);break;case 23:case 22:if(d.memoizedState!==null&&d.memoizedState.cachePool!==null){var m=d.memoizedState.cachePool.pool;m!=null&&m.refCount++}break;case 24:Zl(d.memoizedState.cache)}if(m=d.child,m!==null)m.return=d,bn=m;else t:for(d=a;bn!==null;){m=bn;var y=m.sibling,w=m.return;if(Hw(m),m===d){bn=null;break t}if(y!==null){y.return=w,bn=y;break t}bn=w}}}var cD={getCacheForType:function(a){var r=kn(Je),d=r.data.get(a);return d===void 0&&(d=a(),r.data.set(a,d)),d},cacheSignal:function(){return kn(Je).controller.signal}},hD=typeof WeakMap=="function"?WeakMap:Map,fe=0,ke=null,Xt=null,Yt=0,xe=0,ys=null,Na=!1,Vr=!1,Vg=!1,ea=0,Pe=0,Ea=0,Ri=0,Pg=0,vs=0,Pr=0,mu=null,ss=null,Gg=!1,ud=0,nS=0,cd=1/0,hd=null,Ra=null,hn=0,Aa=null,Gr=null,na=0,Wg=0,Hg=null,sS=null,gu=0,qg=null;function ws(){return(fe&2)!==0&&Yt!==0?Yt&-Yt:L.T!==null?Qg():y1()}function oS(){if(vs===0)if((Yt&536870912)===0||Qt){var a=yh;yh<<=1,(yh&3932160)===0&&(yh=262144),vs=a}else vs=536870912;return a=xs.current,a!==null&&(a.flags|=32),vs}function os(a,r,d){(a===ke&&(xe===2||xe===9)||a.cancelPendingCommit!==null)&&(Wr(a,0),Da(a,Yt,vs,!1)),zl(a,d),((fe&2)===0||a!==ke)&&(a===ke&&((fe&2)===0&&(Ri|=d),Pe===4&&Da(a,Yt,vs,!1)),vo(a))}function aS(a,r,d){if((fe&6)!==0)throw Error(s(327));var m=!d&&(r&127)===0&&(r&a.expiredLanes)===0||Ml(a,r),y=m?pD(a,r):Xg(a,r,!0),w=m;do{if(y===0){Vr&&!m&&Da(a,r,0,!1);break}else{if(d=a.current.alternate,w&&!dD(d)){y=Xg(a,r,!1),w=!1;continue}if(y===2){if(w=r,a.errorRecoveryDisabledLanes&w)var I=0;else I=a.pendingLanes&-536870913,I=I!==0?I:I&536870912?536870912:0;if(I!==0){r=I;t:{var A=a;y=mu;var V=A.current.memoizedState.isDehydrated;if(V&&(Wr(A,I).flags|=256),I=Xg(A,I,!1),I!==2){if(Vg&&!V){A.errorRecoveryDisabledLanes|=w,Ri|=w,y=4;break t}w=ss,ss=y,w!==null&&(ss===null?ss=w:ss.push.apply(ss,w))}y=I}if(w=!1,y!==2)continue}}if(y===1){Wr(a,0),Da(a,r,0,!0);break}t:{switch(m=a,w=y,w){case 0:case 1:throw Error(s(345));case 4:if((r&4194048)!==r)break;case 6:Da(m,r,vs,!Na);break t;case 2:ss=null;break;case 3:case 5:break;default:throw Error(s(329))}if((r&62914560)===r&&(y=ud+300-De(),10<y)){if(Da(m,r,vs,!Na),wh(m,0,!0)!==0)break t;na=r,m.timeoutHandle=MS(iS.bind(null,m,d,ss,hd,Gg,r,vs,Ri,Pr,Na,w,"Throttled",-0,0),y);break t}iS(m,d,ss,hd,Gg,r,vs,Ri,Pr,Na,w,null,-0,0)}}break}while(!0);vo(a)}function iS(a,r,d,m,y,w,I,A,V,at,pt,xt,rt,ct){if(a.timeoutHandle=-1,xt=r.subtreeFlags,xt&8192||(xt&16785408)===16785408){xt={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Vo},Qw(r,w,xt);var kt=(w&62914560)===w?ud-De():(w&4194048)===w?nS-De():0;if(kt=YD(xt,kt),kt!==null){na=w,a.cancelPendingCommit=kt(pS.bind(null,a,r,w,d,m,y,I,A,V,pt,xt,null,rt,ct)),Da(a,w,I,!at);return}}pS(a,r,w,d,m,y,I,A,V)}function dD(a){for(var r=a;;){var d=r.tag;if((d===0||d===11||d===15)&&r.flags&16384&&(d=r.updateQueue,d!==null&&(d=d.stores,d!==null)))for(var m=0;m<d.length;m++){var y=d[m],w=y.getSnapshot;y=y.value;try{if(!ms(w(),y))return!1}catch{return!1}}if(d=r.child,r.subtreeFlags&16384&&d!==null)d.return=r,r=d;else{if(r===a)break;for(;r.sibling===null;){if(r.return===null||r.return===a)return!0;r=r.return}r.sibling.return=r.return,r=r.sibling}}return!0}function Da(a,r,d,m){r&=~Pg,r&=~Ri,a.suspendedLanes|=r,a.pingedLanes&=~r,m&&(a.warmLanes|=r),m=a.expirationTimes;for(var y=r;0<y;){var w=31-ps(y),I=1<<w;m[w]=-1,y&=~I}d!==0&&g1(a,d,r)}function dd(){return(fe&6)===0?(xu(0),!1):!0}function jg(){if(Xt!==null){if(xe===0)var a=Xt.return;else a=Xt,Ho=wi=null,ug(a),_r=null,Jl=0,a=Xt;for(;a!==null;)zw(a.alternate,a),a=a.return;Xt=null}}function Wr(a,r){var d=a.timeoutHandle;d!==-1&&(a.timeoutHandle=-1,DD(d)),d=a.cancelPendingCommit,d!==null&&(a.cancelPendingCommit=null,d()),na=0,jg(),ke=a,Xt=d=Go(a.current,null),Yt=r,xe=0,ys=null,Na=!1,Vr=Ml(a,r),Vg=!1,Pr=vs=Pg=Ri=Ea=Pe=0,ss=mu=null,Gg=!1,(r&8)!==0&&(r|=r&32);var m=a.entangledLanes;if(m!==0)for(a=a.entanglements,m&=r;0<m;){var y=31-ps(m),w=1<<y;r|=a[y],m&=~w}return ea=r,Oh(),d}function rS(a,r){Vt=null,L.H=ru,r===Or||r===Vh?(r=Cv(),xe=3):r===Zm?(r=Cv(),xe=4):xe=r===Tg?8:r!==null&&typeof r=="object"&&typeof r.then=="function"?6:1,ys=r,Xt===null&&(Pe=1,ed(a,Ds(r,a.current)))}function lS(){var a=xs.current;return a===null?!0:(Yt&4194048)===Yt?Ms===null:(Yt&62914560)===Yt||(Yt&536870912)!==0?a===Ms:!1}function uS(){var a=L.H;return L.H=ru,a===null?ru:a}function cS(){var a=L.A;return L.A=cD,a}function fd(){Pe=4,Na||(Yt&4194048)!==Yt&&xs.current!==null||(Vr=!0),(Ea&134217727)===0&&(Ri&134217727)===0||ke===null||Da(ke,Yt,vs,!1)}function Xg(a,r,d){var m=fe;fe|=2;var y=uS(),w=cS();(ke!==a||Yt!==r)&&(hd=null,Wr(a,r)),r=!1;var I=Pe;t:do try{if(xe!==0&&Xt!==null){var A=Xt,V=ys;switch(xe){case 8:jg(),I=6;break t;case 3:case 2:case 9:case 6:xs.current===null&&(r=!0);var at=xe;if(xe=0,ys=null,Hr(a,A,V,at),d&&Vr){I=0;break t}break;default:at=xe,xe=0,ys=null,Hr(a,A,V,at)}}fD(),I=Pe;break}catch(pt){rS(a,pt)}while(!0);return r&&a.shellSuspendCounter++,Ho=wi=null,fe=m,L.H=y,L.A=w,Xt===null&&(ke=null,Yt=0,Oh()),I}function fD(){for(;Xt!==null;)hS(Xt)}function pD(a,r){var d=fe;fe|=2;var m=uS(),y=cS();ke!==a||Yt!==r?(hd=null,cd=De()+500,Wr(a,r)):Vr=Ml(a,r);t:do try{if(xe!==0&&Xt!==null){r=Xt;var w=ys;e:switch(xe){case 1:xe=0,ys=null,Hr(a,r,w,1);break;case 2:case 9:if(wv(w)){xe=0,ys=null,dS(r);break}r=function(){xe!==2&&xe!==9||ke!==a||(xe=7),vo(a)},w.then(r,r);break t;case 3:xe=7;break t;case 4:xe=5;break t;case 7:wv(w)?(xe=0,ys=null,dS(r)):(xe=0,ys=null,Hr(a,r,w,7));break;case 5:var I=null;switch(Xt.tag){case 26:I=Xt.memoizedState;case 5:case 27:var A=Xt;if(I?ZS(I):A.stateNode.complete){xe=0,ys=null;var V=A.sibling;if(V!==null)Xt=V;else{var at=A.return;at!==null?(Xt=at,pd(at)):Xt=null}break e}}xe=0,ys=null,Hr(a,r,w,5);break;case 6:xe=0,ys=null,Hr(a,r,w,6);break;case 8:jg(),Pe=6;break t;default:throw Error(s(462))}}mD();break}catch(pt){rS(a,pt)}while(!0);return Ho=wi=null,L.H=m,L.A=y,fe=d,Xt!==null?0:(ke=null,Yt=0,Oh(),Pe)}function mD(){for(;Xt!==null&&!Pn();)hS(Xt)}function hS(a){var r=Fw(a.alternate,a,ea);a.memoizedProps=a.pendingProps,r===null?pd(a):Xt=r}function dS(a){var r=a,d=r.alternate;switch(r.tag){case 15:case 0:r=Ew(d,r,r.pendingProps,r.type,void 0,Yt);break;case 11:r=Ew(d,r,r.pendingProps,r.type.render,r.ref,Yt);break;case 5:ug(r);default:zw(d,r),r=Xt=cv(r,ea),r=Fw(d,r,ea)}a.memoizedProps=a.pendingProps,r===null?pd(a):Xt=r}function Hr(a,r,d,m){Ho=wi=null,ug(r),_r=null,Jl=0;var y=r.return;try{if(sD(a,y,r,d,Yt)){Pe=1,ed(a,Ds(d,a.current)),Xt=null;return}}catch(w){if(y!==null)throw Xt=y,w;Pe=1,ed(a,Ds(d,a.current)),Xt=null;return}r.flags&32768?(Qt||m===1?a=!0:Vr||(Yt&536870912)!==0?a=!1:(Na=a=!0,(m===2||m===9||m===3||m===6)&&(m=xs.current,m!==null&&m.tag===13&&(m.flags|=16384))),fS(r,a)):pd(r)}function pd(a){var r=a;do{if((r.flags&32768)!==0){fS(r,Na);return}a=r.return;var d=iD(r.alternate,r,ea);if(d!==null){Xt=d;return}if(r=r.sibling,r!==null){Xt=r;return}Xt=r=a}while(r!==null);Pe===0&&(Pe=5)}function fS(a,r){do{var d=rD(a.alternate,a);if(d!==null){d.flags&=32767,Xt=d;return}if(d=a.return,d!==null&&(d.flags|=32768,d.subtreeFlags=0,d.deletions=null),!r&&(a=a.sibling,a!==null)){Xt=a;return}Xt=a=d}while(a!==null);Pe=6,Xt=null}function pS(a,r,d,m,y,w,I,A,V){a.cancelPendingCommit=null;do md();while(hn!==0);if((fe&6)!==0)throw Error(s(327));if(r!==null){if(r===a.current)throw Error(s(177));if(w=r.lanes|r.childLanes,w|=Mm,XR(a,d,w,I,A,V),a===ke&&(Xt=ke=null,Yt=0),Gr=r,Aa=a,na=d,Wg=w,Hg=y,sS=m,(r.subtreeFlags&10256)!==0||(r.flags&10256)!==0?(a.callbackNode=null,a.callbackPriority=0,yD(fs,function(){return yS(),null})):(a.callbackNode=null,a.callbackPriority=0),m=(r.flags&13878)!==0,(r.subtreeFlags&13878)!==0||m){m=L.T,L.T=null,y=P.p,P.p=2,I=fe,fe|=4;try{lD(a,r,d)}finally{fe=I,P.p=y,L.T=m}}hn=1,mS(),gS(),xS()}}function mS(){if(hn===1){hn=0;var a=Aa,r=Gr,d=(r.flags&13878)!==0;if((r.subtreeFlags&13878)!==0||d){d=L.T,L.T=null;var m=P.p;P.p=2;var y=fe;fe|=4;try{Kw(r,a);var w=ix,I=ev(a.containerInfo),A=w.focusedElem,V=w.selectionRange;if(I!==A&&A&&A.ownerDocument&&tv(A.ownerDocument.documentElement,A)){if(V!==null&&Am(A)){var at=V.start,pt=V.end;if(pt===void 0&&(pt=at),"selectionStart"in A)A.selectionStart=at,A.selectionEnd=Math.min(pt,A.value.length);else{var xt=A.ownerDocument||document,rt=xt&&xt.defaultView||window;if(rt.getSelection){var ct=rt.getSelection(),kt=A.textContent.length,_t=Math.min(V.start,kt),Ce=V.end===void 0?_t:Math.min(V.end,kt);!ct.extend&&_t>Ce&&(I=Ce,Ce=_t,_t=I);var et=J1(A,_t),j=J1(A,Ce);if(et&&j&&(ct.rangeCount!==1||ct.anchorNode!==et.node||ct.anchorOffset!==et.offset||ct.focusNode!==j.node||ct.focusOffset!==j.offset)){var ot=xt.createRange();ot.setStart(et.node,et.offset),ct.removeAllRanges(),_t>Ce?(ct.addRange(ot),ct.extend(j.node,j.offset)):(ot.setEnd(j.node,j.offset),ct.addRange(ot))}}}}for(xt=[],ct=A;ct=ct.parentNode;)ct.nodeType===1&&xt.push({element:ct,left:ct.scrollLeft,top:ct.scrollTop});for(typeof A.focus=="function"&&A.focus(),A=0;A<xt.length;A++){var mt=xt[A];mt.element.scrollLeft=mt.left,mt.element.scrollTop=mt.top}}Id=!!ax,ix=ax=null}finally{fe=y,P.p=m,L.T=d}}a.current=r,hn=2}}function gS(){if(hn===2){hn=0;var a=Aa,r=Gr,d=(r.flags&8772)!==0;if((r.subtreeFlags&8772)!==0||d){d=L.T,L.T=null;var m=P.p;P.p=2;var y=fe;fe|=4;try{Ww(a,r.alternate,r)}finally{fe=y,P.p=m,L.T=d}}hn=3}}function xS(){if(hn===4||hn===3){hn=0,Bo();var a=Aa,r=Gr,d=na,m=sS;(r.subtreeFlags&10256)!==0||(r.flags&10256)!==0?hn=5:(hn=0,Gr=Aa=null,bS(a,a.pendingLanes));var y=a.pendingLanes;if(y===0&&(Ra=null),dm(d),r=r.stateNode,Gn&&typeof Gn.onCommitFiberRoot=="function")try{Gn.onCommitFiberRoot(mo,r,void 0,(r.current.flags&128)===128)}catch{}if(m!==null){r=L.T,y=P.p,P.p=2,L.T=null;try{for(var w=a.onRecoverableError,I=0;I<m.length;I++){var A=m[I];w(A.value,{componentStack:A.stack})}}finally{L.T=r,P.p=y}}(na&3)!==0&&md(),vo(a),y=a.pendingLanes,(d&261930)!==0&&(y&42)!==0?a===qg?gu++:(gu=0,qg=a):gu=0,xu(0)}}function bS(a,r){(a.pooledCacheLanes&=r)===0&&(r=a.pooledCache,r!=null&&(a.pooledCache=null,Zl(r)))}function md(){return mS(),gS(),xS(),yS()}function yS(){if(hn!==5)return!1;var a=Aa,r=Wg;Wg=0;var d=dm(na),m=L.T,y=P.p;try{P.p=32>d?32:d,L.T=null,d=Hg,Hg=null;var w=Aa,I=na;if(hn=0,Gr=Aa=null,na=0,(fe&6)!==0)throw Error(s(331));var A=fe;if(fe|=4,tS(w.current),Zw(w,w.current,I,d),fe=A,xu(0,!1),Gn&&typeof Gn.onPostCommitFiberRoot=="function")try{Gn.onPostCommitFiberRoot(mo,w)}catch{}return!0}finally{P.p=y,L.T=m,bS(a,r)}}function vS(a,r,d){r=Ds(d,r),r=$g(a.stateNode,r,2),a=$a(a,r,2),a!==null&&(zl(a,2),vo(a))}function be(a,r,d){if(a.tag===3)vS(a,a,d);else for(;r!==null;){if(r.tag===3){vS(r,a,d);break}else if(r.tag===1){var m=r.stateNode;if(typeof r.type.getDerivedStateFromError=="function"||typeof m.componentDidCatch=="function"&&(Ra===null||!Ra.has(m))){a=Ds(d,a),d=ww(2),m=$a(r,d,2),m!==null&&(Sw(d,m,r,a),zl(m,2),vo(m));break}}r=r.return}}function Kg(a,r,d){var m=a.pingCache;if(m===null){m=a.pingCache=new hD;var y=new Set;m.set(r,y)}else y=m.get(r),y===void 0&&(y=new Set,m.set(r,y));y.has(d)||(Vg=!0,y.add(d),a=gD.bind(null,a,r,d),r.then(a,a))}function gD(a,r,d){var m=a.pingCache;m!==null&&m.delete(r),a.pingedLanes|=a.suspendedLanes&d,a.warmLanes&=~d,ke===a&&(Yt&d)===d&&(Pe===4||Pe===3&&(Yt&62914560)===Yt&&300>De()-ud?(fe&2)===0&&Wr(a,0):Pg|=d,Pr===Yt&&(Pr=0)),vo(a)}function wS(a,r){r===0&&(r=m1()),a=bi(a,r),a!==null&&(zl(a,r),vo(a))}function xD(a){var r=a.memoizedState,d=0;r!==null&&(d=r.retryLane),wS(a,d)}function bD(a,r){var d=0;switch(a.tag){case 31:case 13:var m=a.stateNode,y=a.memoizedState;y!==null&&(d=y.retryLane);break;case 19:m=a.stateNode;break;case 22:m=a.stateNode._retryCache;break;default:throw Error(s(314))}m!==null&&m.delete(r),wS(a,d)}function yD(a,r){return Ue(a,r)}var gd=null,qr=null,Yg=!1,xd=!1,Zg=!1,Oa=0;function vo(a){a!==qr&&a.next===null&&(qr===null?gd=qr=a:qr=qr.next=a),xd=!0,Yg||(Yg=!0,wD())}function xu(a,r){if(!Zg&&xd){Zg=!0;do for(var d=!1,m=gd;m!==null;){if(a!==0){var y=m.pendingLanes;if(y===0)var w=0;else{var I=m.suspendedLanes,A=m.pingedLanes;w=(1<<31-ps(42|a)+1)-1,w&=y&~(I&~A),w=w&201326741?w&201326741|1:w?w|2:0}w!==0&&(d=!0,TS(m,w))}else w=Yt,w=wh(m,m===ke?w:0,m.cancelPendingCommit!==null||m.timeoutHandle!==-1),(w&3)===0||Ml(m,w)||(d=!0,TS(m,w));m=m.next}while(d);Zg=!1}}function vD(){SS()}function SS(){xd=Yg=!1;var a=0;Oa!==0&&AD()&&(a=Oa);for(var r=De(),d=null,m=gd;m!==null;){var y=m.next,w=CS(m,r);w===0?(m.next=null,d===null?gd=y:d.next=y,y===null&&(qr=d)):(d=m,(a!==0||(w&3)!==0)&&(xd=!0)),m=y}hn!==0&&hn!==5||xu(a),Oa!==0&&(Oa=0)}function CS(a,r){for(var d=a.suspendedLanes,m=a.pingedLanes,y=a.expirationTimes,w=a.pendingLanes&-62914561;0<w;){var I=31-ps(w),A=1<<I,V=y[I];V===-1?((A&d)===0||(A&m)!==0)&&(y[I]=jR(A,r)):V<=r&&(a.expiredLanes|=A),w&=~A}if(r=ke,d=Yt,d=wh(a,a===r?d:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),m=a.callbackNode,d===0||a===r&&(xe===2||xe===9)||a.cancelPendingCommit!==null)return m!==null&&m!==null&&Ns(m),a.callbackNode=null,a.callbackPriority=0;if((d&3)===0||Ml(a,d)){if(r=d&-d,r===a.callbackPriority)return r;switch(m!==null&&Ns(m),dm(d)){case 2:case 8:d=Qs;break;case 32:d=fs;break;case 268435456:d=dr;break;default:d=fs}return m=$S.bind(null,a),d=Ue(d,m),a.callbackPriority=r,a.callbackNode=d,r}return m!==null&&m!==null&&Ns(m),a.callbackPriority=2,a.callbackNode=null,2}function $S(a,r){if(hn!==0&&hn!==5)return a.callbackNode=null,a.callbackPriority=0,null;var d=a.callbackNode;if(md()&&a.callbackNode!==d)return null;var m=Yt;return m=wh(a,a===ke?m:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),m===0?null:(aS(a,m,r),CS(a,De()),a.callbackNode!=null&&a.callbackNode===d?$S.bind(null,a):null)}function TS(a,r){if(md())return null;aS(a,r,!0)}function wD(){OD(function(){(fe&6)!==0?Ue(Zs,vD):SS()})}function Qg(){if(Oa===0){var a=Ar;a===0&&(a=bh,bh<<=1,(bh&261888)===0&&(bh=256)),Oa=a}return Oa}function kS(a){return a==null||typeof a=="symbol"||typeof a=="boolean"?null:typeof a=="function"?a:Th(""+a)}function IS(a,r){var d=r.ownerDocument.createElement("input");return d.name=r.name,d.value=r.value,a.id&&d.setAttribute("form",a.id),r.parentNode.insertBefore(d,r),a=new FormData(a),d.parentNode.removeChild(d),a}function SD(a,r,d,m,y){if(r==="submit"&&d&&d.stateNode===y){var w=kS((y[Qn]||null).action),I=m.submitter;I&&(r=(r=I[Qn]||null)?kS(r.formAction):I.getAttribute("formAction"),r!==null&&(w=r,I=null));var A=new Eh("action","action",null,m,y);a.push({event:A,listeners:[{instance:null,listener:function(){if(m.defaultPrevented){if(Oa!==0){var V=I?IS(y,I):new FormData(y);bg(d,{pending:!0,data:V,method:y.method,action:w},null,V)}}else typeof w=="function"&&(A.preventDefault(),V=I?IS(y,I):new FormData(y),bg(d,{pending:!0,data:V,method:y.method,action:w},w,V))},currentTarget:y}]})}}for(var Jg=0;Jg<Fm.length;Jg++){var tx=Fm[Jg],CD=tx.toLowerCase(),$D=tx[0].toUpperCase()+tx.slice(1);Js(CD,"on"+$D)}Js(ov,"onAnimationEnd"),Js(av,"onAnimationIteration"),Js(iv,"onAnimationStart"),Js("dblclick","onDoubleClick"),Js("focusin","onFocus"),Js("focusout","onBlur"),Js(UA,"onTransitionRun"),Js(VA,"onTransitionStart"),Js(PA,"onTransitionCancel"),Js(rv,"onTransitionEnd"),xr("onMouseEnter",["mouseout","mouseover"]),xr("onMouseLeave",["mouseout","mouseover"]),xr("onPointerEnter",["pointerout","pointerover"]),xr("onPointerLeave",["pointerout","pointerover"]),pi("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),pi("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),pi("onBeforeInput",["compositionend","keypress","textInput","paste"]),pi("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),pi("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),pi("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var bu="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),TD=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(bu));function NS(a,r){r=(r&4)!==0;for(var d=0;d<a.length;d++){var m=a[d],y=m.event;m=m.listeners;t:{var w=void 0;if(r)for(var I=m.length-1;0<=I;I--){var A=m[I],V=A.instance,at=A.currentTarget;if(A=A.listener,V!==w&&y.isPropagationStopped())break t;w=A,y.currentTarget=at;try{w(y)}catch(pt){Dh(pt)}y.currentTarget=null,w=V}else for(I=0;I<m.length;I++){if(A=m[I],V=A.instance,at=A.currentTarget,A=A.listener,V!==w&&y.isPropagationStopped())break t;w=A,y.currentTarget=at;try{w(y)}catch(pt){Dh(pt)}y.currentTarget=null,w=V}}}}function Kt(a,r){var d=r[fm];d===void 0&&(d=r[fm]=new Set);var m=a+"__bubble";d.has(m)||(ES(r,a,2,!1),d.add(m))}function ex(a,r,d){var m=0;r&&(m|=4),ES(d,a,m,r)}var bd="_reactListening"+Math.random().toString(36).slice(2);function nx(a){if(!a[bd]){a[bd]=!0,S1.forEach(function(d){d!=="selectionchange"&&(TD.has(d)||ex(d,!1,a),ex(d,!0,a))});var r=a.nodeType===9?a:a.ownerDocument;r===null||r[bd]||(r[bd]=!0,ex("selectionchange",!1,r))}}function ES(a,r,d,m){switch(oC(r)){case 2:var y=JD;break;case 8:y=tO;break;default:y=xx}d=y.bind(null,r,d,a),y=void 0,!Sm||r!=="touchstart"&&r!=="touchmove"&&r!=="wheel"||(y=!0),m?y!==void 0?a.addEventListener(r,d,{capture:!0,passive:y}):a.addEventListener(r,d,!0):y!==void 0?a.addEventListener(r,d,{passive:y}):a.addEventListener(r,d,!1)}function sx(a,r,d,m,y){var w=m;if((r&1)===0&&(r&2)===0&&m!==null)t:for(;;){if(m===null)return;var I=m.tag;if(I===3||I===4){var A=m.stateNode.containerInfo;if(A===y)break;if(I===4)for(I=m.return;I!==null;){var V=I.tag;if((V===3||V===4)&&I.stateNode.containerInfo===y)return;I=I.return}for(;A!==null;){if(I=pr(A),I===null)return;if(V=I.tag,V===5||V===6||V===26||V===27){m=w=I;continue t}A=A.parentNode}}m=m.return}_1(function(){var at=w,pt=vm(d),xt=[];t:{var rt=lv.get(a);if(rt!==void 0){var ct=Eh,kt=a;switch(a){case"keypress":if(Ih(d)===0)break t;case"keydown":case"keyup":ct=bA;break;case"focusin":kt="focus",ct=km;break;case"focusout":kt="blur",ct=km;break;case"beforeblur":case"afterblur":ct=km;break;case"click":if(d.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ct=z1;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ct=iA;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ct=wA;break;case ov:case av:case iv:ct=uA;break;case rv:ct=CA;break;case"scroll":case"scrollend":ct=oA;break;case"wheel":ct=TA;break;case"copy":case"cut":case"paste":ct=hA;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ct=B1;break;case"toggle":case"beforetoggle":ct=IA}var _t=(r&4)!==0,Ce=!_t&&(a==="scroll"||a==="scrollend"),et=_t?rt!==null?rt+"Capture":null:rt;_t=[];for(var j=at,ot;j!==null;){var mt=j;if(ot=mt.stateNode,mt=mt.tag,mt!==5&&mt!==26&&mt!==27||ot===null||et===null||(mt=Ul(j,et),mt!=null&&_t.push(yu(j,mt,ot))),Ce)break;j=j.return}0<_t.length&&(rt=new ct(rt,kt,null,d,pt),xt.push({event:rt,listeners:_t}))}}if((r&7)===0){t:{if(rt=a==="mouseover"||a==="pointerover",ct=a==="mouseout"||a==="pointerout",rt&&d!==ym&&(kt=d.relatedTarget||d.fromElement)&&(pr(kt)||kt[fr]))break t;if((ct||rt)&&(rt=pt.window===pt?pt:(rt=pt.ownerDocument)?rt.defaultView||rt.parentWindow:window,ct?(kt=d.relatedTarget||d.toElement,ct=at,kt=kt?pr(kt):null,kt!==null&&(Ce=i(kt),_t=kt.tag,kt!==Ce||_t!==5&&_t!==27&&_t!==6)&&(kt=null)):(ct=null,kt=at),ct!==kt)){if(_t=z1,mt="onMouseLeave",et="onMouseEnter",j="mouse",(a==="pointerout"||a==="pointerover")&&(_t=B1,mt="onPointerLeave",et="onPointerEnter",j="pointer"),Ce=ct==null?rt:Bl(ct),ot=kt==null?rt:Bl(kt),rt=new _t(mt,j+"leave",ct,d,pt),rt.target=Ce,rt.relatedTarget=ot,mt=null,pr(pt)===at&&(_t=new _t(et,j+"enter",kt,d,pt),_t.target=ot,_t.relatedTarget=Ce,mt=_t),Ce=mt,ct&&kt)e:{for(_t=kD,et=ct,j=kt,ot=0,mt=et;mt;mt=_t(mt))ot++;mt=0;for(var Dt=j;Dt;Dt=_t(Dt))mt++;for(;0<ot-mt;)et=_t(et),ot--;for(;0<mt-ot;)j=_t(j),mt--;for(;ot--;){if(et===j||j!==null&&et===j.alternate){_t=et;break e}et=_t(et),j=_t(j)}_t=null}else _t=null;ct!==null&&RS(xt,rt,ct,_t,!1),kt!==null&&Ce!==null&&RS(xt,Ce,kt,_t,!0)}}t:{if(rt=at?Bl(at):window,ct=rt.nodeName&&rt.nodeName.toLowerCase(),ct==="select"||ct==="input"&&rt.type==="file")var ie=j1;else if(H1(rt))if(X1)ie=zA;else{ie=FA;var Et=_A}else ct=rt.nodeName,!ct||ct.toLowerCase()!=="input"||rt.type!=="checkbox"&&rt.type!=="radio"?at&&bm(at.elementType)&&(ie=j1):ie=MA;if(ie&&(ie=ie(a,at))){q1(xt,ie,d,pt);break t}Et&&Et(a,rt,at),a==="focusout"&&at&&rt.type==="number"&&at.memoizedProps.value!=null&&xm(rt,"number",rt.value)}switch(Et=at?Bl(at):window,a){case"focusin":(H1(Et)||Et.contentEditable==="true")&&(Cr=Et,Dm=at,Xl=null);break;case"focusout":Xl=Dm=Cr=null;break;case"mousedown":Om=!0;break;case"contextmenu":case"mouseup":case"dragend":Om=!1,nv(xt,d,pt);break;case"selectionchange":if(BA)break;case"keydown":case"keyup":nv(xt,d,pt)}var Gt;if(Nm)t:{switch(a){case"compositionstart":var Zt="onCompositionStart";break t;case"compositionend":Zt="onCompositionEnd";break t;case"compositionupdate":Zt="onCompositionUpdate";break t}Zt=void 0}else Sr?G1(a,d)&&(Zt="onCompositionEnd"):a==="keydown"&&d.keyCode===229&&(Zt="onCompositionStart");Zt&&(U1&&d.locale!=="ko"&&(Sr||Zt!=="onCompositionStart"?Zt==="onCompositionEnd"&&Sr&&(Gt=F1()):(xa=pt,Cm="value"in xa?xa.value:xa.textContent,Sr=!0)),Et=yd(at,Zt),0<Et.length&&(Zt=new L1(Zt,a,null,d,pt),xt.push({event:Zt,listeners:Et}),Gt?Zt.data=Gt:(Gt=W1(d),Gt!==null&&(Zt.data=Gt)))),(Gt=EA?RA(a,d):AA(a,d))&&(Zt=yd(at,"onBeforeInput"),0<Zt.length&&(Et=new L1("onBeforeInput","beforeinput",null,d,pt),xt.push({event:Et,listeners:Zt}),Et.data=Gt)),SD(xt,a,at,d,pt)}NS(xt,r)})}function yu(a,r,d){return{instance:a,listener:r,currentTarget:d}}function yd(a,r){for(var d=r+"Capture",m=[];a!==null;){var y=a,w=y.stateNode;if(y=y.tag,y!==5&&y!==26&&y!==27||w===null||(y=Ul(a,d),y!=null&&m.unshift(yu(a,y,w)),y=Ul(a,r),y!=null&&m.push(yu(a,y,w))),a.tag===3)return m;a=a.return}return[]}function kD(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5&&a.tag!==27);return a||null}function RS(a,r,d,m,y){for(var w=r._reactName,I=[];d!==null&&d!==m;){var A=d,V=A.alternate,at=A.stateNode;if(A=A.tag,V!==null&&V===m)break;A!==5&&A!==26&&A!==27||at===null||(V=at,y?(at=Ul(d,w),at!=null&&I.unshift(yu(d,at,V))):y||(at=Ul(d,w),at!=null&&I.push(yu(d,at,V)))),d=d.return}I.length!==0&&a.push({event:r,listeners:I})}var ID=/\r\n?/g,ND=/\u0000|\uFFFD/g;function AS(a){return(typeof a=="string"?a:""+a).replace(ID,`
`).replace(ND,"")}function DS(a,r){return r=AS(r),AS(a)===r}function Se(a,r,d,m,y,w){switch(d){case"children":typeof m=="string"?r==="body"||r==="textarea"&&m===""||yr(a,m):(typeof m=="number"||typeof m=="bigint")&&r!=="body"&&yr(a,""+m);break;case"className":Ch(a,"class",m);break;case"tabIndex":Ch(a,"tabindex",m);break;case"dir":case"role":case"viewBox":case"width":case"height":Ch(a,d,m);break;case"style":D1(a,m,w);break;case"data":if(r!=="object"){Ch(a,"data",m);break}case"src":case"href":if(m===""&&(r!=="a"||d!=="href")){a.removeAttribute(d);break}if(m==null||typeof m=="function"||typeof m=="symbol"||typeof m=="boolean"){a.removeAttribute(d);break}m=Th(""+m),a.setAttribute(d,m);break;case"action":case"formAction":if(typeof m=="function"){a.setAttribute(d,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof w=="function"&&(d==="formAction"?(r!=="input"&&Se(a,r,"name",y.name,y,null),Se(a,r,"formEncType",y.formEncType,y,null),Se(a,r,"formMethod",y.formMethod,y,null),Se(a,r,"formTarget",y.formTarget,y,null)):(Se(a,r,"encType",y.encType,y,null),Se(a,r,"method",y.method,y,null),Se(a,r,"target",y.target,y,null)));if(m==null||typeof m=="symbol"||typeof m=="boolean"){a.removeAttribute(d);break}m=Th(""+m),a.setAttribute(d,m);break;case"onClick":m!=null&&(a.onclick=Vo);break;case"onScroll":m!=null&&Kt("scroll",a);break;case"onScrollEnd":m!=null&&Kt("scrollend",a);break;case"dangerouslySetInnerHTML":if(m!=null){if(typeof m!="object"||!("__html"in m))throw Error(s(61));if(d=m.__html,d!=null){if(y.children!=null)throw Error(s(60));a.innerHTML=d}}break;case"multiple":a.multiple=m&&typeof m!="function"&&typeof m!="symbol";break;case"muted":a.muted=m&&typeof m!="function"&&typeof m!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(m==null||typeof m=="function"||typeof m=="boolean"||typeof m=="symbol"){a.removeAttribute("xlink:href");break}d=Th(""+m),a.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",d);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":m!=null&&typeof m!="function"&&typeof m!="symbol"?a.setAttribute(d,""+m):a.removeAttribute(d);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":m&&typeof m!="function"&&typeof m!="symbol"?a.setAttribute(d,""):a.removeAttribute(d);break;case"capture":case"download":m===!0?a.setAttribute(d,""):m!==!1&&m!=null&&typeof m!="function"&&typeof m!="symbol"?a.setAttribute(d,m):a.removeAttribute(d);break;case"cols":case"rows":case"size":case"span":m!=null&&typeof m!="function"&&typeof m!="symbol"&&!isNaN(m)&&1<=m?a.setAttribute(d,m):a.removeAttribute(d);break;case"rowSpan":case"start":m==null||typeof m=="function"||typeof m=="symbol"||isNaN(m)?a.removeAttribute(d):a.setAttribute(d,m);break;case"popover":Kt("beforetoggle",a),Kt("toggle",a),Sh(a,"popover",m);break;case"xlinkActuate":Uo(a,"http://www.w3.org/1999/xlink","xlink:actuate",m);break;case"xlinkArcrole":Uo(a,"http://www.w3.org/1999/xlink","xlink:arcrole",m);break;case"xlinkRole":Uo(a,"http://www.w3.org/1999/xlink","xlink:role",m);break;case"xlinkShow":Uo(a,"http://www.w3.org/1999/xlink","xlink:show",m);break;case"xlinkTitle":Uo(a,"http://www.w3.org/1999/xlink","xlink:title",m);break;case"xlinkType":Uo(a,"http://www.w3.org/1999/xlink","xlink:type",m);break;case"xmlBase":Uo(a,"http://www.w3.org/XML/1998/namespace","xml:base",m);break;case"xmlLang":Uo(a,"http://www.w3.org/XML/1998/namespace","xml:lang",m);break;case"xmlSpace":Uo(a,"http://www.w3.org/XML/1998/namespace","xml:space",m);break;case"is":Sh(a,"is",m);break;case"innerText":case"textContent":break;default:(!(2<d.length)||d[0]!=="o"&&d[0]!=="O"||d[1]!=="n"&&d[1]!=="N")&&(d=nA.get(d)||d,Sh(a,d,m))}}function ox(a,r,d,m,y,w){switch(d){case"style":D1(a,m,w);break;case"dangerouslySetInnerHTML":if(m!=null){if(typeof m!="object"||!("__html"in m))throw Error(s(61));if(d=m.__html,d!=null){if(y.children!=null)throw Error(s(60));a.innerHTML=d}}break;case"children":typeof m=="string"?yr(a,m):(typeof m=="number"||typeof m=="bigint")&&yr(a,""+m);break;case"onScroll":m!=null&&Kt("scroll",a);break;case"onScrollEnd":m!=null&&Kt("scrollend",a);break;case"onClick":m!=null&&(a.onclick=Vo);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!C1.hasOwnProperty(d))t:{if(d[0]==="o"&&d[1]==="n"&&(y=d.endsWith("Capture"),r=d.slice(2,y?d.length-7:void 0),w=a[Qn]||null,w=w!=null?w[d]:null,typeof w=="function"&&a.removeEventListener(r,w,y),typeof m=="function")){typeof w!="function"&&w!==null&&(d in a?a[d]=null:a.hasAttribute(d)&&a.removeAttribute(d)),a.addEventListener(r,m,y);break t}d in a?a[d]=m:m===!0?a.setAttribute(d,""):Sh(a,d,m)}}}function Nn(a,r,d){switch(r){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Kt("error",a),Kt("load",a);var m=!1,y=!1,w;for(w in d)if(d.hasOwnProperty(w)){var I=d[w];if(I!=null)switch(w){case"src":m=!0;break;case"srcSet":y=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,r));default:Se(a,r,w,I,d,null)}}y&&Se(a,r,"srcSet",d.srcSet,d,null),m&&Se(a,r,"src",d.src,d,null);return;case"input":Kt("invalid",a);var A=w=I=y=null,V=null,at=null;for(m in d)if(d.hasOwnProperty(m)){var pt=d[m];if(pt!=null)switch(m){case"name":y=pt;break;case"type":I=pt;break;case"checked":V=pt;break;case"defaultChecked":at=pt;break;case"value":w=pt;break;case"defaultValue":A=pt;break;case"children":case"dangerouslySetInnerHTML":if(pt!=null)throw Error(s(137,r));break;default:Se(a,r,m,pt,d,null)}}N1(a,w,A,V,at,I,y,!1);return;case"select":Kt("invalid",a),m=I=w=null;for(y in d)if(d.hasOwnProperty(y)&&(A=d[y],A!=null))switch(y){case"value":w=A;break;case"defaultValue":I=A;break;case"multiple":m=A;default:Se(a,r,y,A,d,null)}r=w,d=I,a.multiple=!!m,r!=null?br(a,!!m,r,!1):d!=null&&br(a,!!m,d,!0);return;case"textarea":Kt("invalid",a),w=y=m=null;for(I in d)if(d.hasOwnProperty(I)&&(A=d[I],A!=null))switch(I){case"value":m=A;break;case"defaultValue":y=A;break;case"children":w=A;break;case"dangerouslySetInnerHTML":if(A!=null)throw Error(s(91));break;default:Se(a,r,I,A,d,null)}R1(a,m,y,w);return;case"option":for(V in d)d.hasOwnProperty(V)&&(m=d[V],m!=null)&&(V==="selected"?a.selected=m&&typeof m!="function"&&typeof m!="symbol":Se(a,r,V,m,d,null));return;case"dialog":Kt("beforetoggle",a),Kt("toggle",a),Kt("cancel",a),Kt("close",a);break;case"iframe":case"object":Kt("load",a);break;case"video":case"audio":for(m=0;m<bu.length;m++)Kt(bu[m],a);break;case"image":Kt("error",a),Kt("load",a);break;case"details":Kt("toggle",a);break;case"embed":case"source":case"link":Kt("error",a),Kt("load",a);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(at in d)if(d.hasOwnProperty(at)&&(m=d[at],m!=null))switch(at){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,r));default:Se(a,r,at,m,d,null)}return;default:if(bm(r)){for(pt in d)d.hasOwnProperty(pt)&&(m=d[pt],m!==void 0&&ox(a,r,pt,m,d,void 0));return}}for(A in d)d.hasOwnProperty(A)&&(m=d[A],m!=null&&Se(a,r,A,m,d,null))}function ED(a,r,d,m){switch(r){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var y=null,w=null,I=null,A=null,V=null,at=null,pt=null;for(ct in d){var xt=d[ct];if(d.hasOwnProperty(ct)&&xt!=null)switch(ct){case"checked":break;case"value":break;case"defaultValue":V=xt;default:m.hasOwnProperty(ct)||Se(a,r,ct,null,m,xt)}}for(var rt in m){var ct=m[rt];if(xt=d[rt],m.hasOwnProperty(rt)&&(ct!=null||xt!=null))switch(rt){case"type":w=ct;break;case"name":y=ct;break;case"checked":at=ct;break;case"defaultChecked":pt=ct;break;case"value":I=ct;break;case"defaultValue":A=ct;break;case"children":case"dangerouslySetInnerHTML":if(ct!=null)throw Error(s(137,r));break;default:ct!==xt&&Se(a,r,rt,ct,m,xt)}}gm(a,I,A,V,at,pt,w,y);return;case"select":ct=I=A=rt=null;for(w in d)if(V=d[w],d.hasOwnProperty(w)&&V!=null)switch(w){case"value":break;case"multiple":ct=V;default:m.hasOwnProperty(w)||Se(a,r,w,null,m,V)}for(y in m)if(w=m[y],V=d[y],m.hasOwnProperty(y)&&(w!=null||V!=null))switch(y){case"value":rt=w;break;case"defaultValue":A=w;break;case"multiple":I=w;default:w!==V&&Se(a,r,y,w,m,V)}r=A,d=I,m=ct,rt!=null?br(a,!!d,rt,!1):!!m!=!!d&&(r!=null?br(a,!!d,r,!0):br(a,!!d,d?[]:"",!1));return;case"textarea":ct=rt=null;for(A in d)if(y=d[A],d.hasOwnProperty(A)&&y!=null&&!m.hasOwnProperty(A))switch(A){case"value":break;case"children":break;default:Se(a,r,A,null,m,y)}for(I in m)if(y=m[I],w=d[I],m.hasOwnProperty(I)&&(y!=null||w!=null))switch(I){case"value":rt=y;break;case"defaultValue":ct=y;break;case"children":break;case"dangerouslySetInnerHTML":if(y!=null)throw Error(s(91));break;default:y!==w&&Se(a,r,I,y,m,w)}E1(a,rt,ct);return;case"option":for(var kt in d)rt=d[kt],d.hasOwnProperty(kt)&&rt!=null&&!m.hasOwnProperty(kt)&&(kt==="selected"?a.selected=!1:Se(a,r,kt,null,m,rt));for(V in m)rt=m[V],ct=d[V],m.hasOwnProperty(V)&&rt!==ct&&(rt!=null||ct!=null)&&(V==="selected"?a.selected=rt&&typeof rt!="function"&&typeof rt!="symbol":Se(a,r,V,rt,m,ct));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var _t in d)rt=d[_t],d.hasOwnProperty(_t)&&rt!=null&&!m.hasOwnProperty(_t)&&Se(a,r,_t,null,m,rt);for(at in m)if(rt=m[at],ct=d[at],m.hasOwnProperty(at)&&rt!==ct&&(rt!=null||ct!=null))switch(at){case"children":case"dangerouslySetInnerHTML":if(rt!=null)throw Error(s(137,r));break;default:Se(a,r,at,rt,m,ct)}return;default:if(bm(r)){for(var Ce in d)rt=d[Ce],d.hasOwnProperty(Ce)&&rt!==void 0&&!m.hasOwnProperty(Ce)&&ox(a,r,Ce,void 0,m,rt);for(pt in m)rt=m[pt],ct=d[pt],!m.hasOwnProperty(pt)||rt===ct||rt===void 0&&ct===void 0||ox(a,r,pt,rt,m,ct);return}}for(var et in d)rt=d[et],d.hasOwnProperty(et)&&rt!=null&&!m.hasOwnProperty(et)&&Se(a,r,et,null,m,rt);for(xt in m)rt=m[xt],ct=d[xt],!m.hasOwnProperty(xt)||rt===ct||rt==null&&ct==null||Se(a,r,xt,rt,m,ct)}function OS(a){switch(a){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function RD(){if(typeof performance.getEntriesByType=="function"){for(var a=0,r=0,d=performance.getEntriesByType("resource"),m=0;m<d.length;m++){var y=d[m],w=y.transferSize,I=y.initiatorType,A=y.duration;if(w&&A&&OS(I)){for(I=0,A=y.responseEnd,m+=1;m<d.length;m++){var V=d[m],at=V.startTime;if(at>A)break;var pt=V.transferSize,xt=V.initiatorType;pt&&OS(xt)&&(V=V.responseEnd,I+=pt*(V<A?1:(A-at)/(V-at)))}if(--m,r+=8*(w+I)/(y.duration/1e3),a++,10<a)break}}if(0<a)return r/a/1e6}return navigator.connection&&(a=navigator.connection.downlink,typeof a=="number")?a:5}var ax=null,ix=null;function vd(a){return a.nodeType===9?a:a.ownerDocument}function _S(a){switch(a){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function FS(a,r){if(a===0)switch(r){case"svg":return 1;case"math":return 2;default:return 0}return a===1&&r==="foreignObject"?0:a}function rx(a,r){return a==="textarea"||a==="noscript"||typeof r.children=="string"||typeof r.children=="number"||typeof r.children=="bigint"||typeof r.dangerouslySetInnerHTML=="object"&&r.dangerouslySetInnerHTML!==null&&r.dangerouslySetInnerHTML.__html!=null}var lx=null;function AD(){var a=window.event;return a&&a.type==="popstate"?a===lx?!1:(lx=a,!0):(lx=null,!1)}var MS=typeof setTimeout=="function"?setTimeout:void 0,DD=typeof clearTimeout=="function"?clearTimeout:void 0,zS=typeof Promise=="function"?Promise:void 0,OD=typeof queueMicrotask=="function"?queueMicrotask:typeof zS<"u"?function(a){return zS.resolve(null).then(a).catch(_D)}:MS;function _D(a){setTimeout(function(){throw a})}function _a(a){return a==="head"}function LS(a,r){var d=r,m=0;do{var y=d.nextSibling;if(a.removeChild(d),y&&y.nodeType===8)if(d=y.data,d==="/$"||d==="/&"){if(m===0){a.removeChild(y),Yr(r);return}m--}else if(d==="$"||d==="$?"||d==="$~"||d==="$!"||d==="&")m++;else if(d==="html")vu(a.ownerDocument.documentElement);else if(d==="head"){d=a.ownerDocument.head,vu(d);for(var w=d.firstChild;w;){var I=w.nextSibling,A=w.nodeName;w[Ll]||A==="SCRIPT"||A==="STYLE"||A==="LINK"&&w.rel.toLowerCase()==="stylesheet"||d.removeChild(w),w=I}}else d==="body"&&vu(a.ownerDocument.body);d=y}while(d);Yr(r)}function BS(a,r){var d=a;a=0;do{var m=d.nextSibling;if(d.nodeType===1?r?(d._stashedDisplay=d.style.display,d.style.display="none"):(d.style.display=d._stashedDisplay||"",d.getAttribute("style")===""&&d.removeAttribute("style")):d.nodeType===3&&(r?(d._stashedText=d.nodeValue,d.nodeValue=""):d.nodeValue=d._stashedText||""),m&&m.nodeType===8)if(d=m.data,d==="/$"){if(a===0)break;a--}else d!=="$"&&d!=="$?"&&d!=="$~"&&d!=="$!"||a++;d=m}while(d)}function ux(a){var r=a.firstChild;for(r&&r.nodeType===10&&(r=r.nextSibling);r;){var d=r;switch(r=r.nextSibling,d.nodeName){case"HTML":case"HEAD":case"BODY":ux(d),pm(d);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(d.rel.toLowerCase()==="stylesheet")continue}a.removeChild(d)}}function FD(a,r,d,m){for(;a.nodeType===1;){var y=d;if(a.nodeName.toLowerCase()!==r.toLowerCase()){if(!m&&(a.nodeName!=="INPUT"||a.type!=="hidden"))break}else if(m){if(!a[Ll])switch(r){case"meta":if(!a.hasAttribute("itemprop"))break;return a;case"link":if(w=a.getAttribute("rel"),w==="stylesheet"&&a.hasAttribute("data-precedence"))break;if(w!==y.rel||a.getAttribute("href")!==(y.href==null||y.href===""?null:y.href)||a.getAttribute("crossorigin")!==(y.crossOrigin==null?null:y.crossOrigin)||a.getAttribute("title")!==(y.title==null?null:y.title))break;return a;case"style":if(a.hasAttribute("data-precedence"))break;return a;case"script":if(w=a.getAttribute("src"),(w!==(y.src==null?null:y.src)||a.getAttribute("type")!==(y.type==null?null:y.type)||a.getAttribute("crossorigin")!==(y.crossOrigin==null?null:y.crossOrigin))&&w&&a.hasAttribute("async")&&!a.hasAttribute("itemprop"))break;return a;default:return a}}else if(r==="input"&&a.type==="hidden"){var w=y.name==null?null:""+y.name;if(y.type==="hidden"&&a.getAttribute("name")===w)return a}else return a;if(a=zs(a.nextSibling),a===null)break}return null}function MD(a,r,d){if(r==="")return null;for(;a.nodeType!==3;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!d||(a=zs(a.nextSibling),a===null))return null;return a}function US(a,r){for(;a.nodeType!==8;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!r||(a=zs(a.nextSibling),a===null))return null;return a}function cx(a){return a.data==="$?"||a.data==="$~"}function hx(a){return a.data==="$!"||a.data==="$?"&&a.ownerDocument.readyState!=="loading"}function zD(a,r){var d=a.ownerDocument;if(a.data==="$~")a._reactRetry=r;else if(a.data!=="$?"||d.readyState!=="loading")r();else{var m=function(){r(),d.removeEventListener("DOMContentLoaded",m)};d.addEventListener("DOMContentLoaded",m),a._reactRetry=m}}function zs(a){for(;a!=null;a=a.nextSibling){var r=a.nodeType;if(r===1||r===3)break;if(r===8){if(r=a.data,r==="$"||r==="$!"||r==="$?"||r==="$~"||r==="&"||r==="F!"||r==="F")break;if(r==="/$"||r==="/&")return null}}return a}var dx=null;function VS(a){a=a.nextSibling;for(var r=0;a;){if(a.nodeType===8){var d=a.data;if(d==="/$"||d==="/&"){if(r===0)return zs(a.nextSibling);r--}else d!=="$"&&d!=="$!"&&d!=="$?"&&d!=="$~"&&d!=="&"||r++}a=a.nextSibling}return null}function PS(a){a=a.previousSibling;for(var r=0;a;){if(a.nodeType===8){var d=a.data;if(d==="$"||d==="$!"||d==="$?"||d==="$~"||d==="&"){if(r===0)return a;r--}else d!=="/$"&&d!=="/&"||r++}a=a.previousSibling}return null}function GS(a,r,d){switch(r=vd(d),a){case"html":if(a=r.documentElement,!a)throw Error(s(452));return a;case"head":if(a=r.head,!a)throw Error(s(453));return a;case"body":if(a=r.body,!a)throw Error(s(454));return a;default:throw Error(s(451))}}function vu(a){for(var r=a.attributes;r.length;)a.removeAttributeNode(r[0]);pm(a)}var Ls=new Map,WS=new Set;function wd(a){return typeof a.getRootNode=="function"?a.getRootNode():a.nodeType===9?a:a.ownerDocument}var sa=P.d;P.d={f:LD,r:BD,D:UD,C:VD,L:PD,m:GD,X:HD,S:WD,M:qD};function LD(){var a=sa.f(),r=dd();return a||r}function BD(a){var r=mr(a);r!==null&&r.tag===5&&r.type==="form"?rw(r):sa.r(a)}var jr=typeof document>"u"?null:document;function HS(a,r,d){var m=jr;if(m&&typeof r=="string"&&r){var y=Rs(r);y='link[rel="'+a+'"][href="'+y+'"]',typeof d=="string"&&(y+='[crossorigin="'+d+'"]'),WS.has(y)||(WS.add(y),a={rel:a,crossOrigin:d,href:r},m.querySelector(y)===null&&(r=m.createElement("link"),Nn(r,"link",a),xn(r),m.head.appendChild(r)))}}function UD(a){sa.D(a),HS("dns-prefetch",a,null)}function VD(a,r){sa.C(a,r),HS("preconnect",a,r)}function PD(a,r,d){sa.L(a,r,d);var m=jr;if(m&&a&&r){var y='link[rel="preload"][as="'+Rs(r)+'"]';r==="image"&&d&&d.imageSrcSet?(y+='[imagesrcset="'+Rs(d.imageSrcSet)+'"]',typeof d.imageSizes=="string"&&(y+='[imagesizes="'+Rs(d.imageSizes)+'"]')):y+='[href="'+Rs(a)+'"]';var w=y;switch(r){case"style":w=Xr(a);break;case"script":w=Kr(a)}Ls.has(w)||(a=p({rel:"preload",href:r==="image"&&d&&d.imageSrcSet?void 0:a,as:r},d),Ls.set(w,a),m.querySelector(y)!==null||r==="style"&&m.querySelector(wu(w))||r==="script"&&m.querySelector(Su(w))||(r=m.createElement("link"),Nn(r,"link",a),xn(r),m.head.appendChild(r)))}}function GD(a,r){sa.m(a,r);var d=jr;if(d&&a){var m=r&&typeof r.as=="string"?r.as:"script",y='link[rel="modulepreload"][as="'+Rs(m)+'"][href="'+Rs(a)+'"]',w=y;switch(m){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":w=Kr(a)}if(!Ls.has(w)&&(a=p({rel:"modulepreload",href:a},r),Ls.set(w,a),d.querySelector(y)===null)){switch(m){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(d.querySelector(Su(w)))return}m=d.createElement("link"),Nn(m,"link",a),xn(m),d.head.appendChild(m)}}}function WD(a,r,d){sa.S(a,r,d);var m=jr;if(m&&a){var y=gr(m).hoistableStyles,w=Xr(a);r=r||"default";var I=y.get(w);if(!I){var A={loading:0,preload:null};if(I=m.querySelector(wu(w)))A.loading=5;else{a=p({rel:"stylesheet",href:a,"data-precedence":r},d),(d=Ls.get(w))&&fx(a,d);var V=I=m.createElement("link");xn(V),Nn(V,"link",a),V._p=new Promise(function(at,pt){V.onload=at,V.onerror=pt}),V.addEventListener("load",function(){A.loading|=1}),V.addEventListener("error",function(){A.loading|=2}),A.loading|=4,Sd(I,r,m)}I={type:"stylesheet",instance:I,count:1,state:A},y.set(w,I)}}}function HD(a,r){sa.X(a,r);var d=jr;if(d&&a){var m=gr(d).hoistableScripts,y=Kr(a),w=m.get(y);w||(w=d.querySelector(Su(y)),w||(a=p({src:a,async:!0},r),(r=Ls.get(y))&&px(a,r),w=d.createElement("script"),xn(w),Nn(w,"link",a),d.head.appendChild(w)),w={type:"script",instance:w,count:1,state:null},m.set(y,w))}}function qD(a,r){sa.M(a,r);var d=jr;if(d&&a){var m=gr(d).hoistableScripts,y=Kr(a),w=m.get(y);w||(w=d.querySelector(Su(y)),w||(a=p({src:a,async:!0,type:"module"},r),(r=Ls.get(y))&&px(a,r),w=d.createElement("script"),xn(w),Nn(w,"link",a),d.head.appendChild(w)),w={type:"script",instance:w,count:1,state:null},m.set(y,w))}}function qS(a,r,d,m){var y=(y=gt.current)?wd(y):null;if(!y)throw Error(s(446));switch(a){case"meta":case"title":return null;case"style":return typeof d.precedence=="string"&&typeof d.href=="string"?(r=Xr(d.href),d=gr(y).hoistableStyles,m=d.get(r),m||(m={type:"style",instance:null,count:0,state:null},d.set(r,m)),m):{type:"void",instance:null,count:0,state:null};case"link":if(d.rel==="stylesheet"&&typeof d.href=="string"&&typeof d.precedence=="string"){a=Xr(d.href);var w=gr(y).hoistableStyles,I=w.get(a);if(I||(y=y.ownerDocument||y,I={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},w.set(a,I),(w=y.querySelector(wu(a)))&&!w._p&&(I.instance=w,I.state.loading=5),Ls.has(a)||(d={rel:"preload",as:"style",href:d.href,crossOrigin:d.crossOrigin,integrity:d.integrity,media:d.media,hrefLang:d.hrefLang,referrerPolicy:d.referrerPolicy},Ls.set(a,d),w||jD(y,a,d,I.state))),r&&m===null)throw Error(s(528,""));return I}if(r&&m!==null)throw Error(s(529,""));return null;case"script":return r=d.async,d=d.src,typeof d=="string"&&r&&typeof r!="function"&&typeof r!="symbol"?(r=Kr(d),d=gr(y).hoistableScripts,m=d.get(r),m||(m={type:"script",instance:null,count:0,state:null},d.set(r,m)),m):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,a))}}function Xr(a){return'href="'+Rs(a)+'"'}function wu(a){return'link[rel="stylesheet"]['+a+"]"}function jS(a){return p({},a,{"data-precedence":a.precedence,precedence:null})}function jD(a,r,d,m){a.querySelector('link[rel="preload"][as="style"]['+r+"]")?m.loading=1:(r=a.createElement("link"),m.preload=r,r.addEventListener("load",function(){return m.loading|=1}),r.addEventListener("error",function(){return m.loading|=2}),Nn(r,"link",d),xn(r),a.head.appendChild(r))}function Kr(a){return'[src="'+Rs(a)+'"]'}function Su(a){return"script[async]"+a}function XS(a,r,d){if(r.count++,r.instance===null)switch(r.type){case"style":var m=a.querySelector('style[data-href~="'+Rs(d.href)+'"]');if(m)return r.instance=m,xn(m),m;var y=p({},d,{"data-href":d.href,"data-precedence":d.precedence,href:null,precedence:null});return m=(a.ownerDocument||a).createElement("style"),xn(m),Nn(m,"style",y),Sd(m,d.precedence,a),r.instance=m;case"stylesheet":y=Xr(d.href);var w=a.querySelector(wu(y));if(w)return r.state.loading|=4,r.instance=w,xn(w),w;m=jS(d),(y=Ls.get(y))&&fx(m,y),w=(a.ownerDocument||a).createElement("link"),xn(w);var I=w;return I._p=new Promise(function(A,V){I.onload=A,I.onerror=V}),Nn(w,"link",m),r.state.loading|=4,Sd(w,d.precedence,a),r.instance=w;case"script":return w=Kr(d.src),(y=a.querySelector(Su(w)))?(r.instance=y,xn(y),y):(m=d,(y=Ls.get(w))&&(m=p({},d),px(m,y)),a=a.ownerDocument||a,y=a.createElement("script"),xn(y),Nn(y,"link",m),a.head.appendChild(y),r.instance=y);case"void":return null;default:throw Error(s(443,r.type))}else r.type==="stylesheet"&&(r.state.loading&4)===0&&(m=r.instance,r.state.loading|=4,Sd(m,d.precedence,a));return r.instance}function Sd(a,r,d){for(var m=d.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),y=m.length?m[m.length-1]:null,w=y,I=0;I<m.length;I++){var A=m[I];if(A.dataset.precedence===r)w=A;else if(w!==y)break}w?w.parentNode.insertBefore(a,w.nextSibling):(r=d.nodeType===9?d.head:d,r.insertBefore(a,r.firstChild))}function fx(a,r){a.crossOrigin==null&&(a.crossOrigin=r.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=r.referrerPolicy),a.title==null&&(a.title=r.title)}function px(a,r){a.crossOrigin==null&&(a.crossOrigin=r.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=r.referrerPolicy),a.integrity==null&&(a.integrity=r.integrity)}var Cd=null;function KS(a,r,d){if(Cd===null){var m=new Map,y=Cd=new Map;y.set(d,m)}else y=Cd,m=y.get(d),m||(m=new Map,y.set(d,m));if(m.has(a))return m;for(m.set(a,null),d=d.getElementsByTagName(a),y=0;y<d.length;y++){var w=d[y];if(!(w[Ll]||w[$n]||a==="link"&&w.getAttribute("rel")==="stylesheet")&&w.namespaceURI!=="http://www.w3.org/2000/svg"){var I=w.getAttribute(r)||"";I=a+I;var A=m.get(I);A?A.push(w):m.set(I,[w])}}return m}function YS(a,r,d){a=a.ownerDocument||a,a.head.insertBefore(d,r==="title"?a.querySelector("head > title"):null)}function XD(a,r,d){if(d===1||r.itemProp!=null)return!1;switch(a){case"meta":case"title":return!0;case"style":if(typeof r.precedence!="string"||typeof r.href!="string"||r.href==="")break;return!0;case"link":if(typeof r.rel!="string"||typeof r.href!="string"||r.href===""||r.onLoad||r.onError)break;return r.rel==="stylesheet"?(a=r.disabled,typeof r.precedence=="string"&&a==null):!0;case"script":if(r.async&&typeof r.async!="function"&&typeof r.async!="symbol"&&!r.onLoad&&!r.onError&&r.src&&typeof r.src=="string")return!0}return!1}function ZS(a){return!(a.type==="stylesheet"&&(a.state.loading&3)===0)}function KD(a,r,d,m){if(d.type==="stylesheet"&&(typeof m.media!="string"||matchMedia(m.media).matches!==!1)&&(d.state.loading&4)===0){if(d.instance===null){var y=Xr(m.href),w=r.querySelector(wu(y));if(w){r=w._p,r!==null&&typeof r=="object"&&typeof r.then=="function"&&(a.count++,a=$d.bind(a),r.then(a,a)),d.state.loading|=4,d.instance=w,xn(w);return}w=r.ownerDocument||r,m=jS(m),(y=Ls.get(y))&&fx(m,y),w=w.createElement("link"),xn(w);var I=w;I._p=new Promise(function(A,V){I.onload=A,I.onerror=V}),Nn(w,"link",m),d.instance=w}a.stylesheets===null&&(a.stylesheets=new Map),a.stylesheets.set(d,r),(r=d.state.preload)&&(d.state.loading&3)===0&&(a.count++,d=$d.bind(a),r.addEventListener("load",d),r.addEventListener("error",d))}}var mx=0;function YD(a,r){return a.stylesheets&&a.count===0&&kd(a,a.stylesheets),0<a.count||0<a.imgCount?function(d){var m=setTimeout(function(){if(a.stylesheets&&kd(a,a.stylesheets),a.unsuspend){var w=a.unsuspend;a.unsuspend=null,w()}},6e4+r);0<a.imgBytes&&mx===0&&(mx=62500*RD());var y=setTimeout(function(){if(a.waitingForImages=!1,a.count===0&&(a.stylesheets&&kd(a,a.stylesheets),a.unsuspend)){var w=a.unsuspend;a.unsuspend=null,w()}},(a.imgBytes>mx?50:800)+r);return a.unsuspend=d,function(){a.unsuspend=null,clearTimeout(m),clearTimeout(y)}}:null}function $d(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)kd(this,this.stylesheets);else if(this.unsuspend){var a=this.unsuspend;this.unsuspend=null,a()}}}var Td=null;function kd(a,r){a.stylesheets=null,a.unsuspend!==null&&(a.count++,Td=new Map,r.forEach(ZD,a),Td=null,$d.call(a))}function ZD(a,r){if(!(r.state.loading&4)){var d=Td.get(a);if(d)var m=d.get(null);else{d=new Map,Td.set(a,d);for(var y=a.querySelectorAll("link[data-precedence],style[data-precedence]"),w=0;w<y.length;w++){var I=y[w];(I.nodeName==="LINK"||I.getAttribute("media")!=="not all")&&(d.set(I.dataset.precedence,I),m=I)}m&&d.set(null,m)}y=r.instance,I=y.getAttribute("data-precedence"),w=d.get(I)||m,w===m&&d.set(null,y),d.set(I,y),this.count++,m=$d.bind(this),y.addEventListener("load",m),y.addEventListener("error",m),w?w.parentNode.insertBefore(y,w.nextSibling):(a=a.nodeType===9?a.head:a,a.insertBefore(y,a.firstChild)),r.state.loading|=4}}var Cu={$$typeof:k,Provider:null,Consumer:null,_currentValue:W,_currentValue2:W,_threadCount:0};function QD(a,r,d,m,y,w,I,A,V){this.tag=1,this.containerInfo=a,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=cm(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=cm(0),this.hiddenUpdates=cm(null),this.identifierPrefix=m,this.onUncaughtError=y,this.onCaughtError=w,this.onRecoverableError=I,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=V,this.incompleteTransitions=new Map}function QS(a,r,d,m,y,w,I,A,V,at,pt,xt){return a=new QD(a,r,d,I,V,at,pt,xt,A),r=1,w===!0&&(r|=24),w=gs(3,null,null,r),a.current=w,w.stateNode=a,r=Xm(),r.refCount++,a.pooledCache=r,r.refCount++,w.memoizedState={element:m,isDehydrated:d,cache:r},Qm(w),a}function JS(a){return a?(a=kr,a):kr}function tC(a,r,d,m,y,w){y=JS(y),m.context===null?m.context=y:m.pendingContext=y,m=Ca(r),m.payload={element:d},w=w===void 0?null:w,w!==null&&(m.callback=w),d=$a(a,m,r),d!==null&&(os(d,a,r),eu(d,a,r))}function eC(a,r){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var d=a.retryLane;a.retryLane=d!==0&&d<r?d:r}}function gx(a,r){eC(a,r),(a=a.alternate)&&eC(a,r)}function nC(a){if(a.tag===13||a.tag===31){var r=bi(a,67108864);r!==null&&os(r,a,67108864),gx(a,67108864)}}function sC(a){if(a.tag===13||a.tag===31){var r=ws();r=hm(r);var d=bi(a,r);d!==null&&os(d,a,r),gx(a,r)}}var Id=!0;function JD(a,r,d,m){var y=L.T;L.T=null;var w=P.p;try{P.p=2,xx(a,r,d,m)}finally{P.p=w,L.T=y}}function tO(a,r,d,m){var y=L.T;L.T=null;var w=P.p;try{P.p=8,xx(a,r,d,m)}finally{P.p=w,L.T=y}}function xx(a,r,d,m){if(Id){var y=bx(m);if(y===null)sx(a,r,m,Nd,d),aC(a,m);else if(nO(y,a,r,d,m))m.stopPropagation();else if(aC(a,m),r&4&&-1<eO.indexOf(a)){for(;y!==null;){var w=mr(y);if(w!==null)switch(w.tag){case 3:if(w=w.stateNode,w.current.memoizedState.isDehydrated){var I=fi(w.pendingLanes);if(I!==0){var A=w;for(A.pendingLanes|=2,A.entangledLanes|=2;I;){var V=1<<31-ps(I);A.entanglements[1]|=V,I&=~V}vo(w),(fe&6)===0&&(cd=De()+500,xu(0))}}break;case 31:case 13:A=bi(w,2),A!==null&&os(A,w,2),dd(),gx(w,2)}if(w=bx(m),w===null&&sx(a,r,m,Nd,d),w===y)break;y=w}y!==null&&m.stopPropagation()}else sx(a,r,m,null,d)}}function bx(a){return a=vm(a),yx(a)}var Nd=null;function yx(a){if(Nd=null,a=pr(a),a!==null){var r=i(a);if(r===null)a=null;else{var d=r.tag;if(d===13){if(a=l(r),a!==null)return a;a=null}else if(d===31){if(a=u(r),a!==null)return a;a=null}else if(d===3){if(r.stateNode.current.memoizedState.isDehydrated)return r.tag===3?r.stateNode.containerInfo:null;a=null}else r!==a&&(a=null)}}return Nd=a,null}function oC(a){switch(a){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Ys()){case Zs:return 2;case Qs:return 8;case fs:case di:return 32;case dr:return 268435456;default:return 32}default:return 32}}var vx=!1,Fa=null,Ma=null,za=null,$u=new Map,Tu=new Map,La=[],eO="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function aC(a,r){switch(a){case"focusin":case"focusout":Fa=null;break;case"dragenter":case"dragleave":Ma=null;break;case"mouseover":case"mouseout":za=null;break;case"pointerover":case"pointerout":$u.delete(r.pointerId);break;case"gotpointercapture":case"lostpointercapture":Tu.delete(r.pointerId)}}function ku(a,r,d,m,y,w){return a===null||a.nativeEvent!==w?(a={blockedOn:r,domEventName:d,eventSystemFlags:m,nativeEvent:w,targetContainers:[y]},r!==null&&(r=mr(r),r!==null&&nC(r)),a):(a.eventSystemFlags|=m,r=a.targetContainers,y!==null&&r.indexOf(y)===-1&&r.push(y),a)}function nO(a,r,d,m,y){switch(r){case"focusin":return Fa=ku(Fa,a,r,d,m,y),!0;case"dragenter":return Ma=ku(Ma,a,r,d,m,y),!0;case"mouseover":return za=ku(za,a,r,d,m,y),!0;case"pointerover":var w=y.pointerId;return $u.set(w,ku($u.get(w)||null,a,r,d,m,y)),!0;case"gotpointercapture":return w=y.pointerId,Tu.set(w,ku(Tu.get(w)||null,a,r,d,m,y)),!0}return!1}function iC(a){var r=pr(a.target);if(r!==null){var d=i(r);if(d!==null){if(r=d.tag,r===13){if(r=l(d),r!==null){a.blockedOn=r,v1(a.priority,function(){sC(d)});return}}else if(r===31){if(r=u(d),r!==null){a.blockedOn=r,v1(a.priority,function(){sC(d)});return}}else if(r===3&&d.stateNode.current.memoizedState.isDehydrated){a.blockedOn=d.tag===3?d.stateNode.containerInfo:null;return}}}a.blockedOn=null}function Ed(a){if(a.blockedOn!==null)return!1;for(var r=a.targetContainers;0<r.length;){var d=bx(a.nativeEvent);if(d===null){d=a.nativeEvent;var m=new d.constructor(d.type,d);ym=m,d.target.dispatchEvent(m),ym=null}else return r=mr(d),r!==null&&nC(r),a.blockedOn=d,!1;r.shift()}return!0}function rC(a,r,d){Ed(a)&&d.delete(r)}function sO(){vx=!1,Fa!==null&&Ed(Fa)&&(Fa=null),Ma!==null&&Ed(Ma)&&(Ma=null),za!==null&&Ed(za)&&(za=null),$u.forEach(rC),Tu.forEach(rC)}function Rd(a,r){a.blockedOn===r&&(a.blockedOn=null,vx||(vx=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,sO)))}var Ad=null;function lC(a){Ad!==a&&(Ad=a,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Ad===a&&(Ad=null);for(var r=0;r<a.length;r+=3){var d=a[r],m=a[r+1],y=a[r+2];if(typeof m!="function"){if(yx(m||d)===null)continue;break}var w=mr(d);w!==null&&(a.splice(r,3),r-=3,bg(w,{pending:!0,data:y,method:d.method,action:m},m,y))}}))}function Yr(a){function r(V){return Rd(V,a)}Fa!==null&&Rd(Fa,a),Ma!==null&&Rd(Ma,a),za!==null&&Rd(za,a),$u.forEach(r),Tu.forEach(r);for(var d=0;d<La.length;d++){var m=La[d];m.blockedOn===a&&(m.blockedOn=null)}for(;0<La.length&&(d=La[0],d.blockedOn===null);)iC(d),d.blockedOn===null&&La.shift();if(d=(a.ownerDocument||a).$$reactFormReplay,d!=null)for(m=0;m<d.length;m+=3){var y=d[m],w=d[m+1],I=y[Qn]||null;if(typeof w=="function")I||lC(d);else if(I){var A=null;if(w&&w.hasAttribute("formAction")){if(y=w,I=w[Qn]||null)A=I.formAction;else if(yx(y)!==null)continue}else A=I.action;typeof A=="function"?d[m+1]=A:(d.splice(m,3),m-=3),lC(d)}}}function uC(){function a(w){w.canIntercept&&w.info==="react-transition"&&w.intercept({handler:function(){return new Promise(function(I){return y=I})},focusReset:"manual",scroll:"manual"})}function r(){y!==null&&(y(),y=null),m||setTimeout(d,20)}function d(){if(!m&&!navigation.transition){var w=navigation.currentEntry;w&&w.url!=null&&navigation.navigate(w.url,{state:w.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var m=!1,y=null;return navigation.addEventListener("navigate",a),navigation.addEventListener("navigatesuccess",r),navigation.addEventListener("navigateerror",r),setTimeout(d,100),function(){m=!0,navigation.removeEventListener("navigate",a),navigation.removeEventListener("navigatesuccess",r),navigation.removeEventListener("navigateerror",r),y!==null&&(y(),y=null)}}}function wx(a){this._internalRoot=a}Dd.prototype.render=wx.prototype.render=function(a){var r=this._internalRoot;if(r===null)throw Error(s(409));var d=r.current,m=ws();tC(d,m,a,r,null,null)},Dd.prototype.unmount=wx.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var r=a.containerInfo;tC(a.current,2,null,a,null,null),dd(),r[fr]=null}};function Dd(a){this._internalRoot=a}Dd.prototype.unstable_scheduleHydration=function(a){if(a){var r=y1();a={blockedOn:null,target:a,priority:r};for(var d=0;d<La.length&&r!==0&&r<La[d].priority;d++);La.splice(d,0,a),d===0&&iC(a)}};var cC=t.version;if(cC!=="19.2.4")throw Error(s(527,cC,"19.2.4"));P.findDOMNode=function(a){var r=a._reactInternals;if(r===void 0)throw typeof a.render=="function"?Error(s(188)):(a=Object.keys(a).join(","),Error(s(268,a)));return a=h(r),a=a!==null?f(a):null,a=a===null?null:a.stateNode,a};var oO={bundleType:0,version:"19.2.4",rendererPackageName:"react-dom",currentDispatcherRef:L,reconcilerVersion:"19.2.4"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Od=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Od.isDisabled&&Od.supportsFiber)try{mo=Od.inject(oO),Gn=Od}catch{}}return Nu.createRoot=function(a,r){if(!o(a))throw Error(s(299));var d=!1,m="",y=xw,w=bw,I=yw;return r!=null&&(r.unstable_strictMode===!0&&(d=!0),r.identifierPrefix!==void 0&&(m=r.identifierPrefix),r.onUncaughtError!==void 0&&(y=r.onUncaughtError),r.onCaughtError!==void 0&&(w=r.onCaughtError),r.onRecoverableError!==void 0&&(I=r.onRecoverableError)),r=QS(a,1,!1,null,null,d,m,null,y,w,I,uC),a[fr]=r.current,nx(a),new wx(r)},Nu.hydrateRoot=function(a,r,d){if(!o(a))throw Error(s(299));var m=!1,y="",w=xw,I=bw,A=yw,V=null;return d!=null&&(d.unstable_strictMode===!0&&(m=!0),d.identifierPrefix!==void 0&&(y=d.identifierPrefix),d.onUncaughtError!==void 0&&(w=d.onUncaughtError),d.onCaughtError!==void 0&&(I=d.onCaughtError),d.onRecoverableError!==void 0&&(A=d.onRecoverableError),d.formState!==void 0&&(V=d.formState)),r=QS(a,1,!0,r,d??null,m,y,V,w,I,A,uC),r.context=JS(null),d=r.current,m=ws(),m=hm(m),y=Ca(m),y.callback=null,$a(d,y,m),d=m,r.current.lanes=d,zl(r,d),vo(r),a[fr]=r.current,nx(a),new Dd(r)},Nu.version="19.2.4",Nu}var vC;function xO(){if(vC)return $x.exports;vC=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),$x.exports=gO(),$x.exports}var bO=xO();const yO=20,vO={UP:{x:0,y:-1},DOWN:{x:0,y:1},LEFT:{x:-1,y:0},RIGHT:{x:1,y:0}},wO={UP:"DOWN",DOWN:"UP",LEFT:"RIGHT",RIGHT:"LEFT"},SO=["UP","RIGHT","DOWN","LEFT"];class wC{constructor(){this.gridSize=yO,this.reset()}reset(){const t=Math.floor(this.gridSize/2);return this.snake=[{x:t,y:t},{x:t-1,y:t},{x:t-2,y:t}],this.direction="RIGHT",this.nextDirection="RIGHT",this.score=0,this.gameOver=!1,this.stepsWithoutFood=0,this.food=this._spawnFood(),this.getState()}getState(){return{snake:this.snake.map(t=>({...t})),food:{...this.food},direction:this.direction,score:this.score,gameOver:this.gameOver,gridSize:this.gridSize}}step(t){const e=SO[t];e&&this.setDirection(e);const s=this.snake[0],o=Math.abs(s.x-this.food.x)+Math.abs(s.y-this.food.y),i=this.score;this.update();let l=0;if(this.gameOver)l=-10;else if(this.score>i)l=10,this.stepsWithoutFood=0;else if(this.stepsWithoutFood++,this.stepsWithoutFood>this.gridSize*this.gridSize)this.gameOver=!0,l=-10;else{const u=this.snake[0];l=Math.abs(u.x-this.food.x)+Math.abs(u.y-this.food.y)<o?1:-1}return{state:this.getState(),reward:l,done:this.gameOver}}setDirection(t){wO[t]!==this.direction&&(this.nextDirection=t)}update(){if(this.gameOver)return;this.direction=this.nextDirection;const t=vO[this.direction],e=this.snake[0],s={x:e.x+t.x,y:e.y+t.y};if(s.x<0||s.x>=this.gridSize||s.y<0||s.y>=this.gridSize){this.gameOver=!0;return}if(this.snake.some(o=>o.x===s.x&&o.y===s.y)){this.gameOver=!0;return}this.snake.unshift(s),s.x===this.food.x&&s.y===this.food.y?(this.score+=10,this.food=this._spawnFood()):this.snake.pop()}_spawnFood(){const t=new Set(this.snake.map(s=>`${s.x},${s.y}`)),e=[];for(let s=0;s<this.gridSize;s++)for(let o=0;o<this.gridSize;o++)t.has(`${s},${o}`)||e.push({x:s,y:o});return e[Math.floor(Math.random()*e.length)]}}const as=25,CO="#1a1a2e",$O="#16213e",TO="#4ade80",kO="#22c55e",IO="#ef4444",SC={ArrowUp:"UP",ArrowDown:"DOWN",ArrowLeft:"LEFT",ArrowRight:"RIGHT"},NO=["UP","RIGHT","DOWN","LEFT"],EO=ae.forwardRef(function({engine:t,tickInterval:e,onScoreChange:s,aiAction:o},i){const l=ae.useRef(null),u=ae.useRef(0),c=ae.useRef(null),h=ae.useRef(o);return h.current=o,ae.useImperativeHandle(i,()=>({getState:()=>t.getState(),step:f=>t.step(f),reset:()=>t.reset()}),[t]),ae.useEffect(()=>{const f=l.current,p=f.getContext("2d"),g=t.gridSize*as;f.width=g,f.height=g;function x(){p.fillStyle=CO,p.fillRect(0,0,g,g),p.strokeStyle=$O,p.lineWidth=.5;for(let C=0;C<=t.gridSize;C++)p.beginPath(),p.moveTo(C*as,0),p.lineTo(C*as,g),p.stroke(),p.beginPath(),p.moveTo(0,C*as),p.lineTo(g,C*as),p.stroke();p.fillStyle=IO,p.beginPath();const v=t.food.x*as+as/2,S=t.food.y*as+as/2;p.arc(v,S,as/2-2,0,Math.PI*2),p.fill(),t.snake.forEach((C,$)=>{p.fillStyle=$===0?kO:TO;const k=1;p.fillRect(C.x*as+k,C.y*as+k,as-k*2,as-k*2)}),t.gameOver&&(p.fillStyle="rgba(0, 0, 0, 0.7)",p.fillRect(0,0,g,g),p.fillStyle="#fff",p.font="bold 36px monospace",p.textAlign="center",p.fillText("GAME OVER",g/2,g/2-20),p.font="20px monospace",p.fillText(`Score: ${t.score}`,g/2,g/2+20),p.font="16px monospace",p.fillStyle="#aaa",p.fillText("Press Space or Enter to restart",g/2,g/2+55))}function b(v){v-u.current>=e&&(h.current!=null&&t.setDirection(NO[h.current]),t.update(),s(t.score),u.current=v),x(),c.current=requestAnimationFrame(b)}return c.current=requestAnimationFrame(b),()=>cancelAnimationFrame(c.current)},[t,e,s]),ae.useEffect(()=>{function f(p){h.current==null&&(SC[p.key]&&(p.preventDefault(),t.setDirection(SC[p.key])),(p.key===" "||p.key==="Enter")&&t.gameOver&&(p.preventDefault(),t.reset()))}return window.addEventListener("keydown",f),()=>window.removeEventListener("keydown",f)},[t]),$e.jsx("canvas",{ref:l,style:{display:"block",border:"2px solid #333",borderRadius:4}})});function RO({aiMode:n,stats:t,onTrain:e,onWatch:s,onStop:o,onExport:i,onImport:l,modelLoaded:u}){const c=n==="training"||n==="playing";return $e.jsxs("div",{className:"training-panel",children:[$e.jsxs("div",{className:"training-controls",children:[n==="training"?$e.jsx("button",{onClick:o,children:"Stop Training"}):$e.jsx("button",{onClick:e,disabled:n==="playing",children:"Train"}),$e.jsx("button",{onClick:s,disabled:n==="training",children:n==="playing"?"Stop Watching":"Watch AI Play"})]}),$e.jsxs("div",{className:"model-controls",children:[$e.jsx("button",{onClick:i,disabled:c||!u,children:"Export Model"}),$e.jsx("button",{onClick:l,disabled:c,children:"Import Model"}),u&&$e.jsx("span",{className:"model-badge",children:"Model saved"})]}),$e.jsxs("div",{className:"training-stats",children:[$e.jsxs("span",{children:["Episode: ",t.episode]}),$e.jsxs("span",{children:["Epsilon: ",t.epsilon.toFixed(3)]}),$e.jsxs("span",{children:["Avg Reward: ",t.avgReward.toFixed(1)]}),$e.jsxs("span",{children:["Best Score: ",t.bestScore]})]})]})}const AO=1e-7,DO=1e-4;class p${constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class _0{refCount(t){return is("refCount")}incRef(t){return is("incRef")}timerAvailable(){return!0}time(t){return is("time")}read(t){return is("read")}readSync(t){return is("readSync")}readToGPU(t,e){return is("readToGPU")}numDataIds(){return is("numDataIds")}disposeData(t,e){return is("disposeData")}write(t,e,s){return is("write")}move(t,e,s,o,i){return is("move")}createTensorFromGPUData(t,e,s){return is("createTensorFromGPUData")}memory(){return is("memory")}floatPrecision(){return is("floatPrecision")}epsilon(){return this.floatPrecision()===32?AO:DO}dispose(){return is("dispose")}}function is(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function OO(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Jr(n,t,e)}function F0(n,t,e){return Math.max(n,Math.min(t,e))}function M0(n){return n%2===0?n:n+1}function Jr(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function _O(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function _(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function z0(n,t,e=""){_(ce(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function m$(n){_(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function dt(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function ce(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function rl(n){return n%1===0}function Zx(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function nl(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function CC(n,t=o=>0,e,s){return new Promise((o,i)=>{let l=0;const u=()=>{if(n()){o();return}l++;const c=t(l);if(e!=null&&l>=e){i();return}s!=null?s(u,c):setTimeout(u,c)};u()})}function g$(n,t){let e=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const o=n.slice();return o[s]=t/e,o}function qt(n,t){const e=t.length;return n=n==null?t.map((s,o)=>o):[].concat(n),_(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),_(n.every(s=>rl(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function ei(n,t){const e=[],s=[],o=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||o?null:qt(t,n).sort();let l=0;for(let u=0;u<n.length;++u){if(i!=null){if(i[l]===u&&n[u]!==1)throw new Error(`Can't squeeze axis ${u} since its dim '${n[u]}' is not 1`);(i[l]==null||i[l]>u)&&n[u]===1&&(e.push(n[u]),s.push(u)),i[l]<=u&&l++}n[u]!==1&&(e.push(n[u]),s.push(u))}return{newShape:e,keptDims:s}}function En(n,t){return Ge(n,t)}function Ge(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function FO(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function MO(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function x$(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function sf(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function zO(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function tc(n){return typeof n=="string"||n instanceof String}function LO(n){return typeof n=="boolean"}function Qx(n){return typeof n=="number"}function yl(n){return Array.isArray(n)?yl(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Qx(n)?"float32":tc(n)?"string":LO(n)?"bool":"float32"}function Jx(n){return!!(n&&n.constructor&&n.call&&n.apply)}function t0(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function Rt(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function b$(n,t,e,s=!1){const o=new Array;if(t.length===1){const i=t[0]*(s?2:1);for(let l=0;l<i;l++)o[l]=e[n+l]}else{const i=t[0],l=t.slice(1),u=l.reduce((c,h)=>c*h)*(s?2:1);for(let c=0;c<i;c++)o[c]=b$(n+c*u,l,e,s)}return o}function ro(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((o,i)=>o*i)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return b$(0,n,t,e)}function BO(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function L0(n,t){const e=Rn(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function Rn(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function y$(n,t){const e=n.reduce((s,o)=>s*o,1);if(t==null||t==="float32")return ro(n,new Float32Array(e));if(t==="int32")return ro(n,new Int32Array(e));if(t==="bool")return ro(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function da(n){n.forEach(t=>{_(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Io(n,t,e){if(t===0)return 0;if(t===1)return n[0];let s=n[n.length-1];for(let o=0;o<n.length-1;++o)s+=e[o]*n[o];return s}function vl(n,t,e){if(t===0)return[];if(t===1)return[n];const s=new Array(t);for(let o=0;o<s.length-1;++o)s[o]=Math.floor(n/e[o]),n-=s[o]*e[o];return s[s.length-1]=n,s}function B0(n){return n&&n.then&&typeof n.then=="function"}const $C="tfjsflags";class UO{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=VO,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(lt().getBool("IS_TEST")||lt().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const o=this.urlFlags[t];lt().getBool("IS_TEST")||lt().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(B0(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);$C in t&&t[$C].split(",").forEach(s=>{const[o,i]=s.split(":");this.urlFlags[o]=GO(o,i)})}}function VO(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(PO(t,s[0],s[1]),s.join("="))),t}function PO(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function GO(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function lt(){return v$}let v$=null;function WO(n){v$=n}let Nx;function w$(){if(Nx==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Nx=n}return Nx}function HO(){const n=w$();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function U0(n,t){const e=HO();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const _f="Abs",ec="Acos",nc="Acosh",wl="Add",V0="AddN",P0="All",G0="Any",Ff="ArgMax",Mf="ArgMin",sc="Asin",oc="Asinh",ac="Atan",ic="Atanh",rc="Atan2",zf="AvgPool",W0="AvgPoolGrad",Lf="AvgPool3D",H0="AvgPool3DGrad",Bf="BatchMatMul",Uf="BatchToSpaceND",q0="Bincount",j0="BitwiseAnd",qO="BroadcastTo",S$="BroadcastArgs",lc="Cast",uc="Ceil",cc="ClipByValue",X0="Complex",Vf="ComplexAbs",Pf="Concat",Gf="Conv2D",K0="Conv2DBackpropFilter",Wf="Conv2DBackpropInput",Hf="Conv3D",Y0="Conv3DBackpropFilterV2",Z0="Conv3DBackpropInputV2",hc="Cos",dc="Cosh",Q0="Cumprod",qf="Cumsum",J0="CropAndResize",tb="DenseBincount",eb="DepthToSpace",jf="DepthwiseConv2dNative",nb="DepthwiseConv2dNativeBackpropFilter",sb="DepthwiseConv2dNativeBackpropInput",C$="Diag",Xf="Dilation2D",e0="Dilation2DBackpropInput",n0="Dilation2DBackpropFilter",jO="Draw",fc="RealDiv",ob="Einsum",pc="Elu",ab="EluGrad",mc="Erf",Kf="Equal",gc="Exp",Yf="ExpandDims",xc="Expm1",ib="FFT",rb="Fill",lb="FlipLeftRight",bc="Floor",yc="FloorDiv",Zf="FusedBatchNorm",Qf="GatherV2",$$="GatherNd",Jf="Greater",vc="GreaterEqual",wc="Identity",ub="IFFT",cb="Imag",Sc="IsFinite",Cc="IsInf",$c="IsNan",tp="LeakyRelu",ep="Less",np="LessEqual",T$="LinSpace",Tc="Log",kc="Log1p",sp="LogicalAnd",op="LogicalNot",ap="LogicalOr",XO="LogSoftmax",ip="LRN",hb="LRNGrad",rp="Max",Ic="Maximum",lp="MaxPool",db="MaxPoolGrad",up="MaxPool3D",fb="MaxPool3DGrad",k$="MaxPoolWithArgmax",cp="Mean",hp="Min",Nc="Minimum",dp="MirrorPad",Ec="Mod",I$="Multinomial",Rc="Multiply",fp="Neg",pp="NotEqual",pb="NonMaxSuppressionV3",mb="NonMaxSuppressionV4",gb="NonMaxSuppressionV5",mp="OnesLike",gp="OneHot",xp="Pack",bp="PadV2",Ac="Pow",yp="Prelu",vp="Prod",N$="RaggedGather",E$="RaggedRange",R$="RaggedTensorToTensor",xb="Range",bb="Real",Dc="Reciprocal",Oc="Relu",wp="Reshape",Sp="ResizeNearestNeighbor",yb="ResizeNearestNeighborGrad",Cp="ResizeBilinear",vb="ResizeBilinearGrad",_c="Relu6",$p="Reverse",Fc="Round",Mc="Rsqrt",A$="ScatterNd",D$="TensorScatterUpdate",O$="SearchSorted",Tp="Select",zc="Selu",kp="Slice",Lc="Sin",Bc="Sinh",Uc="Sign",Vc="Sigmoid",Pc="Softplus",Gc="Sqrt",Ip="Sum",Np="SpaceToBatchND",Ep="SplitV",Rp="Softmax",_$="SparseFillEmptyRows",F$="SparseReshape",M$="SparseSegmentMean",z$="SparseSegmentSum",L$="SparseToDense",Wc="SquaredDifference",wb="Square",Sb="StaticRegexReplace",Cb="StridedSlice",B$="StringNGrams",U$="StringSplit",V$="StringToHashBucketFast",Hc="Sub",qc="Tan",jc="Tanh",Xc="Tile",$b="TopK",Tb="Transform",sl="Transpose",kb="Unique",Ap="Unpack",Dp="UnsortedSegmentSum",Op="ZerosLike",Kc="Step",KO="FromPixels",Ib="RotateWithOffset",of="_FusedMatMul",af="FusedConv2D",P$="FusedDepthwiseConv2D";function Ss(...n){lt().getBool("IS_TEST")||lt().getBool("PROD")||console.warn(...n)}const rf=U0("kernelRegistry",()=>new Map),s0=U0("gradRegistry",()=>new Map);function TC(n,t){const e=W$(n,t);return rf.get(e)}function kC(n){return s0.get(n)}function IC(n){const t=rf.entries(),e=[];for(;;){const{done:s,value:o}=t.next();if(s)break;const[i,l]=o,[u]=i.split("_");u===n&&e.push(l)}return e}function G$(n){const{kernelName:t,backendName:e}=n,s=W$(t,e);rf.has(s)&&Ss(`The kernel '${t}' for backend '${e}' is already registered`),rf.set(s,n)}function YO(n){const{kernelName:t}=n;s0.has(t)&&lt().getBool("DEBUG")&&Ss(`Overriding the gradient for '${t}'`),s0.set(t,n)}function W$(n,t){return`${t}_${n}`}function H$(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Ex,NC;function ZO(){if(NC)return Ex;NC=1,Ex=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(F,E,U){this.low=F|0,this.high=E|0,this.unsigned=!!U}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(F){return(F&&F.__isLong__)===!0}t.isLong=e;var s={},o={};function i(F,E){var U,Y,X;return E?(F>>>=0,(X=0<=F&&F<256)&&(Y=o[F],Y)?Y:(U=u(F,(F|0)<0?-1:0,!0),X&&(o[F]=U),U)):(F|=0,(X=-128<=F&&F<128)&&(Y=s[F],Y)?Y:(U=u(F,F<0?-1:0,!1),X&&(s[F]=U),U))}t.fromInt=i;function l(F,E){if(isNaN(F))return E?$:C;if(E){if(F<0)return $;if(F>=b)return D}else{if(F<=-v)return z;if(F+1>=v)return R}return F<0?l(-F,E).neg():u(F%x|0,F/x|0,E)}t.fromNumber=l;function u(F,E,U){return new t(F,E,U)}t.fromBits=u;var c=Math.pow;function h(F,E,U){if(F.length===0)throw Error("empty string");if(F==="NaN"||F==="Infinity"||F==="+Infinity"||F==="-Infinity")return C;if(typeof E=="number"?(U=E,E=!1):E=!!E,U=U||10,U<2||36<U)throw RangeError("radix");var Y;if((Y=F.indexOf("-"))>0)throw Error("interior hyphen");if(Y===0)return h(F.substring(1),E,U).neg();for(var X=l(c(U,8)),q=C,L=0;L<F.length;L+=8){var P=Math.min(8,F.length-L),W=parseInt(F.substring(L,L+P),U);if(P<8){var nt=l(c(U,P));q=q.mul(nt).add(l(W))}else q=q.mul(X),q=q.add(l(W))}return q.unsigned=E,q}t.fromString=h;function f(F,E){return typeof F=="number"?l(F,E):typeof F=="string"?h(F,E):u(F.low,F.high,typeof E=="boolean"?E:F.unsigned)}t.fromValue=f;var p=65536,g=1<<24,x=p*p,b=x*x,v=b/2,S=i(g),C=i(0);t.ZERO=C;var $=i(0,!0);t.UZERO=$;var k=i(1);t.ONE=k;var T=i(1,!0);t.UONE=T;var N=i(-1);t.NEG_ONE=N;var R=u(-1,2147483647,!1);t.MAX_VALUE=R;var D=u(-1,-1,!0);t.MAX_UNSIGNED_VALUE=D;var z=u(0,-2147483648,!1);t.MIN_VALUE=z;var O=t.prototype;return O.toInt=function(){return this.unsigned?this.low>>>0:this.low},O.toNumber=function(){return this.unsigned?(this.high>>>0)*x+(this.low>>>0):this.high*x+(this.low>>>0)},O.toString=function(E){if(E=E||10,E<2||36<E)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(z)){var U=l(E),Y=this.div(U),X=Y.mul(U).sub(this);return Y.toString(E)+X.toInt().toString(E)}else return"-"+this.neg().toString(E);for(var q=l(c(E,6),this.unsigned),L=this,P="";;){var W=L.div(q),nt=L.sub(W.mul(q)).toInt()>>>0,it=nt.toString(E);if(L=W,L.isZero())return it+P;for(;it.length<6;)it="0"+it;P=""+it+P}},O.getHighBits=function(){return this.high},O.getHighBitsUnsigned=function(){return this.high>>>0},O.getLowBits=function(){return this.low},O.getLowBitsUnsigned=function(){return this.low>>>0},O.getNumBitsAbs=function(){if(this.isNegative())return this.eq(z)?64:this.neg().getNumBitsAbs();for(var E=this.high!=0?this.high:this.low,U=31;U>0&&(E&1<<U)==0;U--);return this.high!=0?U+33:U+1},O.isZero=function(){return this.high===0&&this.low===0},O.eqz=O.isZero,O.isNegative=function(){return!this.unsigned&&this.high<0},O.isPositive=function(){return this.unsigned||this.high>=0},O.isOdd=function(){return(this.low&1)===1},O.isEven=function(){return(this.low&1)===0},O.equals=function(E){return e(E)||(E=f(E)),this.unsigned!==E.unsigned&&this.high>>>31===1&&E.high>>>31===1?!1:this.high===E.high&&this.low===E.low},O.eq=O.equals,O.notEquals=function(E){return!this.eq(E)},O.neq=O.notEquals,O.ne=O.notEquals,O.lessThan=function(E){return this.comp(E)<0},O.lt=O.lessThan,O.lessThanOrEqual=function(E){return this.comp(E)<=0},O.lte=O.lessThanOrEqual,O.le=O.lessThanOrEqual,O.greaterThan=function(E){return this.comp(E)>0},O.gt=O.greaterThan,O.greaterThanOrEqual=function(E){return this.comp(E)>=0},O.gte=O.greaterThanOrEqual,O.ge=O.greaterThanOrEqual,O.compare=function(E){if(e(E)||(E=f(E)),this.eq(E))return 0;var U=this.isNegative(),Y=E.isNegative();return U&&!Y?-1:!U&&Y?1:this.unsigned?E.high>>>0>this.high>>>0||E.high===this.high&&E.low>>>0>this.low>>>0?-1:1:this.sub(E).isNegative()?-1:1},O.comp=O.compare,O.negate=function(){return!this.unsigned&&this.eq(z)?z:this.not().add(k)},O.neg=O.negate,O.add=function(E){e(E)||(E=f(E));var U=this.high>>>16,Y=this.high&65535,X=this.low>>>16,q=this.low&65535,L=E.high>>>16,P=E.high&65535,W=E.low>>>16,nt=E.low&65535,it=0,M=0,G=0,Q=0;return Q+=q+nt,G+=Q>>>16,Q&=65535,G+=X+W,M+=G>>>16,G&=65535,M+=Y+P,it+=M>>>16,M&=65535,it+=U+L,it&=65535,u(G<<16|Q,it<<16|M,this.unsigned)},O.subtract=function(E){return e(E)||(E=f(E)),this.add(E.neg())},O.sub=O.subtract,O.multiply=function(E){if(this.isZero())return C;if(e(E)||(E=f(E)),n){var U=n.mul(this.low,this.high,E.low,E.high);return u(U,n.get_high(),this.unsigned)}if(E.isZero())return C;if(this.eq(z))return E.isOdd()?z:C;if(E.eq(z))return this.isOdd()?z:C;if(this.isNegative())return E.isNegative()?this.neg().mul(E.neg()):this.neg().mul(E).neg();if(E.isNegative())return this.mul(E.neg()).neg();if(this.lt(S)&&E.lt(S))return l(this.toNumber()*E.toNumber(),this.unsigned);var Y=this.high>>>16,X=this.high&65535,q=this.low>>>16,L=this.low&65535,P=E.high>>>16,W=E.high&65535,nt=E.low>>>16,it=E.low&65535,M=0,G=0,Q=0,ut=0;return ut+=L*it,Q+=ut>>>16,ut&=65535,Q+=q*it,G+=Q>>>16,Q&=65535,Q+=L*nt,G+=Q>>>16,Q&=65535,G+=X*it,M+=G>>>16,G&=65535,G+=q*nt,M+=G>>>16,G&=65535,G+=L*W,M+=G>>>16,G&=65535,M+=Y*it+X*nt+q*W+L*P,M&=65535,u(Q<<16|ut,M<<16|G,this.unsigned)},O.mul=O.multiply,O.divide=function(E){if(e(E)||(E=f(E)),E.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&E.low===-1&&E.high===-1)return this;var U=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,E.low,E.high);return u(U,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?$:C;var Y,X,q;if(this.unsigned){if(E.unsigned||(E=E.toUnsigned()),E.gt(this))return $;if(E.gt(this.shru(1)))return T;q=$}else{if(this.eq(z)){if(E.eq(k)||E.eq(N))return z;if(E.eq(z))return k;var L=this.shr(1);return Y=L.div(E).shl(1),Y.eq(C)?E.isNegative()?k:N:(X=this.sub(E.mul(Y)),q=Y.add(X.div(E)),q)}else if(E.eq(z))return this.unsigned?$:C;if(this.isNegative())return E.isNegative()?this.neg().div(E.neg()):this.neg().div(E).neg();if(E.isNegative())return this.div(E.neg()).neg();q=C}for(X=this;X.gte(E);){Y=Math.max(1,Math.floor(X.toNumber()/E.toNumber()));for(var P=Math.ceil(Math.log(Y)/Math.LN2),W=P<=48?1:c(2,P-48),nt=l(Y),it=nt.mul(E);it.isNegative()||it.gt(X);)Y-=W,nt=l(Y,this.unsigned),it=nt.mul(E);nt.isZero()&&(nt=k),q=q.add(nt),X=X.sub(it)}return q},O.div=O.divide,O.modulo=function(E){if(e(E)||(E=f(E)),n){var U=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,E.low,E.high);return u(U,n.get_high(),this.unsigned)}return this.sub(this.div(E).mul(E))},O.mod=O.modulo,O.rem=O.modulo,O.not=function(){return u(~this.low,~this.high,this.unsigned)},O.and=function(E){return e(E)||(E=f(E)),u(this.low&E.low,this.high&E.high,this.unsigned)},O.or=function(E){return e(E)||(E=f(E)),u(this.low|E.low,this.high|E.high,this.unsigned)},O.xor=function(E){return e(E)||(E=f(E)),u(this.low^E.low,this.high^E.high,this.unsigned)},O.shiftLeft=function(E){return e(E)&&(E=E.toInt()),(E&=63)===0?this:E<32?u(this.low<<E,this.high<<E|this.low>>>32-E,this.unsigned):u(0,this.low<<E-32,this.unsigned)},O.shl=O.shiftLeft,O.shiftRight=function(E){return e(E)&&(E=E.toInt()),(E&=63)===0?this:E<32?u(this.low>>>E|this.high<<32-E,this.high>>E,this.unsigned):u(this.high>>E-32,this.high>=0?0:-1,this.unsigned)},O.shr=O.shiftRight,O.shiftRightUnsigned=function(E){if(e(E)&&(E=E.toInt()),E&=63,E===0)return this;var U=this.high;if(E<32){var Y=this.low;return u(Y>>>E|U<<32-E,U>>>E,this.unsigned)}else return E===32?u(U,0,this.unsigned):u(U>>>E-32,0,this.unsigned)},O.shru=O.shiftRightUnsigned,O.shr_u=O.shiftRightUnsigned,O.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},O.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},O.toBytes=function(E){return E?this.toBytesLE():this.toBytesBE()},O.toBytesLE=function(){var E=this.high,U=this.low;return[U&255,U>>>8&255,U>>>16&255,U>>>24,E&255,E>>>8&255,E>>>16&255,E>>>24]},O.toBytesBE=function(){var E=this.high,U=this.low;return[E>>>24,E>>>16&255,E>>>8&255,E&255,U>>>24,U>>>16&255,U>>>8&255,U&255]},t.fromBytes=function(E,U,Y){return Y?t.fromBytesLE(E,U):t.fromBytesBE(E,U)},t.fromBytesLE=function(E,U){return new t(E[0]|E[1]<<8|E[2]<<16|E[3]<<24,E[4]|E[5]<<8|E[6]<<16|E[7]<<24,U)},t.fromBytesBE=function(E,U){return new t(E[4]<<24|E[5]<<16|E[6]<<8|E[7],E[0]<<24|E[1]<<16|E[2]<<8|E[3],U)},Ex}var q$=ZO();const j$=rO(q$),QO=iO({__proto__:null,default:j$},[q$]);const _i=j$||QO;function _p(n){return _i.fromString(n,!0,16)}const X$=_p("c3a5c85c97cb3127"),Oi=_p("b492b66fbe98f273"),zn=_p("9ae16a3b2f90404f");function o0(n){return n.xor(n.shru(47))}function K$(n,t,e){const s=n.slice(t,t+e);return _i.fromBytes(Array.from(s),!0,!0)}function Ie(n,t){return K$(n,t,8)}function EC(n,t){return K$(n,t,4)}function fn(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function Ha(n,t,e=_p("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let o=t.xor(s).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function JO(n,t,e,s,o,i){o=o.add(n),i=fn(i.add(o).add(s),21);const l=o;return o=o.add(t),o=o.add(e),i=i.add(fn(o,44)),[o.add(s),i.add(l)]}function _d(n,t,e,s){return JO(Ie(n,t),Ie(n,t+8),Ie(n,t+16),Ie(n,t+24),e,s)}function t_(n,t=n.length){if(t>=8){const e=zn.add(t*2),s=Ie(n,0).add(zn),o=Ie(n,t-8),i=fn(o,37).mul(e).add(s),l=fn(s,25).add(o).mul(e);return Ha(i,l,e)}if(t>=4){const e=zn.add(t*2),s=EC(n,0);return Ha(s.shl(3).add(t),EC(n,t-4),e)}if(t>0){const e=n[0],s=n[t>>1],o=n[t-1],i=e+(s<<8),l=t+(o<<2);return o0(zn.mul(i).xor(X$.mul(l))).mul(zn)}return zn}function e_(n,t=n.length){const e=zn.add(t*2),s=Ie(n,0).mul(Oi),o=Ie(n,8),i=Ie(n,t-8).mul(e),l=Ie(n,t-16).mul(zn);return Ha(fn(s.add(o),43).add(fn(i,30)).add(l),s.add(fn(o.add(zn),18)).add(i),e)}function n_(n,t=n.length){const e=zn.add(t*2),s=Ie(n,0).mul(zn),o=Ie(n,8),i=Ie(n,t-8).mul(e),l=Ie(n,t-16).mul(zn),u=fn(s.add(o),43).add(fn(i,30)).add(l),c=Ha(u,s.add(fn(o.add(zn),18)).add(i),e),h=Ie(n,16).mul(e),f=Ie(n,24),p=u.add(Ie(n,t-32)).mul(e),g=c.add(Ie(n,t-24)).mul(e);return Ha(fn(h.add(f),43).add(fn(p,30)).add(g),h.add(fn(f.add(s),18)).add(p),e)}function s_(n,t=n.length){const e=_i.fromNumber(81,!0);if(t<=32)return t<=16?t_(n,t):e_(n,t);if(t<=64)return n_(n,t);let s=e,o=e.mul(Oi).add(113),i=o0(o.mul(zn).add(113)).mul(zn),l=[_i.UZERO,_i.UZERO],u=[_i.UZERO,_i.UZERO];s=s.mul(zn).add(Ie(n,0));let c=0;const h=(t-1>>6)*64,f=h+(t-1&63)-63;do s=fn(s.add(o).add(l[0]).add(Ie(n,c+8)),37).mul(Oi),o=fn(o.add(l[1]).add(Ie(n,c+48)),42).mul(Oi),s=s.xor(u[1]),o=o.add(l[0]).add(Ie(n,c+40)),i=fn(i.add(u[0]),33).mul(Oi),l=_d(n,c,l[1].mul(Oi),s.add(u[0])),u=_d(n,c+32,i.add(u[1]),o.add(Ie(n,c+16))),[i,s]=[s,i],c+=64;while(c!==h);const p=Oi.add(i.and(255).shl(1));return c=f,u[0]=u[0].add(t-1&63),l[0]=l[0].add(u[0]),u[0]=u[0].add(l[0]),s=fn(s.add(o).add(l[0]).add(Ie(n,c+8)),37).mul(p),o=fn(o.add(l[1]).add(Ie(n,c+48)),42).mul(p),s=s.xor(u[1].mul(9)),o=o.add(l[0].mul(9).add(Ie(n,c+40))),i=fn(i.add(u[0]),33).mul(p),l=_d(n,c,l[1].mul(p),s.add(u[0])),u=_d(n,c+32,i.add(u[1]),o.add(Ie(n,c+16))),[i,s]=[s,i],Ha(Ha(l[0],u[0],p).add(o0(o).mul(X$)).add(i),Ha(l[1],u[1],p).add(s),p)}function ni(n,t){return t==="string"?qa(n):nr([n],t)}function o_(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function nr(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Pi(n)),lt().getBool("DEBUG")&&FO(n,t),o_(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Hn(){return lt().platform.now()}function qa(n,t="utf-8"){return t=t||"utf-8",lt().platform.encode(n,t)}function Ka(n,t="utf-8"){return t=t||"utf-8",lt().platform.decode(n,t)}function Hs(n){return lt().platform.isTypedArray!=null?lt().platform.isTypedArray(n):H$(n)}function Pi(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||B0(n)||n==null||Hs(n)&&e)t.push(n);else if(Array.isArray(n)||Hs(n))for(let s=0;s<n.length;++s)Pi(n[s],t,e);else{let s=-1;for(const o of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(o)&&(s=Math.max(s,Number(o)));for(let o=0;o<=s;o++)Pi(n[o],t,e)}return t}class a_{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new r_)}profileKernel(t,e,s){let o;const i=()=>{o=s()};let l;const u=Hn();if(this.backendTimer.timerAvailable())l=this.backendTimer.time(i);else{i();for(const h of o)h.dataSync();l=Promise.resolve({kernelMs:Hn()-u})}if(lt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<o.length;h++){const f=o[h];f.data().then(p=>{i_(p,f.dtype,t)})}return{kernelName:t,outputs:o,inputs:e,timeMs:l.then(h=>h.kernelMs),extraInfo:l.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:o,inputs:i,extraInfo:l}=t;s.forEach(u=>{Promise.all([u.data(),o,l]).then(c=>{this.logger.logKernelProfile(e,u,c[0],c[1],i,c[2])})})}}function i_(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const o=n[s];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}class r_{logKernelProfile(t,e,s,o,i,l){const u=typeof o=="number"?nl(`${o}ms`,9):o.error,c=nl(t,25),h=e.rank,f=e.size,p=nl(e.shape.toString(),14);let g="";for(const x in i){const b=i[x];if(b!=null){const v=b.shape||e.shape,S=v.length;g+=`${x}: ${S}D ${S>0?v:""} `}}console.log(`%c${c}	%c${u}	%c${h}D ${p}	%c${f}	%c${g}	%c${l}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function l_(n,t,e){const s={},o={};for(let c=0;c<t.length;c++)s[t[c].id]=!0;for(let c=0;c<n.length;c++){const h=n[c],f=h.inputs;for(const p in f){const g=f[p];let x=!1;for(let b=0;b<t.length;b++)if(s[g.id]){h.outputs.forEach(v=>s[v.id]=!0),x=!0,o[h.id]=!0;break}if(x)break}}const i={};i[e.id]=!0;const l={};for(let c=n.length-1;c>=0;c--){const h=n[c],f=h.inputs;for(let p=0;p<h.outputs.length;p++)if(i[h.outputs[p].id]){for(const g in f)i[f[g].id]=!0,l[h.id]=!0;break}}const u=[];for(let c=0;c<n.length;c++){const h=n[c];if(o[h.id]&&l[h.id]){const f={};for(const g in h.inputs){const x=h.inputs[g];s[x.id]&&(f[g]=x)}const p=Object.assign({},h);p.inputs=f,p.outputs=h.outputs,u.push(p)}}return u}function u_(n,t,e,s){for(let o=t.length-1;o>=0;o--){const i=t[o],l=[];if(i.outputs.forEach(c=>{const h=n[c.id];h!=null?l.push(h):l.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const u=i.gradient(l);for(const c in i.inputs){if(!(c in u))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(u)}.`);const h=e(()=>u[c]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${h.dtype}'`);const f=i.inputs[c];if(!ce(h.shape,f.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${c}' has shape '${h.shape}', which does not match the shape of the input '${f.shape}'`);if(n[f.id]==null)n[f.id]=h;else{const p=n[f.id];n[f.id]=s(p,h),p.dispose()}}}}const RC=20,Eu=3,Rx=7;function c_(n,t,e,s){const o=Rt(t),i=h_(n,t,e,o),l=t.length,u=Xd(n,t,e,o,i),c=["Tensor"];return s&&(c.push(`  dtype: ${e}`),c.push(`  rank: ${l}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(u.map(h=>"    "+h).join(`
`)),c.join(`
`)}function h_(n,t,e,s){const o=dt(t),i=s[s.length-1],l=new Array(i).fill(0),u=t.length,c=e==="complex64"?_u(n):n;if(u>1)for(let h=0;h<o/i;h++){const f=h*i;for(let p=0;p<i;p++)l[p]=Math.max(l[p],Ou(c[f+p],0,e).length)}return l}function Ou(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Rx))} + ${parseFloat(n[1].toFixed(Rx))}j`:tc(n)?s=`'${n}'`:e==="bool"?s=Y$(n):s=parseFloat(n.toFixed(Rx)).toString(),nl(s,t)}function Y$(n){return n===0?"false":"true"}function Xd(n,t,e,s,o,i=!0){const l=e==="complex64"?2:1,u=t[0],c=t.length;if(c===0){if(e==="complex64"){const v=_u(n);return[Ou(v[0],0,e)]}return e==="bool"?[Y$(n[0])]:[n[0].toString()]}if(c===1){if(u>RC){const S=Eu*l;let C=Array.from(n.slice(0,S)),$=Array.from(n.slice((u-Eu)*l,u*l));return e==="complex64"&&(C=_u(C),$=_u($)),["["+C.map((k,T)=>Ou(k,o[T],e)).join(", ")+", ..., "+$.map((k,T)=>Ou(k,o[u-Eu+T],e)).join(", ")+"]"]}return["["+(e==="complex64"?_u(n):Array.from(n)).map((S,C)=>Ou(S,o[C],e)).join(", ")+"]"]}const h=t.slice(1),f=s.slice(1),p=s[0]*l,g=[];if(u>RC){for(let v=0;v<Eu;v++){const S=v*p,C=S+p;g.push(...Xd(n.slice(S,C),h,e,f,o,!1))}g.push("...");for(let v=u-Eu;v<u;v++){const S=v*p,C=S+p;g.push(...Xd(n.slice(S,C),h,e,f,o,v===u-1))}}else for(let v=0;v<u;v++){const S=v*p,C=S+p;g.push(...Xd(n.slice(S,C),h,e,f,o,v===u-1))}const x=c===2?",":"";g[0]="["+(u>0?g[0]+x:"");for(let v=1;v<g.length-1;v++)g[v]=" "+g[v]+x;let b=`,
`;for(let v=2;v<c;v++)b+=`
`;return g[g.length-1]=" "+g[g.length-1]+"]"+(i?"":b),g}function _u(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class vn{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=dt(t),s!=null){const o=s.length;_(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Ge(e,this.size),this.strides=Rt(t)}set(t,...e){e.length===0&&(e=[0]),_(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const o of t){if(o<0||o>=this.shape[e]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}e++}let s=t[t.length-1];for(let o=0;o<t.length-1;++o)s+=this.strides[o]*t[o];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return oo().makeTensor(this.values,this.shape,this.dtype)}}let oo=null,tl=null;function d_(n){oo=n}function f_(n){tl=n}class sn{constructor(t,e,s,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=dt(t),this.strides=Rt(t),this.dataId=s,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return tl.buffer(this.shape,this.dtype,t)}bufferSync(){return tl.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return ro(this.shape,t,this.dtype==="complex64")}arraySync(){return ro(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=oo().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>Ka(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),oo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=oo().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>Ka(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await oo().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),oo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return tl.print(this,t)}clone(){return this.throwIfDisposed(),tl.clone(this)}toString(t=!1){const e=this.dataSync();return c_(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),tl.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),oo().makeVariable(this,t,e,s)}}Object.defineProperty(sn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function ht(){return U0("Tensor",()=>sn)}ht();class lf extends sn{constructor(t,e,s,o){super(t.shape,t.dtype,t.dataId,o),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!ce(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);oo().disposeTensor(this),this.dataId=t.dataId,oo().incRef(this,null)}dispose(){oo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(lf,Symbol.hasInstance,{value:n=>n instanceof sn&&n.assign!=null&&n.assign instanceof Function});var AC;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(AC||(AC={}));var a0;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(a0||(a0={}));var i0;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(i0||(i0={}));var r0;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(r0||(r0={}));var l0;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(l0||(l0={}));const p_={float32:r0,int32:a0,bool:i0,complex64:l0};function us(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return p_[n][t]}function Nb(n){return us(n,"int32")}function Z$(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function Q$(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function He(n,t){if(n.dtype===t.dtype)return[n,t];const e=us(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function J$(n){const t=[];return tT(n,t,new Set),t}function tT(n,t,e){if(n==null)return;if(n instanceof sn){t.push(n);return}if(!m_(n))return;const s=n;for(const o in s){const i=s[o];e.has(i)||(e.add(i),tT(i,t,e))}}function m_(n){return Array.isArray(n)||typeof n=="object"}function Ax(n){return n.kernelName!=null}class DC{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class ll{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new DC}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(Ss(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new a_(this.backendInstance),!0}setupRegisteredKernels(){IC(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){IC(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof _0)&&typeof s.then=="function"){const o=++this.pendingBackendInitId,i=s.then(l=>o<this.pendingBackendInitId?!1:(this.registry[t]=l,this.pendingBackendInit=null,!0)).catch(l=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Ss(`Initialization of backend ${t} failed`),Ss(l.stack||l.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Ss(`Initialization of backend ${t} failed`),Ss(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),o=s.backend,i=this.readSync(e),l=o.refCount(e);o.disposeData(e,!0),s.backend=t,t.move(e,i,s.shape,s.dtype,l),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let o;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=e(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(t,e,s){t();try{const o=s();return e(),o}catch(o){throw e(),o}}nextTensorId(){return ll.nextTensorId++}nextVariableId(){return ll.nextVariableId++}clone(t){const e=Z.runKernel(wc,{x:t}),s={x:t},o=l=>({x:()=>{const u="float32",c={x:l},h={dtype:u};return Z.runKernel(lc,c,h)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[e],o,i,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(TC(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const o=this.backend.numDataIds();let i=0;s.forEach(c=>{i+=c.dtype==="complex64"?3:1});const l=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],u=o-e-i-l;if(u>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${u} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const o=this.isTapeOn(),i=this.state.numBytes,l=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let u;this.backendName==null&&this.backend;let c;const h=Ax(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Ax(t)){const{kernelName:b,inputs:v,attrs:S}=t;this.backendName==null&&this.backend;const C=TC(b,this.backendName);_(C!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),u=()=>{const $=this.backend.numDataIds();c=C.kernelFunc({inputs:v,attrs:S,backend:this.backend});const k=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,$,k);const T=k.map(N=>N.rank!=null?N:this.makeTensorFromTensorInfo(N));if(o){const N=this.getTensorsForGradient(b,v,T);s=this.saveTensorsForBackwardMode(N)}return T}}else{const{forwardFunc:b}=t,v=S=>{o&&(s=S.map(C=>this.keep(this.clone(C))))};u=()=>{const S=this.backend.numDataIds();c=this.tidy(()=>b(this.backend,v));const C=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,S,C),C}}const{inputs:f,attrs:p}=t,g=Ax(t)?null:t.backwardsFunc;let x;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=u():(x=this.profiler.profileKernel(h,f,()=>u()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(x),e=x.outputs)}),o&&this.addTapeNode(h,f,e,g,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-l,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(f).map(b=>f[b]!=null?f[b].shape:null),outputShapes:e.map(b=>b.shape),kernelTimeMs:x.timeMs,extraInfo:x.extraInfo}),Array.isArray(c)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const o=kC(t);if(o!=null){const i=o.inputsToSave||[],l=o.outputsToSave||[];let u;o.saveAllInputs?(_(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),u=Object.keys(e).map(h=>e[h])):u=i.map(h=>e[h]);const c=s.filter((h,f)=>l[f]);return u.concat(c)}return[]}makeTensor(t,e,s,o){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",o=o||this.backend;let i=t;s==="string"&&tc(t[0])&&(i=t.map(c=>qa(c)));const l=o.write(i,e,s),u=new sn(e,s,l,this.nextTensorId());if(this.trackTensor(u,o),s==="string"){const c=this.state.tensorInfo.get(l),h=zO(i);this.state.numBytes+=h-c.bytes,c.bytes=h}return u}makeTensorFromDataId(t,e,s,o){s=s||"float32";const i={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(i,o)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:o,dtype:i}=t,l=new sn(o,i,s,this.nextTensorId());return this.trackTensor(l,e),l}makeVariable(t,e=!0,s,o){s=s||this.nextVariableId().toString(),o!=null&&o!==t.dtype&&(t=t.cast(o));const i=new lf(t,e,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*sf(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof lf||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*sf(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,o,i,l){const u={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:i},c=kC(t);c!=null&&(o=c.gradFunc),o!=null&&(u.gradient=h=>(h=h.map((f,p)=>{if(f==null){const g=s[p],x=Rn(g.size,g.dtype);return this.makeTensor(x,g.shape,g.dtype)}return f}),o(h.length>1?h:h[0],i,l))),this.state.activeTape.push(u)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=J$(t),s=new Set(e.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const l=this.state.activeScope.track[i];!l.kept&&!s.has(l.id)&&l.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(t,e,s,o=!1){if(_(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));_(i instanceof sn,()=>"The result y returned by f() must be a tensor.");const l=l_(this.state.activeTape,e,i);if(!o&&l.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const u={};u[i.id]=s??g_(i.shape),u_(u,l,h=>this.tidy(h),x_);const c=e.map(h=>u[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const f of h.saved)f.dispose()}),this.state.activeTape=null),{value:i,grads:c}})}customGrad(t){return _(Jx(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{_(e.every(u=>u instanceof sn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const o={};e.forEach((u,c)=>{o[c]=u});const i=(u,c)=>(s=t(...e,c),_(s.value instanceof sn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),_(Jx(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),l=(u,c)=>{const h=s.gradFunc(u,c),f=Array.isArray(h)?h:[h];_(f.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),_(f.every(g=>g instanceof sn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return f.forEach((g,x)=>{p[x]=()=>g}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:l,inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=Hn(),s=await this.backend.time(t);return s.wallMs=Hn()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new DC;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ll.nextTensorId=0;ll.nextVariableId=0;function g_(n){const t=L0(dt(n),"float32");return Z.makeTensor(t,n,"float32")}function eT(){const n=w$();if(n._tfengine==null){const t=new UO(n);n._tfengine=new ll(t)}return WO(n._tfengine.ENV),d_(()=>n._tfengine),n._tfengine}const Z=eT();function x_(n,t){const e={a:n,b:t};return Z.runKernel(wl,e)}function b_(){return typeof navigator<"u"&&navigator!=null}function nT(n){if(n||b_()){if(n||(n=navigator),n.product==="ReactNative")return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function sT(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Kn=lt();Kn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Kn.registerFlag("IS_BROWSER",()=>sT());Kn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Kn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Kn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Kn.registerFlag("PROD",()=>!1);Kn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Kn.getBool("DEBUG"));Kn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Kn.registerFlag("IS_TEST",()=>!1);Kn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Kn.getBool("DEBUG"));Kn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Kn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Kn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Fp(n,t){let e=n;if(Hs(n))return t==="string"?[]:[n.length];if(Z$(n)){const o=n.channels||"RGBA";return[n.height,n.width*o.length]}else if(Q$(n))return[n.buffer.size/(t==null?4:sf(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||Hs(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&lt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&oT(n,s,[]),s}function oT(n,t,e){if(e=e||[],!Array.isArray(n)&&!Hs(n)){_(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}_(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),_(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let o=0;o<n.length;++o)oT(n[o],s,e.concat(o))}function OC(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function B(n,t,e,s="numeric"){if(n instanceof ht())return OC(s,n.dtype,t,e),n;let o=yl(n);if(o!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(o=s),OC(s,o,t,e),n==null||!Hs(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const c=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${c}'`)}const i=Fp(n,o);!Hs(n)&&!Array.isArray(n)&&(n=[n]);const u=o!=="string"?nr(n,o):Pi(n,[],!0);return Z.makeTensor(u,i,o)}function aT(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,l)=>B(i,`${t}[${l}]`,e,s))}const y_="__op";function tt(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+y_;const o=(...i)=>{Z.startScope(e);try{const l=s(...i);return B0(l)&&console.error("Cannot return a Promise inside of tidy."),Z.endScope(l),l}catch(l){throw Z.endScope(null),l}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function v_(n,t){const e=B(n,"real","complex"),s=B(t,"imag","complex");z0(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const o={real:e,imag:s};return Z.runKernel(X0,o)}const Gi=tt({complex_:v_});function Mp(n,t,e,s){if(s==null)s=yl(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Q$(n)||Z$(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return Z.backend.createTensorFromGPUData(n,t||e,s)}if(!Hs(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){da(t);const o=dt(t),i=dt(e);_(o===i,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${i}`);for(let l=0;l<e.length;++l){const u=e[l],c=l===e.length-1?u!==dt(t.slice(l)):!0;_(e[l]===t[l]||!c,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Hs(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?nr(n,s):Pi(n,[],!0),Z.makeTensor(n,t,s)}function Bu(n,t,e){const s=Fp(n,e);return Mp(n,t,s,e)}const uf={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class si{static join(t){return new si(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>Hs(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const o=t[s];s!==t.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=e+o.byteLength;this.shards.push({buffer:o,start:e,end:i}),e=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const o=e-t,i=new ArrayBuffer(o),l=new Uint8Array(i);let u=0;for(let c=s;c<this.shards.length;c++){const h=this.shards[c],p=t+u-h.start,g=u,b=Math.min(e,h.end)-h.start,v=new Uint8Array(h.buffer,p,b-p);if(l.set(v,g),u+=v.length,e<h.end)break}return i}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(o){return t<o.start?-1:t>=o.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=w_(this.shards,e);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function w_(n,t){let e=0,s=n.length;for(;e<=s;){const o=Math.floor((s-e)/2)+e,i=t(n[o]);if(i===0)return o;i<0?s=o:e=o+1}return-1}function wo(){return Z}function _C(){return Z.memory()}function st(n,t){return Z.tidy(n,t)}function Wt(n){J$(n).forEach(e=>e.dispose())}function No(n){return Z.keep(n)}function iT(n,t,e=1){return Z.registerBackend(n,t,e)}function S_(){return Z.backend}const ul=4;async function FC(n,t){const e=[],s=[],o=Array.isArray(n)?n.map(l=>l.name):Object.keys(n);for(let l=0;l<o.length;++l){const u=o[l],c=Array.isArray(n)?n[l].tensor:n[u];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${u}': ${c.dtype}`);const h={name:u,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const f=new Promise(async p=>{const g=await c.bytes(),x=g.reduce((S,C)=>S+C.length,0)+ul*g.length,b=new Uint8Array(x);let v=0;for(let S=0;S<g.length;S++){const C=g[S],$=new Uint8Array(new Uint32Array([C.length]).buffer);b.set($,v),v+=ul,b.set(C,v),v+=C.length}p(b)});s.push(f)}else s.push(c.data());t!=null&&(h.group=t),e.push(h)}const i=await Promise.all(s);return{data:k_(i),specs:e}}function C_(n,t){const e=new si(n),s={};let o=0;for(const i of t){const l=$_(i,(u,c)=>e.slice(o+u,o+c));s[i.name]=T_(i,e.slice(o,o+l)),o+=l}return s}function $_(n,t){const e=dt(n.shape);let s;if("quantization"in n){const o=n.quantization;s=uf[o.dtype]}else if(n.dtype==="string"){let o=0;for(let i=0;i<e;i++)o+=ul+new Uint32Array(t(o,o+ul))[0];return o}else s=uf[n.dtype];return e*s}function T_(n,t){const e=n.name,s=n.dtype,o=n.shape,i=dt(o);let l,u=0;if("quantization"in n){const c=n.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${n.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=uf[c.dtype],f=c.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){l=new Float32Array(f.length);for(let p=0;p<f.length;p++){const g=f[p];l[p]=g*c.scale+c.min}}else if(c.dtype==="float16")l=M_()(f);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(s==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);l=new Int32Array(f.length);for(let p=0;p<f.length;p++){const g=f[p];l[p]=Math.round(g*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);u+=i*h}else if(s==="string"){const c=dt(n.shape);l=[];for(let h=0;h<c;h++){const f=new Uint32Array(t.slice(u,u+ul))[0];u+=ul;const p=new Uint8Array(t.slice(u,u+f));l.push(p),u+=f}}else{const c=uf[s];if(s==="float32")l=new Float32Array(t);else if(s==="int32")l=new Int32Array(t);else if(s==="bool")l=new Uint8Array(t);else if(s==="complex64"){l=new Float32Array(t);const h=new Float32Array(l.length/2),f=new Float32Array(l.length/2);for(let b=0;b<h.length;b++)h[b]=l[b*2],f[b]=l[b*2+1];const p=Bu(h,o,"float32"),g=Bu(f,o,"float32"),x=Gi(p,g);return p.dispose(),g.dispose(),x}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);u+=i*c}return Bu(l,o,s)}function k_(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let o=0;return e.forEach(i=>{s.set(new Uint8Array(i.buffer),o),o+=i.byteLength}),s.buffer}const Eb=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function MC(n){return Eb?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function I_(n){if(Eb)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,o=t.length;s<o;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function N_(n){if(Eb){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function E_(n){return si.join(n)}function R_(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(e.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function A_(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function D_(n,t){let e,s;return n.weightsManifest!=null&&([e,s]=await t(n.weightsManifest)),A_(n,e,s)}function Rb(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:MC(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:MC(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new si(n.weightData).byteLength}}function zC(n){const t=[];for(const e of n)t.push(...e.weights);return t}function O_(){const n=e=>{let s=e<<13,o=0;for(;(s&8388608)===0;)o-=8388608,s<<=1;return s&=-8388609,o+=947912704,s|o},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function __(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function F_(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function M_(){const n=O_(),t=__(),e=F_();return s=>{const o=new ArrayBuffer(4*s.length),i=new Uint32Array(o);for(let l=0;l<s.length;l++){const u=s[l],c=n[e[u>>10]+(u&1023)]+t[u>>10];i[l]=c}return new Float32Array(o)}}class dn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return dn.instance==null&&(dn.instance=new dn),dn.instance}static registerSaveRouter(t){dn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){dn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return dn.getHandlers(t,"save")}static getLoadHandlers(t,e){return dn.getHandlers(t,"load",e)}static getHandlers(t,e,s){const o=[];return(e==="load"?dn.getInstance().loadRouters:dn.getInstance().saveRouters).forEach(l=>{const u=l(t,s);u!==null&&o.push(u)}),o}}const z_=n=>dn.getSaveHandlers(n),L_=(n,t)=>dn.getLoadHandlers(n,t);const u0="tensorflowjs",c0=1,zi="models_store",Pa="model_info_store";function rT(){if(!lt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function h0(n){const t=n.result;t.createObjectStore(zi,{keyPath:"modelPath"}),t.createObjectStore(Pa,{keyPath:"modelPath"})}class Wi{constructor(t){if(this.indexedDB=rT(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,o)=>{const i=this.indexedDB.open(u0,c0);i.onupgradeneeded=()=>h0(i),i.onsuccess=()=>{const l=i.result;if(e==null){const u=l.transaction(zi,"readonly"),h=u.objectStore(zi).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return l.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=f=>(l.close(),o(h.error)),u.oncomplete=()=>l.close()}else{e.weightData=si.join(e.weightData);const u=Rb(e),c=l.transaction(Pa,"readwrite");let h=c.objectStore(Pa),f;try{f=h.put({modelPath:this.modelPath,modelArtifactsInfo:u})}catch(g){return o(g)}let p;f.onsuccess=()=>{p=l.transaction(zi,"readwrite");const g=p.objectStore(zi);let x;try{x=g.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:u})}catch(b){return o(b)}x.onsuccess=()=>s({modelArtifactsInfo:u}),x.onerror=b=>{h=c.objectStore(Pa);const v=h.delete(this.modelPath);v.onsuccess=()=>(l.close(),o(x.error)),v.onerror=S=>(l.close(),o(x.error))}},f.onerror=g=>(l.close(),o(f.error)),c.oncomplete=()=>{p==null?l.close():p.oncomplete=()=>l.close()}}},i.onerror=l=>o(i.error)})}}Wi.URL_SCHEME="indexeddb://";const lT=n=>lt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Wi.URL_SCHEME)?B_(n.slice(Wi.URL_SCHEME.length)):null;dn.registerSaveRouter(lT);dn.registerLoadRouter(lT);function B_(n){return new Wi(n)}function U_(n){return n.startsWith(Wi.URL_SCHEME)?n.slice(Wi.URL_SCHEME.length):n}class V_{constructor(){this.indexedDB=rT()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(u0,c0);s.onupgradeneeded=()=>h0(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(Pa,"readonly"),u=i.objectStore(Pa).getAll();u.onsuccess=()=>{const c={};for(const h of u.result)c[h.modelPath]=h.modelArtifactsInfo;t(c)},u.onerror=c=>(o.close(),e(u.error)),i.oncomplete=()=>o.close()},s.onerror=o=>e(s.error)})}async removeModel(t){return t=U_(t),new Promise((e,s)=>{const o=this.indexedDB.open(u0,c0);o.onupgradeneeded=()=>h0(o),o.onsuccess=()=>{const i=o.result,l=i.transaction(Pa,"readwrite"),u=l.objectStore(Pa),c=u.get(t);let h;c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const f=u.delete(t),p=()=>{h=i.transaction(zi,"readwrite");const x=h.objectStore(zi).delete(t);x.onsuccess=()=>e(c.result.modelArtifactsInfo),x.onerror=b=>s(c.error)};f.onsuccess=p,f.onerror=g=>(p(),i.close(),s(c.error))}},c.onerror=f=>(i.close(),s(c.error)),l.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})}}const ia="/",el="tensorflowjs_models",uT="info",P_="model_topology",G_="weight_specs",W_="weight_data",H_="model_metadata";function cT(n){return{info:[el,n,uT].join(ia),topology:[el,n,P_].join(ia),weightSpecs:[el,n,G_].join(ia),weightData:[el,n,W_].join(ia),modelMetadata:[el,n,H_].join(ia)}}function hT(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function q_(n){const t=n.split(ia);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(ia)}function j_(n){return n.startsWith(Hi.URL_SCHEME)?n.slice(Hi.URL_SCHEME.length):n}class Hi{constructor(t){if(!lt().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=cT(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),o=Rb(t),i=si.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,I_(i));const l={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(l)),{modelArtifactsInfo:o}}catch{throw hT(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=o;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const u=JSON.parse(i);e.format=u.format,e.generatedBy=u.generatedBy,e.convertedBy=u.convertedBy,u.signature!=null&&(e.signature=u.signature),u.userDefinedMetadata!=null&&(e.userDefinedMetadata=u.userDefinedMetadata),u.modelInitializer!=null&&(e.modelInitializer=u.modelInitializer),u.initializerSignature!=null&&(e.initializerSignature=u.initializerSignature),u.trainingConfig!=null&&(e.trainingConfig=u.trainingConfig)}const l=this.LS.getItem(this.keys.weightData);if(l==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=N_(l),e}}Hi.URL_SCHEME="localstorage://";const dT=n=>lt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Hi.URL_SCHEME)?X_(n.slice(Hi.URL_SCHEME.length)):null;dn.registerSaveRouter(dT);dn.registerLoadRouter(dT);function X_(n){return new Hi(n)}class K_{constructor(){_(lt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),_(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=el+ia,s=ia+uT;for(let o=0;o<this.LS.length;++o){const i=this.LS.key(o);if(i.startsWith(e)&&i.endsWith(s)){const l=q_(i);t[l]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=j_(t);const e=cT(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return hT(e),s}}const LC="://";class So{constructor(){this.managers={}}static getInstance(){return So.instance==null&&(So.instance=new So),So.instance}static registerManager(t,e){_(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(LC)&&(t=t.slice(0,t.indexOf(LC))),_(t.length>0,()=>"scheme must not be an empty string.");const s=So.getInstance();_(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=So.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(So.getInstance().managers)}}class Y_{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!lt().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const o=this.functionRefs[s.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return H$(t)}}if(lt().get("IS_BROWSER")){lt().setPlatform("browser",new Y_);try{So.registerManager(Hi.URL_SCHEME,new K_)}catch{}try{So.registerManager(Wi.URL_SCHEME,new V_)}catch{}}const Z_={importFetch:()=>require("node-fetch")};let Dx;class Q_{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return lt().global.fetch!=null?lt().global.fetch(t,e):(Dx==null&&(Dx=Z_.importFetch()),Dx(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}lt().get("IS_NODE")&&!lt().get("IS_BROWSER")&&lt().setPlatform("node",new Q_);function Ht(n,t="float32",e){return t=t||"float32",da(n),new vn(n,t,e)}function J_(n,t){const e=B(n,"x","cast");if(!MO(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},o={dtype:t};return Z.runKernel(lc,s,o)}const $t=tt({cast_:J_});function t3(n){const e={x:B(n,"x","clone","string_or_numeric")};return Z.runKernel(wc,e)}const Bi=tt({clone_:t3});function e3(n,t=!1){console.log(n.toString(t))}eT();const n3={buffer:Ht,cast:$t,clone:Bi,print:e3};f_(n3);function s3(n,t){let e=B(n,"a","add"),s=B(t,"b","add");[e,s]=He(e,s);const o={a:e,b:s};return Z.runKernel(wl,o)}const vt=tt({add_:s3});function o3(n,t){let e=B(n,"a","floorDiv"),s=B(t,"b","floorDiv");[e,s]=He(e,s);const o={a:e,b:s};return Z.runKernel(yc,o)}const fT=tt({floorDiv_:o3});function a3(n,t){let e=B(n,"a","div"),s=B(t,"b","div");if([e,s]=He(e,s),e.dtype==="int32"&&s.dtype==="int32")return fT(e,s);const o={a:e,b:s},i={};return Z.runKernel(fc,o,i)}const Ot=tt({div_:a3});function i3(n,t){let e=B(n,"a","mul"),s=B(t,"b","mul");[e,s]=He(e,s);const o={a:e,b:s};return Z.runKernel(Rc,o)}const K=tt({mul_:i3});function r3(n){const t=B(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return Z.runKernel(Vf,e)}else{const e={x:t};return Z.runKernel(_f,e)}}const Mn=tt({abs_:r3});function l3(n){const e={x:B(n,"x","acos")};return Z.runKernel(ec,e)}const u3=tt({acos_:l3});function c3(n){const e={x:B(n,"x","acosh")};return Z.runKernel(nc,e)}const h3=tt({acosh_:c3});function d3(n,t=null,e=!1){const o={x:B(n,"x","all","bool")},i={axis:t,keepDims:e};return Z.runKernel(P0,o,i)}const pT=tt({all_:d3});function f3(n,t=null,e=!1){const o={x:B(n,"x","any","bool")},i={axis:t,keepDims:e};return Z.runKernel(G0,o,i)}const d0=tt({any_:f3});function p3(n,t=0){const s={x:B(n,"x","argMax")},o={axis:t};return Z.runKernel(Ff,s,o)}const Pu=tt({argMax_:p3});function m3(n,t=0){const s={x:B(n,"x","argMin")},o={axis:t};return Z.runKernel(Mf,s,o)}const g3=tt({argMin_:m3});function x3(n){const e={x:B(n,"x","asin")};return Z.runKernel(sc,e)}const b3=tt({asin_:x3});function y3(n){const e={x:B(n,"x","asinh")};return Z.runKernel(oc,e)}const v3=tt({asinh_:y3});function w3(n){const e={x:B(n,"x","atan")};return Z.runKernel(ac,e)}const S3=tt({atan_:w3});function C3(n,t){let e=B(n,"a","atan2"),s=B(t,"b","atan2");[e,s]=He(e,s);const o={a:e,b:s};return Z.runKernel(rc,o)}const $3=tt({atan2_:C3});function T3(n){const e={x:B(n,"x","atanh")};return Z.runKernel(ic,e)}const k3=tt({atanh_:T3});function Yc(n,t,e,s,o="NHWC",i){const l=n[3],u=[...t,l],c=pa(o);return wn(n,u,e,i,s,null,null,c)}function js(n,t,e,s,o,i,l="channelsLast"){const[u,c]=Gu(t);let h;if(l==="channelsLast")h=[u,c,n[3],n[3]];else if(l==="channelsFirst")h=[u,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${l}`);return wn(n,h,e,s,o,i,!1,l)}function fa(n,t,e,s,o,i,l="NDHWC"){const[u,c,h]=f0(t);let f,p;if(l==="NDHWC")p="channelsLast",f=[u,c,h,n[4],n[4]];else if(l==="NCDHW")p="channelsFirst",f=[u,c,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${l}`);return oi(n,f,e,s,o,!1,p,i)}function wn(n,t,e,s,o,i,l=!1,u="channelsLast"){let[c,h,f,p]=[-1,-1,-1,-1];if(u==="channelsLast")[c,h,f,p]=n;else if(u==="channelsFirst")[c,p,h,f]=n;else throw new Error(`Unknown dataFormat ${u}`);const[g,x,,b]=t,[v,S]=Gu(e),[C,$]=Gu(s),k=ol(g,C),T=ol(x,$),{padInfo:N,outHeight:R,outWidth:D}=E3(o,h,f,v,S,k,T,i,u),z=l?b*p:b;let O;return u==="channelsFirst"?O=[c,z,R,D]:u==="channelsLast"&&(O=[c,R,D,z]),{batchSize:c,dataFormat:u,inHeight:h,inWidth:f,inChannels:p,outHeight:R,outWidth:D,outChannels:z,padInfo:N,strideHeight:v,strideWidth:S,filterHeight:g,filterWidth:x,effectiveFilterHeight:k,effectiveFilterWidth:T,dilationHeight:C,dilationWidth:$,inShape:n,outShape:O,filterShape:t}}function oi(n,t,e,s,o,i=!1,l="channelsLast",u){let[c,h,f,p,g]=[-1,-1,-1,-1,-1];if(l==="channelsLast")[c,h,f,p,g]=n;else if(l==="channelsFirst")[c,g,h,f,p]=n;else throw new Error(`Unknown dataFormat ${l}`);const[x,b,v,,S]=t,[C,$,k]=f0(e),[T,N,R]=f0(s),D=ol(x,T),z=ol(b,N),O=ol(v,R),{padInfo:F,outDepth:E,outHeight:U,outWidth:Y}=R3(o,h,f,p,C,$,k,D,z,O,u),X=i?S*g:S;let q;return l==="channelsFirst"?q=[c,X,E,U,Y]:l==="channelsLast"&&(q=[c,E,U,Y,X]),{batchSize:c,dataFormat:l,inDepth:h,inHeight:f,inWidth:p,inChannels:g,outDepth:E,outHeight:U,outWidth:Y,outChannels:X,padInfo:F,strideDepth:C,strideHeight:$,strideWidth:k,filterDepth:x,filterHeight:b,filterWidth:v,effectiveFilterDepth:D,effectiveFilterHeight:z,effectiveFilterWidth:O,dilationDepth:T,dilationHeight:N,dilationWidth:R,inShape:n,outShape:q,filterShape:t}}function I3(n,t,e,s,o){s==null&&(s=Ab(n,t,e));const i=n[0],l=n[1],u=Wu((i-t+2*s)/e+1,o),c=Wu((l-t+2*s)/e+1,o);return[u,c]}function N3(n,t,e,s,o,i){o==null&&(o=Ab(n,t[0],s[0]));const l=[0,0,0,e];for(let u=0;u<3;u++)n[u]+2*o>=t[u]&&(l[u]=Wu((n[u]-t[u]+2*o)/s[u]+1,i));return l}function Ab(n,t,e,s=1){const o=ol(t,s);return Math.floor((n[0]*(e-1)-e+o)/2)}function Gu(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function f0(n){return typeof n=="number"?[n,n,n]:n}function ol(n,t){return t<=1?n:n+(n-1)*(t-1)}function E3(n,t,e,s,o,i,l,u,c){let h,f,p;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const x=I3([t,e],i,s,n,u);f=x[0],p=x[1]}else if(n==="same"){f=Math.ceil(t/s),p=Math.ceil(e/o);const g=Math.max(0,(f-1)*s+i-t),x=Math.max(0,(p-1)*o+l-e),b=Math.floor(g/2),v=g-b,S=Math.floor(x/2),C=x-S;h={top:b,bottom:v,left:S,right:C,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},f=Math.ceil((t-i+1)/s),p=Math.ceil((e-l+1)/o);else if(typeof n=="object"){const g=c==="channelsLast"?n[1][0]:n[2][0],x=c==="channelsLast"?n[1][1]:n[2][1],b=c==="channelsLast"?n[2][0]:n[3][0],v=c==="channelsLast"?n[2][1]:n[3][1];h={top:g,bottom:x,left:b,right:v,type:g===0&&x===0&&b===0&&v===0?"VALID":"EXPLICIT"},f=Wu((t-i+g+x)/s+1,u),p=Wu((e-l+b+v)/o+1,u)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:f,outWidth:p}}function R3(n,t,e,s,o,i,l,u,c,h,f){let p,g,x,b;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const S=N3([t,e,s,1],[u,c,h],1,[o,i,l],n,f);g=S[0],x=S[1],b=S[2]}else if(n==="same"){g=Math.ceil(t/o),x=Math.ceil(e/i),b=Math.ceil(s/l);const v=(g-1)*o+u-t,S=(x-1)*i+c-e,C=(b-1)*l+h-s,$=Math.floor(v/2),k=v-$,T=Math.floor(S/2),N=S-T,R=Math.floor(C/2),D=C-R;p={top:T,bottom:N,left:R,right:D,front:$,back:k,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:g,outHeight:x,outWidth:b}}function Wu(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function qi(n){const[t,e,s]=Gu(n);return t===1&&e===1&&s===1}function Dn(n,t){return qi(n)||qi(t)}function ji(n){return Gu(n).every(t=>t>0)}function pa(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Zn(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")_(rl(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(o=>{_(rl(o),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}function A3(n,t){const s={x:B(n,"x","reshape","string_or_numeric")},o={shape:t};return Z.runKernel(wp,s,o)}const J=tt({reshape_:A3});function D3(n,t,e,s,o){const i=B(n,"x","avgPool","float32"),l=1;_(Dn(e,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${l}'`);let u=i,c=!1;i.rank===3&&(c=!0,u=J(i,[1,i.shape[0],i.shape[1],i.shape[2]])),_(u.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${u.rank}.`),Zn("avgPool",s,o);const h={x:u},f={filterSize:t,strides:e,pad:s,dimRoundingMode:o};let p=Z.runKernel(zf,h,f);return p=$t(p,i.dtype),c?J(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Db=tt({avgPool_:D3});function O3(n,t,e,s,o,i="NDHWC"){const l=B(n,"x","avgPool3d","float32");let u=l,c=!1;l.rank===4&&(c=!0,u=J(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),_(u.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`),_(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),_(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),Zn("avgPool3d",s,o);const h={x:u},f={filterSize:t,strides:e,pad:s,dimRoundingMode:o,dataFormat:i};let p=Z.runKernel(Lf,h,f);return p=$t(p,u.dtype),c?J(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const _3=tt({avgPool3d_:O3});function F3(n,t=0){_(n.length>=1,()=>"Pass at least one tensor to concat");const e=aT(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),e.length===1)return Bi(e[0]);const s=e,o={axis:t};return Z.runKernel(Pf,s,o)}const Xn=tt({concat_:F3});function M3(n,t,e=!1,s=!1){let o=B(n,"a","matMul"),i=B(t,"b","matMul");[o,i]=He(o,i);const l={a:o,b:i},u={transposeA:e,transposeB:s};return Z.runKernel(Bf,l,u)}const le=tt({matMul_:M3});function z3(n){const e={x:B(n,"x","sigmoid","float32")};return Z.runKernel(Vc,e)}const Sl=tt({sigmoid_:z3});function L3(n,t,e){const s=B(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const o={x:s},i={begin:t,size:e};return Z.runKernel(kp,o,i)}const Ne=tt({slice_:L3});function B3(n){const e={x:B(n,"x","tanh","float32")};return Z.runKernel(jc,e)}const zp=tt({tanh_:B3});function U3(n,t,e){const s=B(n,"x","batchToSpaceND"),o=t.reduce((u,c)=>u*c);_(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),_(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),_(s.shape[0]%o===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);const i={x:s},l={blockShape:t,crops:e};return Z.runKernel(Uf,i,l)}const Ob=tt({batchToSpaceND_:U3});function V3(n){let t;return n.rank===0||n.rank===1?t=J(n,[1,1,1,n.size]):n.rank===2?t=J(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function P3(n,t,e,s,o,i){i==null&&(i=.001);const l=B(n,"x","batchNorm"),u=B(t,"mean","batchNorm"),c=B(e,"variance","batchNorm");let h;o!=null&&(h=B(o,"scale","batchNorm"));let f;s!=null&&(f=B(s,"offset","batchNorm")),_(u.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(f==null||u.rank===f.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(h==null||u.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const g={x:V3(l),scale:h,offset:f,mean:u,variance:c},x={varianceEpsilon:i},b=Z.runKernel(Zf,g,x);return J(b,l.shape)}const Lp=tt({batchNorm_:P3});function G3(n,t,e,s,o,i){const l=B(n,"x","batchNorm"),u=B(t,"mean","batchNorm"),c=B(e,"variance","batchNorm");let h;o!=null&&(h=B(o,"scale","batchNorm"));let f;return s!=null&&(f=B(s,"offset","batchNorm")),_(l.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`),_(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`),_(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&_(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),f!=null&&_(f.rank===2||f.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${f.rank}.`),Lp(l,u,c,f,h,i)}const W3=tt({batchNorm2d_:G3});function H3(n,t,e,s,o,i){const l=B(n,"x","batchNorm"),u=B(t,"mean","batchNorm"),c=B(e,"variance","batchNorm");let h;o!=null&&(h=B(o,"scale","batchNorm"));let f;return s!=null&&(f=B(s,"offset","batchNorm")),_(l.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`),_(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`),_(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&_(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),f!=null&&_(f.rank===3||f.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${f.rank}.`),Lp(l,u,c,f,h,i)}const q3=tt({batchNorm3d_:H3});function j3(n,t,e,s,o,i){const l=B(n,"x","batchNorm"),u=B(t,"mean","batchNorm"),c=B(e,"variance","batchNorm");let h;o!=null&&(h=B(o,"scale","batchNorm"));let f;return s!=null&&(f=B(s,"offset","batchNorm")),_(l.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`),_(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`),_(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&_(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),f!=null&&_(f.rank===4||f.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${f.rank}.`),Lp(l,u,c,f,h,i)}const X3=tt({batchNorm4d_:j3});function K3(n,t,e){const s=B(n,"x","bincount"),o=B(t,"weights","bincount");_(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),_(e>=0,()=>`size must be non-negative, but got ${e}.`),_(o.size===s.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${o.shape}.`);const i={x:s,weights:o},l={size:e};return Z.runKernel(q0,i,l)}const Y3=tt({bincount_:K3});function Z3(n,t){let e=B(n,"broadcastTo","x");const s=e.shape;if(da(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const h=e.shape.slice();for(;h.length<t.length;)h.unshift(1);e=J(e,h)}const o=e.shape,i=Array.from(t);for(let h=t.length-1;h>=0;h--)if(o[h]===t[h])i[h]=1;else if(e.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(i.map((h,f)=>h>1?f:-1).filter(h=>h>=0).length===0)return Bi(e);const u={x:e},c={reps:i};return Z.runKernel(Xc,u,c)}const Uu=tt({broadcastTo_:Z3});function Q3(n){const e={x:B(n,"x","ceil","float32")};return Z.runKernel(uc,e)}const J3=tt({ceil_:Q3});function Bp(n,t,e){da(n),e=e||yl(t);const s={shape:n,value:t,dtype:e};return Z.runKernel(rb,{},s)}function tF(n,t,e){const s=B(n,"x","clipByValue");if(_(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return Bp(s.shape,t,s.dtype);const o={x:s},i={clipValueMin:t,clipValueMax:e};return Z.runKernel(cc,o,i)}const Ts=tt({clipByValue_:tF});function eF(n){return Xn(n,0)}const nF=tt({concat1d_:eF});function sF(n,t){return Xn(n,t)}const oF=tt({concat2d_:sF});function aF(n,t){return Xn(n,t)}const iF=tt({concat3d_:aF});function rF(n,t){return Xn(n,t)}const lF=tt({concat4d_:rF});function uF(n,t,e,s,o="NHWC",i=[1,1],l){const u=B(n,"x","conv2d","float32"),c=B(t,"filter","conv2d","float32");let h=u,f=!1;u.rank===3&&(f=!0,h=J(u,[1,u.shape[0],u.shape[1],u.shape[2]])),_(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),_(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),Zn("conv2d",s,l);const p=o==="NHWC"?h.shape[3]:h.shape[1];_(p===c.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${c.shape[2]}.`),_(Dn(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),_(ji(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),_(ji(e),()=>"Error in conv2D: Strides should be larger than 0.");const g={x:h,filter:c},x={strides:e,pad:s,dataFormat:o,dilations:i,dimRoundingMode:l},b=Z.runKernel(Gf,g,x);return f?J(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Xi=tt({conv2d_:uF});function cF(n,t,e,s,o="NWC",i=1,l){const u=B(n,"x","conv1d"),c=B(t,"filter","conv1d");let h=u,f=!1;u.rank===2&&(f=!0,h=J(u,[1,u.shape[0],u.shape[1]])),_(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),_(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),Zn("conv1d",s,l),_(h.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${c.shape[1]}.`),_(Dn(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),_(ji(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),_(ji(e),()=>"Error in conv1D: Stride should be larger than 0."),_(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);const p=J(c,[1,c.shape[0],c.shape[1],c.shape[2]]),g=J(h,[h.shape[0],1,h.shape[1],h.shape[2]]),S=Xi(g,p,[1,e],s,"NHWC",[1,i],l);return f?J(S,[S.shape[2],S.shape[3]]):J(S,[S.shape[0],S.shape[2],S.shape[3]])}const mT=tt({conv1d_:cF});function hF(n,t,e,s,o,i="NHWC",l){_(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let u=n,c=t,h=!1;t.rank===3&&(h=!0,c=J(t,[1,t.shape[0],t.shape[1],t.shape[2]]),u=[1,n[0],n[1],n[2]]),_(u.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${u.length}.`),_(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),_(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const f=i==="NHWC"?u[3]:u[1],p=i==="NHWC"?c.shape[3]:c.shape[1];_(f===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${f}) must match input depth for filter ${e.shape[2]}.`),_(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),Zn("conv2dDerInput",o,l);const g={dy:c,filter:e},x={strides:s,pad:o,dataFormat:i,dimRoundingMode:l,inputShape:u},b=Z.runKernel(Wf,g,x);return h?J(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const _b=tt({conv2DBackpropInput_:hF});function dF(n,t,e,s,o,i){const l=B(n,"x","conv2dTranspose"),u=B(t,"filter","conv2dTranspose");return _b(e,l,u,s,o,"NHWC",i)}const gT=tt({conv2dTranspose_:dF});function fF(n,t,e,s,o="NDHWC",i=[1,1,1]){const l=B(n,"x","conv3d"),u=B(t,"filter","conv3d");let c=l,h=!1;l.rank===4&&(h=!0,c=J(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),_(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),_(u.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${u.rank}.`),_(c.shape[4]===u.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${u.shape[3]}.`),_(Dn(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),_(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`),_(ji(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),_(ji(e),()=>"Error in conv3D: Strides should be larger than 0.");const f={x:c,filter:u},p={strides:e,pad:s,dataFormat:o,dilations:i},g=Z.runKernel(Hf,f,p);return h?J(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const pF=tt({conv3d_:fF});function mF(n,t,e,s,o){_(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,l=t,u=!1;t.rank===4&&(u=!0,l=J(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const c=i[4],h=l.shape[4];_(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),_(l.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${l.rank}`),_(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),_(c===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[3]}.`),_(h===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[4]}.`);const f={dy:l,filter:e},p={pad:o,strides:s,inputShape:i},g=Z.runKernel(Z0,f,p);return u?J(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const xT=tt({conv3DBackpropInput_:mF});function gF(n,t,e,s,o){const i=B(n,"x","conv3dTranspose"),l=B(t,"filter","conv3dTranspose");return xT(e,i,l,s,o)}const xF=tt({conv3dTranspose_:gF});function bF(n){const e={x:B(n,"x","cos","float32")};return Z.runKernel(hc,e)}const Fb=tt({cos_:bF});function yF(n){const e={x:B(n,"x","cosh","float32")};return Z.runKernel(dc,e)}const bT=tt({cosh_:yF});function vF(n,t=0,e=!1,s=!1){const i={x:B(n,"x","cumprod")},l={axis:t,exclusive:e,reverse:s};return Z.runKernel(Q0,i,l)}const p0=tt({cumprod_:vF});function wF(n,t=0,e=!1,s=!1){const i={x:B(n,"x","cumsum")},l={axis:t,exclusive:e,reverse:s};return Z.runKernel(qf,i,l)}const yT=tt({cumsum_:wF});function SF(n,t,e,s=!1){const o=B(n,"x","denseBincount"),i=B(t,"weights","denseBincount");_(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),_(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),_(e>=0,()=>`size must be non-negative, but got ${e}.`),_(i.size===o.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${i.shape}.`);const l={x:o,weights:i},u={size:e,binaryOutput:s};return Z.runKernel(tb,l,u)}const BC=tt({denseBincount_:SF});function CF(n,t,e="NHWC"){const s=B(n,"x","depthToSpace","float32"),o=e==="NHWC"?s.shape[1]:s.shape[2],i=e==="NHWC"?s.shape[2]:s.shape[3],l=e==="NHWC"?s.shape[3]:s.shape[1];_(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),_(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${s.shape}`),_(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${s.shape}`),_(l%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${l} for depthToSpace with input shape ${s.shape}`);const u={x:s},c={blockSize:t,dataFormat:e};return Z.runKernel(eb,u,c)}const $F=tt({depthToSpace_:CF});function TF(n,t,e,s,o="NHWC",i=[1,1],l){const u=B(n,"x","depthwiseConv2d","float32"),c=B(t,"filter","depthwiseConv2d","float32");let h=u,f=!1;u.rank===3&&(f=!0,h=J(u,[1,u.shape[0],u.shape[1],u.shape[2]])),_(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),_(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const p=o==="NHWC"?h.shape[3]:h.shape[1];_(p===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${c.shape[2]}.`),Zn("depthwiseConv2d",s,l);const g={x:h,filter:c},x={strides:e,pad:s,dataFormat:o,dilations:i,dimRoundingMode:l},b=Z.runKernel(jf,g,x);return f?J(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Mb=tt({depthwiseConv2d_:TF});function kF(n,t,e,s,o=[1,1],i="NHWC"){const l=B(n,"x","dilation2d"),u=B(t,"filter","dilation2d");_(l.rank===3||l.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${l.rank}.`),_(u.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${u.rank}.`),_(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let c=l,h=!1;l.rank===3&&(c=J(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=!0),_(c.shape[3]===u.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${u.shape[2]}`);const f={x:c,filter:u},p={strides:e,pad:s,dilations:o},g=Z.runKernel(Xf,f,p);return h?J(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const IF=tt({dilation2d_:kF});function cl(n,t){const e=n.length,s=[];for(let o=0;o<e;o++){const i=e-1-o,l=n[i]||1;(t[t.length-1-o]||1)>1&&l===1&&s.unshift(i)}return s}function un(n,t){const e=[];for(let s=0;s<t.length;s++){const o=n[n.length-s-1],i=t.length-s-1,l=t[i];(o==null||o===1&&l>1)&&e.unshift(i)}return e}function Ut(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let o=0;o<e;o++){let i=n[n.length-o-1];i==null&&(i=1);let l=t[t.length-o-1];if(l==null&&(l=1),i===1)s[e-o-1]=l;else if(l===1)s[e-o-1]=i;else if(i!==l){const u=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(u)}else s[e-o-1]=i}return s}function NF(n,t){let e=B(n,"a","equal","string_or_numeric"),s=B(t,"b","equal","string_or_numeric");[e,s]=He(e,s),Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(Kf,o)}const Oo=tt({equal_:NF});function EF(n,t,e){const s=B(t,"a","where"),o=B(e,"b","where"),i=B(n,"condition","where","bool"),l=Ut(Ut(i.shape,s.shape),o.shape),u=Uu(i,l),c=Uu(s,l),h=Uu(o,l),f={condition:u,t:c,e:h};return Z.runKernel(Tp,f)}const Bn=tt({where_:EF});function RF(n){const e={x:B(n,"x","zerosLike")};return Z.runKernel(Op,e)}const te=tt({zerosLike_:RF});function AF(n,t){let e=B(n,"a","div"),s=B(t,"b","div");[e,s]=He(e,s);const o=Ot(e,s),i=te(o),l=Oo(s,i);return Bn(l,i,o)}const DF=tt({divNoNan_:AF});function OF(n,t){const e=B(n,"t1","dot"),s=B(t,"t2","dot");_((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const o=e.rank===1?e.size:e.shape[1],i=s.rank===1?s.size:s.shape[0];if(_(o===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${i}.`),e.rank===1&&s.rank===1){const l=J(e,[1,-1]),u=J(s,[-1,1]),c=le(l,u);return J(c,[])}else if(e.rank===1&&s.rank===2){const l=J(e,[1,-1]),u=J(s,[s.shape[0],s.shape[1]]),c=le(l,u);return J(c,[c.size])}else if(e.rank===2&&s.rank===1){const l=J(s,[-1,1]),u=le(e,l);return J(u,[u.size])}else{const l=J(s,[s.shape[0],s.shape[1]]);return le(e,l)}}const _F=tt({dot_:OF});function FF(n,...t){const e=t.map((o,i)=>B(o,`tensors${i}`,"einsum")),s={equation:n};return Z.runKernel(ob,e,s)}const Ru=tt({einsum_:FF});function MF(n){const e={x:B(n,"x","elu","float32")};return Z.runKernel(pc,e)}const Up=tt({elu_:MF});function zF(n){let t=B(n,"x","erf");_(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=$t(t,"float32"));const e={x:t};return Z.runKernel(mc,e)}const vT=tt({erf_:zF});function zb(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function wT(n,t,e){const s=n.length+t.length,o=[];let i=0,l=0;for(let u=0;u<s;u++)e.indexOf(u)===-1?o.push(n[i++]):o.push(t[l++]);return o}function gn(n,t){const e=[],s=n.length;for(let i=0;i<s;i++)t.indexOf(i)===-1&&e.push(n[i]);const o=t.map(i=>n[i]);return[e,o]}function Qe(n,t){const e=t.map(s=>1);return wT(n,e,t)}function Sn(n,t,e){_(zb(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Be(n,t){if(zb(n,t))return null;const e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function ai(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function qe(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}function LF(n,t=null,e=!1){const o={x:B(n,"x","max")},i={reductionIndices:t,keepDims:e};return Z.runKernel(rp,o,i)}const lo=tt({max_:LF});function BF(n,t=null,e=!1){const o={x:B(n,"x","min")},i={axis:t,keepDims:e};return Z.runKernel(hp,o,i)}const cf=tt({min_:BF});function UF(n,t){let e=B(n,"base","pow"),s=B(t,"exp","pow");[e,s]=He(e,s);const o={a:e,b:s};return Z.runKernel(Ac,o)}const Ki=tt({pow_:UF});function ue(n,t){if((Hs(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Hs(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Mp(n,[],[],t)}function VF(n){const e={x:B(n,"x","sqrt","float32")};return Z.runKernel(Gc,e)}const An=tt({sqrt_:VF});function PF(n){const t=B(n,"x","square"),e={};return Z.runKernel("Square",{x:t},e)}const Ae=tt({square_:PF});function GF(n,t=null,e=!1){let s=B(n,"x","sum");s.dtype==="bool"&&(s=$t(s,"int32"));const o={x:s},i={axis:t,keepDims:e};return Z.runKernel(Ip,o,i)}const At=tt({sum_:GF});function WF(n,t="euclidean",e=null,s=!1){n=B(n,"x","norm");const o=ST(n,t,e);let i=o.shape;if(s){const l=qt(e,n.shape);i=Qe(o.shape,l)}return J(o,i)}function ST(n,t,e=null){if(n.rank===0)return Mn(n);if(n.rank!==1&&e===null)return ST(J(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return At(Mn(n),e);if(t===1/0)return lo(Mn(n),e);if(t===-1/0)return cf(Mn(n),e);if(t==="euclidean"||t===2)return An(At(Ki(Mn(n),ue(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return lo(At(Mn(n),e[0]),e[1]-1);if(t===1/0)return lo(At(Mn(n),e[1]),e[0]);if(t===-1/0)return cf(At(Mn(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return An(At(Ae(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Vp=tt({norm_:WF});function HF(n,t=null,e=!1){return Vp(n,"euclidean",t,e)}const qF=tt({euclideanNorm_:HF});function jF(n){const e={x:B(n,"x","exp")};return Z.runKernel(gc,e)}const _o=tt({exp_:jF});function XF(n,t=0){const e=B(n,"x","expandDims","string_or_numeric");_(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},o={dim:t};return Z.runKernel(Yf,s,o)}const qn=tt({expandDims_:XF});function KF(n){const e={x:B(n,"x","expm1")};return Z.runKernel(xc,e)}const YF=tt({expm1_:KF});function ZF(n,t){const e=B(n,"x","tile","string_or_numeric");_(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},o={reps:t};return Z.runKernel(Xc,s,o)}const io=tt({tile_:ZF});function QF(n,t,e,s="float32"){t==null&&(t=n);const o=Ht([n,t],s),i=n<=t?n:t;for(let u=0;u<i;++u)o.set(1,u,u);const l=J(o.toTensor(),[n,t]);if(e==null)return l;if(e.length===1)return io(qn(l,0),[e[0],1,1]);if(e.length===2)return io(qn(qn(l,0),0),[e[0],e[1],1,1]);if(e.length===3)return io(qn(qn(qn(l,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const CT=tt({eye_:QF});function JF(n){const e={x:B(n,"x","floor","float32")};return Z.runKernel(bc,e)}const Pp=tt({floor_:JF});function tM(n,t,e=0,s=0){const o=B(n,"x","gather"),i=B(t,"indices","gather","int32"),l={x:o,indices:i},u={axis:e,batchDims:s};return Z.runKernel(Qf,l,u)}const Lb=tt({gather_:tM});function eM(n,t){let e=B(n,"a","greater","string_or_numeric"),s=B(t,"b","greater","string_or_numeric");[e,s]=He(e,s),Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(Jf,o)}const ks=tt({greater_:eM});function nM(n,t){let e=B(n,"a","greaterEqual","string_or_numeric"),s=B(t,"b","greaterEqual","string_or_numeric");[e,s]=He(e,s),Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(vc,o)}const sr=tt({greaterEqual_:nM});function sM(n){const e={input:B(n,"input","imag")};return Z.runKernel(cb,e)}const Bb=tt({imag_:sM});function oM(n){const e={x:B(n,"x","isFinite")};return Z.runKernel(Sc,e)}const aM=tt({isFinite_:oM});function iM(n){const e={x:B(n,"x","isInf")};return Z.runKernel(Cc,e)}const rM=tt({isInf_:iM});function lM(n){const e={x:B(n,"x","isNaN")};return Z.runKernel($c,e)}const uM=tt({isNaN_:lM});function cM(n,t=.2){const s={x:B(n,"x","leakyRelu")},o={alpha:t};return Z.runKernel(tp,s,o)}const Ub=tt({leakyRelu_:cM});function hM(n,t){let e=B(n,"a","less","string_or_numeric"),s=B(t,"b","less","string_or_numeric");[e,s]=He(e,s),Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(ep,o)}const hf=tt({less_:hM});function dM(n,t){let e=B(n,"a","lessEqual","string_or_numeric"),s=B(t,"b","lessEqual","string_or_numeric");[e,s]=He(e,s),Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(np,o)}const Cl=tt({lessEqual_:dM});function fM(n,t=5,e=1,s=1,o=.5){const i=B(n,"x","localResponseNormalization");_(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),_(rl(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let l=i,u=!1;i.rank===3&&(u=!0,l=J(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const c={x:l},h={depthRadius:t,bias:e,alpha:s,beta:o},f=Z.runKernel(ip,c,h);return u?J(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const pM=tt({localResponseNormalization_:fM});function mM(n){const e={x:B(n,"x","log","float32")};return Z.runKernel(Tc,e)}const Fo=tt({log_:mM});function gM(n){const e={x:B(n,"x","log1p")};return Z.runKernel(kc,e)}const $T=tt({log1p_:gM});function xM(n,t){_(Jx(n),()=>"The f passed in variableGrads(f) must be a function"),_(t==null||Array.isArray(t)&&t.every(h=>h instanceof lf),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const h in Z.registeredVariables)t.push(Z.registeredVariables[h])}const s=e?t.filter(h=>!h.trainable):null,o=t.length;t=t.filter(h=>h.trainable),_(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);const i=!0,{value:l,grads:u}=Z.gradients(n,t,null,i);_(u.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),_(l.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${l.rank} tensor`);const c={};return t.forEach((h,f)=>{u[f]!=null&&(c[h.name]=u[f])}),s?.forEach(h=>c[h.name]=null),{value:l,grads:c}}function hl(n){return Z.customGrad(n)}function bM(n){const e={x:B(n,"x","neg")};return Z.runKernel(fp,e)}const We=tt({neg_:bM});function yM(n){const e={x:B(n,"x","softplus")};return Z.runKernel(Pc,e)}const Zc=tt({softplus_:yM});function vM(n){const t=B(n,"x","logSigmoid");return hl(s=>({value:We(Zc(We(s))),gradFunc:l=>K(l,Sl(We(s)))}))(t)}const wM=tt({logSigmoid_:vM});function SM(n,t){let e=B(n,"a","sub"),s=B(t,"b","sub");[e,s]=He(e,s);const o={a:e,b:s};return Z.runKernel(Hc,o)}const Ft=tt({sub_:SM});function CM(n,t=-1){const e=B(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return hl((o,i)=>{const u=lo(o,t,!0),c=Ft(o,u),h=Ft($t(c,"float32"),Fo(At(_o(c),t,!0)));return i([h]),{value:h,gradFunc:(p,g)=>{const[x]=g,b=!0,v=_o(x);return Ft(p,K(At(p,t,b),v))}}})(e)}const TT=tt({logSoftmax_:CM});function $M(n,t=null,e=!1){const s=B(n,"x","logSumExp"),o=qt(t,s.shape),i=lo(s,o,!0),l=Ft(s,i),u=_o(l),c=At(u,o),h=Fo(c),f=vt(J(i,h.shape),h);if(e){const p=Qe(f.shape,o);return J(f,p)}return f}const kT=tt({logSumExp_:$M});function TM(n,t){const e=B(n,"a","logicalAnd","bool"),s=B(t,"b","logicalAnd","bool");Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(sp,o)}const la=tt({logicalAnd_:TM});function kM(n){const e={x:B(n,"x","logicalNot","bool")};return Z.runKernel(op,e)}const Vb=tt({logicalNot_:kM});function IM(n,t){const e=B(n,"a","logicalOr","bool"),s=B(t,"b","logicalOr","bool");Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(ap,o)}const IT=tt({logicalOr_:IM});function NM(n,t){const e=B(n,"a","logicalXor","bool"),s=B(t,"b","logicalXor","bool");return Ut(e.shape,s.shape),la(IT(n,t),Vb(la(n,t)))}const EM=tt({logicalXor_:NM});function RM(n,t,e,s,o){const i=B(n,"x","maxPool"),l=1;let u=i,c=!1;i.rank===3&&(c=!0,u=J(i,[1,i.shape[0],i.shape[1],i.shape[2]])),_(u.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.rank}.`),_(Dn(e,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${l}'`),Zn("maxPool",s,o);const h={x:u},f={filterSize:t,strides:e,pad:s,dimRoundingMode:o},p=Z.runKernel(lp,h,f);return c?J(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Pb=tt({maxPool_:RM});function AM(n,t=[1,1,1],e,s,o,i="NDHWC"){const l=B(n,"x","maxPool3d");let u=l,c=!1;l.rank===4&&(c=!0,u=J(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),_(u.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${u.rank}.`),_(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Zn("maxPool3d",s,o);const h={x:u},f={filterSize:t,strides:e,pad:s,dimRoundingMode:o,dataFormat:i},p=Z.runKernel(up,h,f);return c?J(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const DM=tt({maxPool3d_:AM});function OM(n,t){let e=B(n,"a","maximum"),s=B(t,"b","maximum");[e,s]=He(e,s),e.dtype==="bool"&&(e=$t(e,"int32"),s=$t(s,"int32")),Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(Ic,o)}const ii=tt({maximum_:OM});function _M(n,t=null,e=!1){const o={x:B(n,"x","mean")},i={axis:t,keepDims:e};return Z.runKernel(cp,o,i)}const Ze=tt({mean_:_M});function pn(n,t="float32"){if(da(n),t==="complex64"){const s=pn(n,"float32"),o=pn(n,"float32");return Gi(s,o)}const e=Rn(dt(n),t);return Z.makeTensor(e,n,t)}function ri(n,t="float32"){if(da(n),t==="complex64"){const s=ri(n,"float32"),o=pn(n,"float32");return Gi(s,o)}const e=L0(dt(n),t);return Z.makeTensor(e,n,t)}function FM(n,t){let e=B(n,"a","minimum"),s=B(t,"b","minimum");[e,s]=He(e,s),e.dtype==="bool"&&(e=$t(e,"int32"),s=$t(s,"int32")),Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(Nc,o)}const Hu=tt({minimum_:FM});function MM(n,t,e){_(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=B(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");_(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const o=e==="reflect"?1:0;for(let u=0;u<s.rank;u++)_(t[u].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_(t[u][0]>=0&&t[u][0]<=s.shape[u]-o&&t[u][1]>=0&&t[u][1]<=s.shape[u]-o,()=>`Padding in dimension ${u} cannot be greater than or equal to ${s.shape[u]-o} or less than 0 for input of shape ${s.shape}`);const i={paddings:t,mode:e},l={x:s};return Z.runKernel(dp,l,i)}const zM=tt({mirrorPad_:MM});function LM(n,t){let e=B(n,"a","mod"),s=B(t,"b","mod");[e,s]=He(e,s);const o={a:e,b:s};return Z.runKernel(Ec,o)}const BM=tt({mod_:LM});function UM(n,t=null,e=!1){n=B(n,"x","moments");const s=qt(t,n.shape),o=Ze(n,s,e);let i=o.shape;e||(i=Qe(o.shape,s));const l=Ae(Ft($t(n,"float32"),J(o,i))),u=Ze(l,s,e);return{mean:o,variance:u}}const Gb=tt({moments_:UM});function VM(n,t){let e=B(n,"a","notEqual","string_or_numeric"),s=B(t,"b","notEqual","string_or_numeric");[e,s]=He(e,s),Ut(e.shape,s.shape);const o={a:e,b:s};return Z.runKernel(pp,o)}const df=tt({notEqual_:VM});function PM(n,t,e=1,s=0,o="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const l={indices:B(n,"indices","oneHot","int32")},u={dtype:o,depth:t,onValue:e,offValue:s};return Z.runKernel(gp,l,u)}const NT=tt({oneHot_:PM});function GM(n){const e={x:B(n,"x","onesLike")};return Z.runKernel(mp,e)}const qs=tt({onesLike_:GM});function WM(n,t,e=0){const s=B(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:t,constantValue:e},i={x:s};return Z.runKernel(bp,i,o)}const Wb=tt({pad_:WM});function HM(n,t,e){const s=B(n,"x","spaceToBatchND");_(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),_(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),_(s.shape.reduce((l,u,c)=>c>0&&c<=t.length?l&&(u+e[c-1][0]+e[c-1][1])%t[c-1]===0:l,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const o={x:s},i={blockShape:t,paddings:e};return Z.runKernel(Np,o,i)}const Hb=tt({spaceToBatchND_:HM});function qM(n,t,e,s,o,i,l){o==null&&(o=[1,1]),i==null&&(i=1),s===0&&(s="valid");const u=B(n,"x","maxPool");let c=u,h=!1;u.rank===3&&(h=!0,c=J(u,[1,u.shape[0],u.shape[1],u.shape[2]])),_(Dn(i,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${o}'`);const f=js(c.shape,t,i,o,s),p=[f.dilationHeight,f.dilationWidth];let g;s==="same"?g=XM([f.filterHeight,f.filterWidth],p):g=[[0,0],[0,0]];const x=p[0]===1&&p[1]===1,[b,v]=jM([f.inHeight,f.inWidth],p,g),S=x?s:"valid",C=x?c:Hb(c,p,b),k=(e==="avg"?()=>Db(C,t,i,S,l):()=>Pb(C,t,i,S,l))(),T=x?k:Ob(k,p,v);return h?J(T,[T.shape[1],T.shape[2],T.shape[3]]):T}function jM(n,t,e){const s=e.map(f=>f[0]),o=e.map(f=>f[1]),i=n.concat(s,o),l=t.map((f,p)=>(f-i[p]%f)%f),u=o.map((f,p)=>f+l[p]),c=t.map((f,p)=>[s[p],u[p]]),h=t.map((f,p)=>[0,l[p]]);return[c,h]}function XM(n,t){const s=n.map((l,u)=>l+(l-1)*(t[u]-1)).map(l=>l-1),o=s.map(l=>Math.floor(l/2)),i=s.map((l,u)=>l-o[u]);return s.map((l,u)=>[o[u],i[u]])}const KM=tt({pool_:qM});function YM(n,t){const e=B(n,"x","prelu"),s=B(t,"alpha","prelu"),o={x:e,alpha:s};return Z.runKernel(yp,o)}const qb=tt({prelu_:YM});function ZM(n,t=null,e=!1){let s=B(n,"x","prod");s.dtype==="bool"&&(s=$t(s,"int32"));const o={x:s},i={axis:t,keepDims:e};return Z.runKernel(vp,o,i)}const QM=tt({prod_:ZM});var Kd={exports:{}},JM=Kd.exports,UC;function tz(){return UC||(UC=1,(function(n){(function(t,e,s){function o(c){var h=this,f=u();h.next=function(){var p=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=p-(h.c=p|0)},h.c=1,h.s0=f(" "),h.s1=f(" "),h.s2=f(" "),h.s0-=f(c),h.s0<0&&(h.s0+=1),h.s1-=f(c),h.s1<0&&(h.s1+=1),h.s2-=f(c),h.s2<0&&(h.s2+=1),f=null}function i(c,h){return h.c=c.c,h.s0=c.s0,h.s1=c.s1,h.s2=c.s2,h}function l(c,h){var f=new o(c),p=h&&h.state,g=f.next;return g.int32=function(){return f.next()*4294967296|0},g.double=function(){return g()+(g()*2097152|0)*11102230246251565e-32},g.quick=g,p&&(typeof p=="object"&&i(p,f),g.state=function(){return i(f,{})}),g}function u(){var c=4022871197,h=function(f){f=String(f);for(var p=0;p<f.length;p++){c+=f.charCodeAt(p);var g=.02519603282416938*c;c=g>>>0,g-=c,g*=c,c=g>>>0,g-=c,c+=g*4294967296}return(c>>>0)*23283064365386963e-26};return h}e&&e.exports?e.exports=l:this.alea=l})(JM,n)})(Kd)),Kd.exports}var Yd={exports:{}},ez=Yd.exports,VC;function nz(){return VC||(VC=1,(function(n){(function(t,e,s){function o(u){var c=this,h="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var p=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^p^p>>>8},u===(u|0)?c.x=u:h+=u;for(var f=0;f<h.length+64;f++)c.x^=h.charCodeAt(f)|0,c.next()}function i(u,c){return c.x=u.x,c.y=u.y,c.z=u.z,c.w=u.w,c}function l(u,c){var h=new o(u),f=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var g=h.next()>>>11,x=(h.next()>>>0)/4294967296,b=(g+x)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,f&&(typeof f=="object"&&i(f,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=l:this.xor128=l})(ez,n)})(Yd)),Yd.exports}var Zd={exports:{}},sz=Zd.exports,PC;function oz(){return PC||(PC=1,(function(n){(function(t,e,s){function o(u){var c=this,h="";c.next=function(){var p=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(p^p<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,u===(u|0)?c.x=u:h+=u;for(var f=0;f<h.length+64;f++)c.x^=h.charCodeAt(f)|0,f==h.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(u,c){return c.x=u.x,c.y=u.y,c.z=u.z,c.w=u.w,c.v=u.v,c.d=u.d,c}function l(u,c){var h=new o(u),f=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var g=h.next()>>>11,x=(h.next()>>>0)/4294967296,b=(g+x)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,f&&(typeof f=="object"&&i(f,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=l:this.xorwow=l})(sz,n)})(Zd)),Zd.exports}var Qd={exports:{}},az=Qd.exports,GC;function iz(){return GC||(GC=1,(function(n){(function(t,e,s){function o(u){var c=this;c.next=function(){var f=c.x,p=c.i,g,x;return g=f[p],g^=g>>>7,x=g^g<<24,g=f[p+1&7],x^=g^g>>>10,g=f[p+3&7],x^=g^g>>>3,g=f[p+4&7],x^=g^g<<7,g=f[p+7&7],g=g^g<<13,x^=g^g<<9,f[p]=x,c.i=p+1&7,x};function h(f,p){var g,x=[];if(p===(p|0))x[0]=p;else for(p=""+p,g=0;g<p.length;++g)x[g&7]=x[g&7]<<15^p.charCodeAt(g)+x[g+1&7]<<13;for(;x.length<8;)x.push(0);for(g=0;g<8&&x[g]===0;++g);for(g==8?x[7]=-1:x[g],f.x=x,f.i=0,g=256;g>0;--g)f.next()}h(c,u)}function i(u,c){return c.x=u.x.slice(),c.i=u.i,c}function l(u,c){u==null&&(u=+new Date);var h=new o(u),f=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var g=h.next()>>>11,x=(h.next()>>>0)/4294967296,b=(g+x)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,f&&(f.x&&i(f,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=l:this.xorshift7=l})(az,n)})(Qd)),Qd.exports}var Jd={exports:{}},rz=Jd.exports,WC;function lz(){return WC||(WC=1,(function(n){(function(t,e,s){function o(u){var c=this;c.next=function(){var f=c.w,p=c.X,g=c.i,x,b;return c.w=f=f+1640531527|0,b=p[g+34&127],x=p[g=g+1&127],b^=b<<13,x^=x<<17,b^=b>>>15,x^=x>>>12,b=p[g]=b^x,c.i=g,b+(f^f>>>16)|0};function h(f,p){var g,x,b,v,S,C=[],$=128;for(p===(p|0)?(x=p,p=null):(p=p+"\0",x=0,$=Math.max($,p.length)),b=0,v=-32;v<$;++v)p&&(x^=p.charCodeAt((v+32)%p.length)),v===0&&(S=x),x^=x<<10,x^=x>>>15,x^=x<<4,x^=x>>>13,v>=0&&(S=S+1640531527|0,g=C[v&127]^=x+S,b=g==0?b+1:0);for(b>=128&&(C[(p&&p.length||0)&127]=-1),b=127,v=512;v>0;--v)x=C[b+34&127],g=C[b=b+1&127],x^=x<<13,g^=g<<17,x^=x>>>15,g^=g>>>12,C[b]=x^g;f.w=S,f.X=C,f.i=b}h(c,u)}function i(u,c){return c.i=u.i,c.w=u.w,c.X=u.X.slice(),c}function l(u,c){u==null&&(u=+new Date);var h=new o(u),f=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var g=h.next()>>>11,x=(h.next()>>>0)/4294967296,b=(g+x)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,f&&(f.X&&i(f,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=l:this.xor4096=l})(rz,n)})(Jd)),Jd.exports}var tf={exports:{}},uz=tf.exports,HC;function cz(){return HC||(HC=1,(function(n){(function(t,e,s){function o(u){var c=this,h="";c.next=function(){var p=c.b,g=c.c,x=c.d,b=c.a;return p=p<<25^p>>>7^g,g=g-x|0,x=x<<24^x>>>8^b,b=b-p|0,c.b=p=p<<20^p>>>12^g,c.c=g=g-x|0,c.d=x<<16^g>>>16^b,c.a=b-p|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,u===Math.floor(u)?(c.a=u/4294967296|0,c.b=u|0):h+=u;for(var f=0;f<h.length+20;f++)c.b^=h.charCodeAt(f)|0,c.next()}function i(u,c){return c.a=u.a,c.b=u.b,c.c=u.c,c.d=u.d,c}function l(u,c){var h=new o(u),f=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var g=h.next()>>>11,x=(h.next()>>>0)/4294967296,b=(g+x)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,f&&(typeof f=="object"&&i(f,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=l:this.tychei=l})(uz,n)})(tf)),tf.exports}var ef={exports:{}};const hz={},dz=Object.freeze(Object.defineProperty({__proto__:null,default:hz},Symbol.toStringTag,{value:"Module"})),fz=lO(dz);var pz=ef.exports,qC;function mz(){return qC||(qC=1,(function(n){(function(t,e,s){var o=256,i=6,l=52,u="random",c=s.pow(o,i),h=s.pow(2,l),f=h*2,p=o-1,g;function x(T,N,R){var D=[];N=N==!0?{entropy:!0}:N||{};var z=C(S(N.entropy?[T,k(e)]:T??$(),3),D),O=new b(D),F=function(){for(var E=O.g(i),U=c,Y=0;E<h;)E=(E+Y)*o,U*=o,Y=O.g(1);for(;E>=f;)E/=2,U/=2,Y>>>=1;return(E+Y)/U};return F.int32=function(){return O.g(4)|0},F.quick=function(){return O.g(4)/4294967296},F.double=F,C(k(O.S),e),(N.pass||R||function(E,U,Y,X){return X&&(X.S&&v(X,O),E.state=function(){return v(O,{})}),Y?(s[u]=E,U):E})(F,z,"global"in N?N.global:this==s,N.state)}function b(T){var N,R=T.length,D=this,z=0,O=D.i=D.j=0,F=D.S=[];for(R||(T=[R++]);z<o;)F[z]=z++;for(z=0;z<o;z++)F[z]=F[O=p&O+T[z%R]+(N=F[z])],F[O]=N;(D.g=function(E){for(var U,Y=0,X=D.i,q=D.j,L=D.S;E--;)U=L[X=p&X+1],Y=Y*o+L[p&(L[X]=L[q=p&q+U])+(L[q]=U)];return D.i=X,D.j=q,Y})(o)}function v(T,N){return N.i=T.i,N.j=T.j,N.S=T.S.slice(),N}function S(T,N){var R=[],D=typeof T,z;if(N&&D=="object")for(z in T)try{R.push(S(T[z],N-1))}catch{}return R.length?R:D=="string"?T:T+"\0"}function C(T,N){for(var R=T+"",D,z=0;z<R.length;)N[p&z]=p&(D^=N[p&z]*19)+R.charCodeAt(z++);return k(N)}function $(){try{var T;return g&&(T=g.randomBytes)?T=T(o):(T=new Uint8Array(o),(t.crypto||t.msCrypto).getRandomValues(T)),k(T)}catch{var N=t.navigator,R=N&&N.plugins;return[+new Date,t,R,t.screen,k(e)]}}function k(T){return String.fromCharCode.apply(0,T)}if(C(s.random(),e),n.exports){n.exports=x;try{g=fz}catch{}}else s["seed"+u]=x})(typeof self<"u"?self:pz,[],Math)})(ef)),ef.exports}var Ox,jC;function gz(){if(jC)return Ox;jC=1;var n=tz(),t=nz(),e=oz(),s=iz(),o=lz(),i=cz(),l=mz();return l.alea=n,l.xor128=t,l.xorwow=e,l.xorshift7=s,l.xor4096=o,l.tychei=i,Ox=l,Ox}var jb=gz();class ET{constructor(t,e,s,o,i){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const l=i||Math.random();this.random=jb.alea(l.toString())}nextValue(){if(!isNaN(this.nextVal)){const o=this.nextVal;return this.nextVal=NaN,o}let t,e,s=!1;for(;!s;){let o,i,l;do o=2*this.random()-1,i=2*this.random()-1,l=o*o+i*i;while(l>=1||l===0);const u=Math.sqrt(-2*Math.log(l)/l);t=this.mean+this.stdDev*o*u,e=this.mean+this.stdDev*i*u,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class xz{constructor(t=0,e=1,s,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=jb.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function bz(n,t=0,e=1,s,o){if(da(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new ET(t,e,s,!1,o),l=Ht(n,s);for(let u=0;u<l.values.length;u++)l.values[u]=i.nextValue();return l.toTensor()}const yz=tt({randomNormal_:bz});function vz(n,t=0,e=1,s="float32",o){da(n);const i=Ht(n,s),l=new xz(t,e,null,o);for(let u=0;u<i.values.length;u++)i.values[u]=l.nextValue();return i.toTensor()}const Qc=tt({randomUniform_:vz});function qu(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const o={start:n,stop:t,step:e,dtype:s};return Z.runKernel(xb,{},o)}function wz(n){const e={input:B(n,"input","real")};return Z.runKernel(bb,e)}const ff=tt({real_:wz});function Sz(n){const e={x:B(n,"x","reciprocal")};return Z.runKernel(Dc,e)}const Cz=tt({reciprocal_:Sz});function $z(n){const e={x:B(n,"x","relu")};return Z.runKernel(Oc,e)}const or=tt({relu_:$z});function Tz(n){const e={x:B(n,"x","relu6")};return Z.runKernel(_c,e)}const RT=tt({relu6_:Tz});function kz(n,t){const s={x:B(n,"x","reverse")},o={dims:t};return Z.runKernel($p,s,o)}const Yi=tt({reverse_:kz});function Iz(n){const e={x:B(n,"x","round")};return Z.runKernel(Fc,e)}const AT=tt({round_:Iz});function Nz(n){const e={x:B(n,"x","rsqrt","float32")};return Z.runKernel(Mc,e)}const DT=tt({rsqrt_:Nz});function Ez(n){const e={x:B(n,"x","selu")};return Z.runKernel(zc,e)}const OT=tt({selu_:Ez});function Rz(n,t,e,s,o,i=[1,1],l="NHWC"){const u=B(n,"x","separableConv2d"),c=B(t,"depthwiseFilter","separableConv2d"),h=B(e,"pointwiseFilter","separableConv2d");let f=u,p=!1;if(u.rank===3&&(p=!0,f=J(u,[1,u.shape[0],u.shape[1],u.shape[2]])),l==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");_(f.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${f.rank}.`),_(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),_(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),_(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),_(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const g=c.shape[2],x=c.shape[3];_(h.shape[2]===g*x,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${g*x}, but got ${h.shape[2]}.`);const b=Mb(f,c,s,o,l,i),S=Xi(b,h,1,"valid",l);return p?J(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const _T=tt({separableConv2d_:Rz});function Az(n){const e={x:B(n,"x","sign")};return Z.runKernel(Uc,e)}const Dz=tt({sign_:Az});function Oz(n){const e={x:B(n,"x","sin","float32")};return Z.runKernel(Lc,e)}const FT=tt({sin_:Oz});function _z(n){const e={x:B(n,"x","sinh")};return Z.runKernel(Bc,e)}const MT=tt({sinh_:_z});function Fz(n,t,e){const s=B(n,"x","slice1d");return _(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Ne(s,[t],[e])}const Xb=tt({slice1d_:Fz});function Mz(n,t,e){const s=B(n,"x","slice2d");return _(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Ne(s,t,e)}const zT=tt({slice2d_:Mz});function zz(n,t,e){const s=B(n,"x","slice3d");return _(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Ne(s,t,e)}const Kb=tt({slice3d_:zz});function Lz(n,t,e){const s=B(n,"x","slice4d");return _(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Ne(s,t,e)}const pf=tt({slice4d_:Lz});function Bz(n,t=-1){const e=B(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},o={dim:t};return Z.runKernel(Rp,s,o)}const Yb=tt({softmax_:Bz});function Uz(n){_(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return Z.runKernel(ib,t)}const LT=tt({fft_:Uz});function Vz(n){_(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return Z.runKernel(ub,t)}const m0=tt({ifft_:Vz});function Pz(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const o=J(n,[e,t]);s=m0(o)}else{const o=[e,2*(t-1)],i=J(ff(n),[e,t]),l=J(Bb(n),[e,t]),u=Yi(Ne(i,[0,1],[e,t-2]),1),c=K(Yi(Ne(l,[0,1],[e,t-2]),1),ue(-1)),h=Xn([i,u],1),f=Xn([l,c],1),p=J(Gi(h,f),[o[0],o[1]]);s=m0(p)}if(s=ff(s),n.rank===3&&n.shape[0]!==0){const o=s,i=n.shape[0];s=J(s,[i,s.shape[0]/i,s.shape[1]]),o.dispose()}return s}const Gz=tt({irfft_:Pz});function Wz(n,t,e=0){const o={x:B(n,"x","split")},i={numOrSizeSplits:t,axis:e};return Z.runKernel(Ep,o,i)}const $s=tt({split_:Wz});function Hz(n,t){_(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let o;if(t!=null&&t<e){const b=n.shape.map(S=>0),v=n.shape.map(S=>S);v[n.shape.length-1]=t,o=Ne(n,b,v),e=t}else if(t!=null&&t>e){const b=n.shape.map(v=>v);b[n.shape.length-1]=t-e,o=Xn([n,pn(b)],n.shape.length-1),e=t}else o=n;const i=te(o),l=J(Gi(o,i),[s,e]),u=LT(l),c=Math.floor(e/2)+1,h=ff(u),f=Bb(u),p=$s(h,[c,e-c],h.shape.length-1),g=$s(f,[c,e-c],f.shape.length-1),x=o.shape.slice();return x[o.shape.length-1]=c,J(Gi(p[0],g[0]),x)}const qz=tt({rfft_:Hz});function jz(n,t){let e=B(n,"a","squaredDifference"),s=B(t,"b","squaredDifference");[e,s]=He(e,s),Ut(e.shape,s.shape);const o={a:e,b:s},i={};return Z.runKernel(Wc,o,i)}const Xz=tt({squaredDifference_:jz});function Kz(n,t){const e=B(n,"x","squeeze","string_or_numeric");return J(e,ei(e.shape,t).newShape)}const Jc=tt({squeeze_:Kz});function Yz(n,t=0){const e=aT(n,"tensors","stack","string_or_numeric");_(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&_(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,o={axis:t};return Z.runKernel(xp,s,o)}const ua=tt({stack_:Yz});function Zz(n,t=0){const s={x:B(n,"x","step")},o={alpha:t};return Z.runKernel(Kc,s,o)}const th=tt({step_:Zz});function Qz(n,t,e,s,o=0,i=0,l=0,u=0,c=0){const f={x:B(n,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:s,beginMask:o,endMask:i,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:c};return Z.runKernel(Cb,f,p)}const Jz=tt({stridedSlice_:Qz});function tL(n){const e={x:B(n,"x","tan","float32")};return Z.runKernel(qc,e)}const eL=tt({tan_:tL});function ls(n,t){m$(n);const e=Fp(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Mp(n,null,e,t)}function Va(n,t,e){if(m$(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Fp(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Mp(n,t,s,e)}function ar(n,t,e){const s=t.shape.length,o=s>1?t.shape[s-1]:1,i=e.length;let l=1;for(let p=o;p<i;++p)l*=e[p];const u=o<1?1:o,c=dt(t.shape)/u,h=[...Rt(e.slice(0,o)),1],f=dt(e);return{sliceRank:o,numUpdates:c,sliceSize:l,strides:h,outputSize:f}}function nL(n,t=1,e=!0){const s=B(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const o=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);const i={x:s},l={k:t,sorted:e},[u,c]=Z.runKernel($b,i,l);return{values:u,indices:c}}const sL=tt({topk_:nL});function oL(n,t=0,e=1,s,o){if(da(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new ET(t,e,s,!0,o),l=Ht(n,s);for(let u=0;u<l.values.length;u++)l.values[u]=i.nextValue();return l.toTensor()}const BT=tt({truncatedNormal_:oL});function aL(n,t=0){const e=B(n,"x","unique","string_or_numeric");_(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},o={axis:t},[i,l]=Z.runKernel(kb,s,o);return{values:i,indices:l}}const iL=tt({unique_:aL});function rL(n,t,e){const s=B(n,"x","unsortedSegmentSum"),o=B(t,"segmentIds","unsortedSegmentSum","int32");_(rl(e),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:o},l={numSegments:e};return Z.runKernel(Dp,i,l)}const UT=tt({unsortedSegmentSum_:rL});function lL(n,t=0){const e=B(n,"x","unstack","string_or_numeric");_(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},o={axis:t};return Z.runKernel(Ap,s,o)}const Zi=tt({unstack_:lL});function uL(n,t=!0,e,s){return Z.makeVariable(n,t,e,s)}function VT(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const s=Ht(n,"int32"),o=Ht([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const l=s.indexToLoc(e[i]),u=i*n.length;o.values.set(l,u)}return o.toTensor()}function cL(n,t,e){const s=B(n,"x","transpose");if(t==null&&(t=s.shape.map((l,u)=>u).reverse()),_(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(l=>{_(l>=0&&l<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const o={x:s},i={perm:t};return s.dtype==="complex64"?st(()=>{let l=ff(s),u=Bb(s);return l=Z.runKernel(sl,{x:l},i),u=Z.runKernel(sl,{x:u},i),e&&(u=We(u)),Gi(l,u)}):Z.runKernel(sl,o,i)}const Jt=tt({transpose_:cL});function hL(n,t){if(t==null)return n.shape.slice();if(ce(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}function dL(n,t,e,s){const o=B(n,"x","dropout");if(_(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),_(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof sn?o.clone():o;const i=hL(o,e),l=1-t,u=Ot(Pp(vt(Qc(i,0,1,"float32",s),l)),l);return K(o,u)}const fL=tt({dropout_:dL});function pL(n,t,e,s,o,i="NHWC",l){let u=n;n.rank===3&&(u=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;c.rank===3&&(c=J(t,[1,t.shape[0],t.shape[1],t.shape[2]])),_(u.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${u.shape}.`),_(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),_(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const h=i==="NHWC"?u.shape[3]:u.shape[1],f=i==="NHWC"?c.shape[3]:c.shape[1];_(h===e[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${e[2]}.`),_(f===e[3],()=>`Error in conv2dDerFilter: depth of dy (${f}) must match output depth for filter (${e[3]}).`),Zn("conv2dDerFilter",o,l);const p={x:u,dy:c},g={strides:s,pad:o,dataFormat:i,dimRoundingMode:l,filterShape:e};return Z.runKernel(K0,p,g)}const Zb=tt({conv2DBackpropFilter_:pL});function Qb(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return K(n,th(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Jb(n,t){let e=t;const s=un(n.shape,t.shape);return s.length>0&&(e=At(e,s)),J(e,n.shape)}function ty(n,t,e,s){if(t==="linear")return n;if(t==="relu")return or(n);if(t==="elu")return Up(n);if(t==="relu6")return RT(n);if(t==="prelu")return qb(n,e);if(t==="leakyrelu")return Ub(n,s);if(t==="sigmoid")return Sl(n);throw new Error(`Unknown fused activation ${t}.`)}const ey=(n,t)=>!(n>0)||t==="linear";function mL({x:n,filter:t,strides:e,pad:s,dataFormat:o="NHWC",dilations:i=[1,1],dimRoundingMode:l,bias:u,activation:c="linear",preluActivationWeights:h,leakyreluAlpha:f}){if(c=c||"linear",ey(Z.state.gradientDepth,c)===!1){_(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let R=Xi(n,t,e,s,o,i,l);return u!=null&&(R=vt(R,u)),ty(R,c,h,f)}const p=B(n,"x","conv2d","float32"),g=B(t,"filter","conv2d","float32");let x=p,b=!1;p.rank===3&&(b=!0,x=J(p,[1,p.shape[0],p.shape[1],p.shape[2]])),_(x.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${x.rank}.`),_(g.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${g.rank}.`),Zn("fused conv2d",s,l);const v=o==="NHWC"?x.shape[3]:x.shape[1];_(g.shape[2]===v,()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${g.shape[2]}.`),_(Dn(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const S=wn(x.shape,g.shape,e,i,s,l);let C;u!=null&&(C=B(u,"bias","fused conv2d"),[C]=He(C,p),o==="NHWC"?Ut(S.outShape,C.shape):(_(C.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${C.shape.length}.`),_(C.shape.length===0||C.shape[0]===S.outChannels||C.shape[0]===1,()=>`Error in fused conv2d: bias shape (${C.shape}) is not compatible with the number of output channels (${S.outChannels})`)));let $;if(h!=null){const R=h.shape;if(_(R.length<=1||R.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${R.length}.`),R.length===1)_(R[0]===1||R[0]===S.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${R}) is not compatible with the number of output channels (${S.outChannels}).`);else if(R.length===3)try{Ut(R,S.outShape)}catch{const z=`Error in fused conv2d: PReLU activation weights (${R}) is not compatible with the output shape of the conv2d (${S.outShape}).`;throw Error(z)}$=B(h,"prelu weights","fused conv2d")}const k=(R,D)=>{_(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);const[z,O,F,E]=D,U=Qb(R,F,c);_(qi(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const Y=_b(O.shape,U,z,e,s),X=Zb(O,U,z.shape,e,s),q=[Y,X];if(E!=null){const L=Jb(E,U);q.push(L)}return q},T={x,filter:g,bias:C,preluActivationWeights:$},N={strides:e,pad:s,dataFormat:o,dilations:i,dimRoundingMode:l,activation:c,leakyreluAlpha:f};return u==null?hl((D,z,O)=>{let F=Z.runKernel(af,T,N);return O([z,D,F]),b&&(F=J(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:k}})(x,g):hl((D,z,O,F)=>{let E=Z.runKernel(af,T,N);return F([z,D,E,O]),b&&(E=J(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:k}})(x,g,C)}const gL=tt({fusedConv2d_:mL});function xL(n,t,e,s,o,i=[1,1],l){let u=n;n.rank===3&&(u=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;c.rank===3&&(c=J(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:u,dy:c},f={strides:s,pad:o,dimRoundingMode:l,dilations:i,filterShape:e};return Z.runKernel(nb,h,f)}const bL=tt({depthwiseConv2dNativeBackpropFilter_:xL});function yL(n,t,e,s,o,i=[1,1],l){let u=t,c=!1;t.rank===3&&(c=!0,u=J(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:u,filter:e},f={strides:s,pad:o,dimRoundingMode:l,dilations:i,inputShape:n},p=Z.runKernel(sb,h,f);return c?J(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const vL=tt({depthwiseConv2dNativeBackpropInput_:yL});function wL({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:o,activation:i="linear",preluActivationWeights:l,leakyreluAlpha:u=.2}){if(ey(Z.state.gradientDepth,i)===!1){let E=le(n,t,e,s);return o!=null&&(E=vt(E,o)),ty(E,i,l,u)}let c=B(n,"a","fused matMul"),h=B(t,"b","fused matMul");[c,h]=He(c,h);const f=e?c.shape[c.rank-2]:c.shape[c.rank-1],p=s?h.shape[h.rank-1]:h.shape[h.rank-2],g=e?c.shape[c.rank-1]:c.shape[c.rank-2],x=s?h.shape[h.rank-2]:h.shape[h.rank-1],b=c.shape.slice(0,-2),v=h.shape.slice(0,-2),S=dt(b),C=dt(v);_(f===p,()=>`Error in fused matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${c.shape} and ${h.shape} and transposeA=${e} and transposeB=${s} must match.`);const k=Ut(c.shape.slice(0,-2),h.shape.slice(0,-2)).concat([g,x]),T=e?J(c,[S,f,g]):J(c,[S,g,f]),N=s?J(h,[C,x,p]):J(h,[C,p,x]);let R;o!=null&&(R=B(o,"bias","fused matMul"),[R]=He(R,c),Ut(k,R.shape));let D;l!=null&&(D=B(l,"prelu weights","fused matMul"));const z=(E,U)=>{const[Y,X,q,L]=U,P=Qb(J(E,q.shape),q,i);let W,nt;if(!e&&!s?(W=le(P,X,!1,!0),nt=le(Y,P,!0,!1)):!e&&s?(W=le(P,X,!1,!1),nt=le(P,Y,!0,!1)):e&&!s?(W=le(X,P,!1,!0),nt=le(Y,P,!1,!1)):(W=le(X,P,!0,!0),nt=le(P,Y,!0,!0)),o!=null){const it=Jb(L,P);return[W,nt,it]}else return[W,nt]},O={a:T,b:N,bias:R,preluActivationWeights:D},F={transposeA:e,transposeB:s,activation:i,leakyreluAlpha:u};return o==null?hl((U,Y,X)=>{const q=Z.runKernel(of,O,F);return X([U,Y,q]),{value:J(q,k),gradFunc:z}})(T,N):hl((U,Y,X,q)=>{const L=Z.runKernel(of,O,F);return q([U,Y,L,X]),{value:J(L,k),gradFunc:z}})(T,N,R)}const XC=tt({fusedMatMul_:wL});function SL(n,t,e,s,o="bilinear",i=0){const l=B(n,"image","cropAndResize"),u=B(t,"boxes","cropAndResize","float32"),c=B(e,"boxInd","cropAndResize","int32"),h=u.shape[0];_(l.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${l.rank}.`),_(u.rank===2&&u.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${u.shape}.`),_(c.rank===1&&c.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${u.shape}.`),_(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),_(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),_(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);const f={image:l,boxes:u,boxInd:c},p={method:o,extrapolationValue:i,cropSize:s};return Z.runKernel(J0,f,p)}const CL=tt({cropAndResize_:SL});function $L(n){const t=B(n,"image","flipLeftRight","float32");_(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return Z.runKernel(lb,e,{})}const TL=tt({flipLeftRight_:$L});function kL(n){const t=B(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];_(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),_(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const o=new Array(t.rank);return o.fill(1,0,e),o[e]=3,io(t,o)}const IL=tt({grayscaleToRGB_:kL});function NL(n){const t=B(n,"image","RGBToGrayscale"),e=t.rank-1,s=t.shape[e];_(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),_(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const o=t.dtype,i=$t(t,"float32"),l=ls([.2989,.587,.114]);let u;switch(t.rank){case 2:u=Ru("ij,j->i",i,l);break;case 3:u=Ru("ijk,k->ij",i,l);break;case 4:u=Ru("ijkl,l->ijk",i,l);break;case 5:u=Ru("ijklm,m->ijkl",i,l);break;case 6:u=Ru("ijklmn,n->ijklm",i,l);break;default:throw new Error("Not a valid tensor rank.")}return u=qn(u,-1),$t(u,o)}const EL=tt({rgbToGrayscale_:NL});function RL(n,t,e=0,s=.5){const o=B(n,"image","rotateWithOffset","float32");_(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);const i={image:o},l={radians:t,fillValue:e,center:s};return Z.runKernel(Ib,i,l)}const AL=tt({rotateWithOffset_:RL});function $l(n,t,e,s,o,i){s==null&&(s=.5),o==null&&(o=Number.NEGATIVE_INFINITY),i==null&&(i=0);const l=n.shape[0];return e=Math.min(e,l),_(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),_(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),_(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),_(t.rank===1,()=>"scores must be a 1D tensor"),_(t.shape[0]===l,()=>`scores has incompatible shape with boxes. Expected ${l}, but was ${t.shape[0]}`),_(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:o,softNmsSigma:i}}function DL(n,t,e,s=.5,o=Number.NEGATIVE_INFINITY){const i=B(n,"boxes","nonMaxSuppression","float32"),l=B(t,"scores","nonMaxSuppression","float32"),u=$l(i,l,e,s,o);e=u.maxOutputSize,s=u.iouThreshold,o=u.scoreThreshold;const c={maxOutputSize:e,iouThreshold:s,scoreThreshold:o};return Z.runKernel(pb,{boxes:i,scores:l},c)}const OL=tt({nonMaxSuppression_:DL});function _L(n,t,e){const s=FL(n,t,e),o=s<0?-(s+1):s;n.splice(o,0,t)}function FL(n,t,e){return zL(n,t,e||ML)}function ML(n,t){return n>t?1:n<t?-1:0}function zL(n,t,e){let s=0,o=n.length,i=0,l=!1;for(;s<o;){i=s+(o-s>>>1);const u=e(t,n[i]);u>0?s=i+1:(o=i,l=!u)}return l?s:-s-1}function ny(n,t,e,s,o){return ay(n,t,e,s,o,0)}function sy(n,t,e,s,o,i){return ay(n,t,e,s,o,0,!1,i,!0)}function oy(n,t,e,s,o,i){return ay(n,t,e,s,o,i,!0)}function ay(n,t,e,s,o,i,l=!1,u=!1,c=!1){const h=[];for(let S=0;S<t.length;S++)t[S]>o&&h.push({score:t[S],boxIndex:S,suppressBeginIndex:0});h.sort(KC);const f=i>0?-.5/i:0,p=[],g=[];for(;p.length<e&&h.length>0;){const S=h.pop(),{score:C,boxIndex:$,suppressBeginIndex:k}=S;if(C<o)break;let T=!1;for(let N=p.length-1;N>=k;--N){const R=LL(n,$,p[N]);if(R>=s){T=!0;break}if(S.score=S.score*BL(s,f,R),S.score<=o)break}S.suppressBeginIndex=p.length,T||(S.score===C?(p.push($),g.push(S.score)):S.score>o&&_L(h,S,KC))}const x=p.length,b=e-x;u&&b>0&&(p.push(...new Array(b).fill(0)),g.push(...new Array(b).fill(0)));const v={selectedIndices:p};return l&&(v.selectedScores=g),c&&(v.validOutputs=x),v}function LL(n,t,e){const s=n.subarray(t*4,t*4+4),o=n.subarray(e*4,e*4+4),i=Math.min(s[0],s[2]),l=Math.min(s[1],s[3]),u=Math.max(s[0],s[2]),c=Math.max(s[1],s[3]),h=Math.min(o[0],o[2]),f=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),g=Math.max(o[1],o[3]),x=(u-i)*(c-l),b=(p-h)*(g-f);if(x<=0||b<=0)return 0;const v=Math.max(i,h),S=Math.max(l,f),C=Math.min(u,p),$=Math.min(c,g),k=Math.max(C-v,0)*Math.max($-S,0);return k/(x+b-k)}function BL(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function KC(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function UL(n,t,e,s=.5,o=Number.NEGATIVE_INFINITY){const i=B(n,"boxes","nonMaxSuppressionAsync"),l=B(t,"scores","nonMaxSuppressionAsync"),u=$l(i,l,e,s,o);e=u.maxOutputSize,s=u.iouThreshold,o=u.scoreThreshold;const c=await Promise.all([i.data(),l.data()]),h=c[0],f=c[1],{selectedIndices:p}=ny(h,f,e,s,o);return i!==n&&i.dispose(),l!==t&&l.dispose(),ls(p,"int32")}const VL=UL;function PL(n,t,e,s=.5,o=Number.NEGATIVE_INFINITY,i=0){const l=B(n,"boxes","nonMaxSuppression"),u=B(t,"scores","nonMaxSuppression"),c=$l(l,u,e,s,o,i);e=c.maxOutputSize,s=c.iouThreshold,o=c.scoreThreshold,i=c.softNmsSigma;const h={boxes:l,scores:u},f={maxOutputSize:e,iouThreshold:s,scoreThreshold:o,softNmsSigma:i},p=Z.runKernel(gb,h,f);return{selectedIndices:p[0],selectedScores:p[1]}}const GL=tt({nonMaxSuppressionWithScore_:PL});async function WL(n,t,e,s=.5,o=Number.NEGATIVE_INFINITY,i=0){const l=B(n,"boxes","nonMaxSuppressionAsync"),u=B(t,"scores","nonMaxSuppressionAsync"),c=$l(l,u,e,s,o,i);e=c.maxOutputSize,s=c.iouThreshold,o=c.scoreThreshold,i=c.softNmsSigma;const h=await Promise.all([l.data(),u.data()]),f=h[0],p=h[1],{selectedIndices:g,selectedScores:x}=oy(f,p,e,s,o,i);return l!==n&&l.dispose(),u!==t&&u.dispose(),{selectedIndices:ls(g,"int32"),selectedScores:ls(x)}}const HL=WL;function qL(n,t,e,s=.5,o=Number.NEGATIVE_INFINITY,i=!1){const l=B(n,"boxes","nonMaxSuppression"),u=B(t,"scores","nonMaxSuppression"),c=$l(l,u,e,s,o,null),h=c.maxOutputSize,f=c.iouThreshold,p=c.scoreThreshold,g={boxes:l,scores:u},x={maxOutputSize:h,iouThreshold:f,scoreThreshold:p,padToMaxOutputSize:i},b=Z.runKernel(mb,g,x);return{selectedIndices:b[0],validOutputs:b[1]}}const jL=tt({nonMaxSuppressionPadded_:qL});async function XL(n,t,e,s=.5,o=Number.NEGATIVE_INFINITY,i=!1){const l=B(n,"boxes","nonMaxSuppressionAsync"),u=B(t,"scores","nonMaxSuppressionAsync"),c=$l(l,u,e,s,o,null),h=c.maxOutputSize,f=c.iouThreshold,p=c.scoreThreshold,[g,x]=await Promise.all([l.data(),u.data()]),{selectedIndices:b,validOutputs:v}=sy(g,x,h,f,p,i);return l!==n&&l.dispose(),u!==t&&u.dispose(),{selectedIndices:ls(b,"int32"),validOutputs:ue(v,"int32")}}const KL=XL;function YL(n,t,e=!1,s=!1){const o=B(n,"images","resizeBilinear");_(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),_(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),_(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=o,l=!1;o.rank===3&&(l=!0,i=J(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={images:i},c={alignCorners:e,halfPixelCenters:s,size:t},h=Z.runKernel(Cp,u,c);return l?J(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const PT=tt({resizeBilinear_:YL});function ZL(n,t,e=!1,s=!1){const o=B(n,"images","resizeNearestNeighbor");_(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),_(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),_(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),_(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=o,l=!1;o.rank===3&&(l=!0,i=J(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={images:i},c={alignCorners:e,halfPixelCenters:s,size:t},h=Z.runKernel(Sp,u,c);return l?J(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const GT=tt({resizeNearestNeighbor_:ZL});function QL(n,t="binary",e=!1,s=.5){const o=B(n,"image","threshold"),i=.2989,l=.587,u=.114,c=o.shape[0]*o.shape[1];let h=K(ls([s]),255),f,p,g,x;if(_(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),_(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),_(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),_(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[f,p,g]=$s(o,[1,1,1],-1);const S=K(f,i),C=K(p,l),$=K(g,u);x=vt(vt(S,C),$)}else x=n;if(t==="otsu"){const S=Y3($t(AT(x),"int32"),Bu([]),256);h=JL(S,c)}const b=e?Cl(x,h):ks(x,h);return $t(K(b,255),"int32")}function JL(n,t){let e=ls([-1]),s=ls([0]),o=ls([0]),i,l,u,c,h,f;for(let p=0;p<n.size-1;p++){i=Ne(n,0,p+1),l=Ne(n,p+1),h=Ot(At(i),t),f=Ot(At(l),t);const g=At(K(i,qu(0,i.size)));u=Ot(g,At(i));const x=Bp(l.shape,i.size),b=vt(qu(0,l.size),x),v=K(l,b);c=Ot(At(v),At(l));const S=Ft(u,c),C=Ft(u,c),$=K(h,f);o=K(K($,S),C);const k=ks(o,s);s=Bn(k,o,s),e=Bn(k,ls([p]),e)}return e}const t4=tt({threshold_:QL});function e4(n,t,e="nearest",s="constant",o=0,i){const l=B(n,"image","transform","float32"),u=B(t,"transforms","transform","float32");_(l.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${l.rank}.`),_(u.rank===2&&(u.shape[0]===l.shape[0]||u.shape[0]===1)&&u.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),_(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const c={image:l,transforms:u},h={interpolation:e,fillMode:s,fillValue:o,outputShape:i};return Z.runKernel(Tb,c,h)}const n4=tt({transform_:e4});function s4(n,t,e){const s=B(n,"a","bandPart");_(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const o=s.shape,[i,l]=s.shape.slice(-2);let u,c;typeof t=="number"?(_(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),_(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),u=B(t<0?i:t,"numLower","bandPart")):(_(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),u=Bn(hf(t,0),i,Hu(t,i))),typeof e=="number"?(_(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),_(e<=l,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${l}).`),c=B(e<0?l:e,"numUpper","bandPart")):(_(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=Bn(hf(e,0),l,Hu(e,l)));const h=J(qu(0,i,1,"int32"),[-1,1]),f=qu(0,l,1,"int32"),p=Ft(h,f),g=la(Cl(p,u),sr(p,We(c))),x=pn([i,l],s.dtype);return J(ua(Zi(J(s,[-1,i,l])).map(b=>Bn(g,b,x))),o)}const o4=tt({bandPart_:s4});function a4(n){let t;if(Array.isArray(n)){t=!1,_(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const o=n[0].shape[0];for(let i=1;i<n.length;++i)_(n[i].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${o})`)}else t=!0,n=$s(n,n.shape[0],0).map(o=>Jc(o,[0]));_(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let o=0;o<n.length;++o)e.push(Z.tidy(()=>{let i=s[o];if(o>0)for(let l=0;l<o;++l){const u=K(At(K(e[l],i)),e[l]);i=Ft(i,u)}return Ot(i,Vp(i,"euclidean"))}));return t?ua(e,0):e}const i4=tt({gramSchmidt_:a4});function r4(n,t=!1){if(_(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return YC(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((c,h)=>c*h),s=Zi(J(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),o=[],i=[];s.forEach(c=>{const[h,f]=YC(c,t);o.push(h),i.push(f)});const l=J(ua(o,0),n.shape),u=J(ua(i,0),n.shape);return[l,u]}}function YC(n,t=!1){return Z.tidy(()=>{_(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let o=CT(e),i=Bi(n);const l=Va([[1]],[1,1]);let u=Bi(l);const c=e>=s?s:e;for(let h=0;h<c;++h){const f=i,p=u,g=o;[u,i,o]=Z.tidy(()=>{const x=Ne(i,[h,h],[e-h,1]),b=Vp(x),v=Ne(i,[h,h],[1,1]),S=Bn(ks(v,0),Va([[-1]]),Va([[1]])),C=Ft(v,K(S,b)),$=Ot(x,C);$.shape[0]===1?u=Bi(l):u=Xn([l,Ne($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const k=We(Ot(le(S,C),b)),T=Ne(i,[h,0],[e-h,s]),N=K(k,u),R=Jt(u);if(h===0)i=Ft(T,le(N,le(R,T)));else{const O=Ft(T,le(N,le(R,T)));i=Xn([Ne(i,[0,0],[h,s]),O],0)}const D=Jt(N),z=Ne(o,[0,h],[e,o.shape[1]-h]);if(h===0)o=Ft(z,le(le(z,u),D));else{const O=Ft(z,le(le(z,u),D));o=Xn([Ne(o,[0,0],[e,h]),O],1)}return[u,i,o]}),Wt([f,p,g])}return!t&&e>s&&(o=Ne(o,[0,0],[e,s]),i=Ne(i,[0,0],[s,s])),[o,i]})}const l4=tt({qr_:r4});const ra={flipLeftRight:TL,grayscaleToRGB:IL,resizeNearestNeighbor:GT,resizeBilinear:PT,rgbToGrayscale:EL,rotateWithOffset:AL,cropAndResize:CL,nonMaxSuppression:OL,nonMaxSuppressionAsync:VL,nonMaxSuppressionWithScore:GL,nonMaxSuppressionWithScoreAsync:HL,nonMaxSuppressionPadded:jL,nonMaxSuppressionPaddedAsync:KL,threshold:t4,transform:n4},u4={bandPart:o4,gramSchmidt:i4,qr:l4};const c4=new Map,h4=new Map;class Tl{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Ps{constructor(){this.classNameMap={}}static getMap(){return Ps.instance==null&&(Ps.instance=new Ps),Ps.instance}static register(t){Ps.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function bt(n,t,e){_(n.className!=null,()=>"Class being registered does not have the static className property defined."),_(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),_(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=e,o=t+">"+s;return Ps.register(n),c4.set(o,n),h4.set(n,o),n}class li extends Tl{minimize(t,e=!1,s){const{value:o,grads:i}=this.computeGradients(t,s);if(s!=null){const l=s.map(u=>({name:u.name,tensor:i[u.name]}));this.applyGradients(l)}else this.applyGradients(i);return Wt(i),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return xM(t,e)}dispose(){this.iterations_!=null&&Wt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ue(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(li,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class WT extends li{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,o)=>{const i=Z.registeredVariables[s],l=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${s}/accum_grad`,variable:st(()=>te(i).variable(l))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${s}/accum_var`,variable:st(()=>te(i).variable(l))});const u=Array.isArray(t)?t[o].tensor:t[s];if(u==null)return;const c=this.accumulatedGrads[o].variable,h=this.accumulatedUpdates[o].variable;st(()=>{const f=vt(K(c,this.rho),K(Ae(u),1-this.rho)),p=K(Ot(An(vt(h,this.epsilon)),An(vt(c,this.epsilon))),u),g=vt(K(h,this.rho),K(Ae(p),1-this.rho));c.assign(f),h.assign(g);const x=vt(K(p,-this.learningRate),i);i.assign(x)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Wt(this.accumulatedGrads.map(t=>t.variable)),Wt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}class HT extends li{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,o)=>{const i=Z.registeredVariables[s];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${s}/accumulator`,variable:st(()=>Bp(i.shape,this.initialAccumulatorValue).variable(!1))});const l=Array.isArray(t)?t[o].tensor:t[s];if(l==null)return;const u=this.accumulatedGrads[o].variable;st(()=>{const c=vt(u,Ae(l));u.assign(c);const h=vt(K(Ot(l,An(vt(c,Z.backend.epsilon()))),-this.learningRate),i);i.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Wt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}class qT extends li{static get className(){return"Adam"}constructor(t,e,s,o=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],st(()=>{this.accBeta1=ue(e).variable(),this.accBeta2=ue(s).variable()}),o==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);st(()=>{const s=Ft(1,this.accBeta1),o=Ft(1,this.accBeta2);e.forEach((i,l)=>{const u=Z.registeredVariables[i],c=!1;this.accumulatedFirstMoment[l]==null&&(this.accumulatedFirstMoment[l]={originalName:`${i}/m`,variable:st(()=>te(u).variable(c))}),this.accumulatedSecondMoment[l]==null&&(this.accumulatedSecondMoment[l]={originalName:`${i}/v`,variable:st(()=>te(u).variable(c))});const h=Array.isArray(t)?t[l].tensor:t[i];if(h==null)return;const f=this.accumulatedFirstMoment[l].variable,p=this.accumulatedSecondMoment[l].variable,g=vt(K(f,this.beta1),K(h,1-this.beta1)),x=vt(K(p,this.beta2),K(Ae(h),1-this.beta2)),b=Ot(g,s),v=Ot(x,o);f.assign(g),p.assign(x);const S=vt(K(Ot(b,vt(An(v),this.epsilon)),-this.learningRate),u);u.assign(S)}),this.accBeta1.assign(K(this.accBeta1,this.beta1)),this.accBeta2.assign(K(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Wt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Wt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),st(()=>{this.accBeta1.assign(Ki(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ki(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}class jT extends li{static get className(){return"Adamax"}constructor(t,e,s,o=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=o,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],st(()=>{this.iteration=ue(0).variable(),this.accBeta1=ue(e).variable()}),o==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);st(()=>{const s=Ft(1,this.accBeta1),o=Ot(-this.learningRate,vt(K(this.iteration,this.decay),1));e.forEach((i,l)=>{const u=Z.registeredVariables[i],c=!1;this.accumulatedFirstMoment[l]==null&&(this.accumulatedFirstMoment[l]={originalName:`${i}/m`,variable:te(u).variable(c)}),this.accumulatedWeightedInfNorm[l]==null&&(this.accumulatedWeightedInfNorm[l]={originalName:`${i}/v`,variable:te(u).variable(c)});const h=Array.isArray(t)?t[l].tensor:t[i];if(h==null)return;const f=this.accumulatedFirstMoment[l].variable,p=this.accumulatedWeightedInfNorm[l].variable,g=vt(K(f,this.beta1),K(h,1-this.beta1)),x=K(p,this.beta2),b=Mn(h),v=ii(x,b);f.assign(g),p.assign(v);const S=vt(K(Ot(o,s),Ot(g,vt(v,this.epsilon))),u);u.assign(S)}),this.iteration.assign(vt(this.iteration,1)),this.accBeta1.assign(K(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Wt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Wt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class iy extends li{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,o)=>{const i=Array.isArray(t)?t[o].tensor:t[s];if(i==null)return;const l=Z.registeredVariables[s];st(()=>{const u=vt(K(this.c,i),l);l.assign(u)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=No(ue(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class XT extends iy{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=ue(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,o)=>{const i=Z.registeredVariables[s];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${s}/momentum`,variable:st(()=>te(i).variable(!1))});const l=this.accumulations[o].variable,u=Array.isArray(t)?t[o].tensor:t[s];u!=null&&st(()=>{let c;const h=vt(K(this.m,l),u);this.useNesterov?c=vt(K(this.c,vt(u,K(h,this.m))),i):c=vt(K(this.c,h),i),l.assign(h),i.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Wt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class KT extends li{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,o=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,o==null&&(this.epsilon=Z.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,o)=>{const i=Z.registeredVariables[s],l=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${s}/rms`,variable:st(()=>te(i).variable(l))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${s}/momentum`,variable:st(()=>te(i).variable(l))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${s}/mg`,variable:st(()=>te(i).variable(l))});const u=Array.isArray(t)?t[o].tensor:t[s];if(u==null)return;const c=this.accumulatedMeanSquares[o].variable,h=this.accumulatedMoments[o].variable;st(()=>{const f=vt(K(c,this.decay),K(Ae(u),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[o].variable,g=vt(K(p,this.decay),K(u,1-this.decay)),x=Ot(K(u,this.learningRate),An(Ft(f,vt(Ae(g),this.epsilon)))),b=vt(K(h,this.momentum),x);c.assign(f),p.assign(g),h.assign(b);const v=Ft(i,b);i.assign(v)}else{const p=vt(K(c,this.decay),K(Ae(u),1-this.decay)),g=vt(K(h,this.momentum),Ot(K(u,this.learningRate),An(vt(p,this.epsilon))));c.assign(p),h.assign(g);const x=Ft(i,g);i.assign(x)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Wt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Wt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Wt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const d4=[WT,HT,qT,jT,XT,KT,iy];function f4(){for(const n of d4)bt(n)}function ZC(n,t,e,s){l(n),e=e??0,s=s??1,u(e,s);let o=0;const i=c=>(c.then(h=>{const f=e+ ++o/n.length*(s-e);return t(f),h}),c);function l(c){_(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function u(c,h){_(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),_(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),_(h>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${h}`)}return Promise.all(n.map(i))}async function p4(n,t){t==null&&(t={});const e=t.fetchFunc==null?lt().platform.fetch:t.fetchFunc,s=n.map(p=>e(p,t.requestInit,{isBinary:!0})),u=(t.onProgress==null?await Promise.all(s):await ZC(s,t.onProgress,0,.5)).map(p=>p.arrayBuffer());return t.onProgress==null?await Promise.all(u):await ZC(u,t.onProgress,.5,1)}function m4(n,t){var e;const s=t.fetchFunc==null?lt().platform.fetch:t.fetchFunc;let o=0,i;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async l=>{for(var u;o<n.length;){i||(i=(await s(n[o],t.requestInit,{isBinary:!0})).body.getReader());const{done:c,value:h}=await i.read();if(c){o++,i=void 0,(u=t.onProgress)===null||u===void 0||u.call(t,o/n.length);continue}l.enqueue(h);return}l.close()}})}const g4="application/octet-stream",x4="application/json";class ry{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(_(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=lt().platform.fetch,_(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&_(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o=R_(t,s);if(e.body.append("model.json",new Blob([JSON.stringify(o)],{type:x4}),"model.json"),t.weightData!=null){const l=si.join(t.weightData);e.body.append("model.weights.bin",new Blob([l],{type:g4}),"model.weights.bin")}const i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:Rb(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let l=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}const s=e.modelTopology,o=e.weightsManifest;if(s==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return D_(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),s=zC(t.weightsManifest),o=()=>m4(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:o})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,o]=b4(e),i=this.weightPathPrefix||s,l=[],u=[];for(const c of t)for(const h of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(h)):l.push(i+h+o);return this.weightUrlConverter&&l.push(...await Promise.all(u)),l}async loadWeights(t){const e=await this.getWeightUrls(t),s=zC(t),o=await p4(e,this.loadOptions);return[s,o]}}ry.URL_SCHEME_REGEX=/^https?:\/\//;function b4(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),s=n.substring(0,t),o=e>t?n.substring(e):"";return[s+"/",o]}function QC(n){return n.match(ry.URL_SCHEME_REGEX)!=null}const YT=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(s=>QC(s)):e=QC(n),e)return ZT(n,t)}return null};dn.registerSaveRouter(YT);dn.registerLoadRouter(YT);function ZT(n,t){return new ry(n,t)}function y4(n,t){return ZT(n,t)}class _x{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class v4{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class w4{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function S4(n,t,e,s){const o=arguments;return new w4(C4(...o))}function C4(n,t,e,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new _x(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _x({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _x({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function $4(n){return new v4(n)}function ly(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(dt(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const o=t.shape,i=o[o.length-1];let l=1;for(let p=0;p<o.length-1;++p)l*=o[p];const u=n.shape,c=o.slice();c.pop();let h=1;for(let p=i;p<e;++p)h*=u[p],c.push(u[p]);const f=[...Rt(n.shape).map(p=>p/h),1].slice(0,i);return[c,l,h,f]}const g0=-2,T4=-1;function QT(n,t,e){const s=n.shape.length;_(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),_(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let o=0;o<s;++o)_(t[o]+e[o]<=n.shape[o],()=>`Error in slice${s}D: begin[${o}] + size[${o}] (${t[o]+e[o]}) would overflow input.shape[${o}] (${n.shape[o]})`)}function JT(n,t,e){const s=[];for(let o=0;o<n.length;o++)s[o]=Math.ceil((t[o]-n[o])/e[o]);return s}function tk(n,t,e){let s=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){s=o;break}for(let o=s+1;o<e.length;o++)if(t[o]>0||e[o]!==n[o])return!1;return!0}function ek(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function uy(n,t,e){let s;const o=n.shape.length;typeof t=="number"?s=[t,...new Array(o-1).fill(0)]:t.length<o?s=t.concat(new Array(o-t.length).fill(0)):s=t.slice(),s.forEach(l=>{_(l!==-1,()=>"slice() does not support negative begin indexing.")});let i;return e==null?i=new Array(o).fill(-1):typeof e=="number"?i=[e,...new Array(o-1).fill(-1)]:e.length<o?i=e.concat(new Array(o-e.length).fill(-1)):i=e,i=i.map((l,u)=>l>=0?l:(_(l===-1,()=>`Negative size values should be exactly -1 but got ${l} for the slice() size at index ${u}.`),n.shape[u]-s[u])),[s,i]}function nk(n,t,e,s,o,i,l,u,c){let h;if(s==null?(h=new Array(t.length),h.fill(1)):h=s,l!=null&&(l&l-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let f=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:h.slice(),beginMask:o,endMask:i,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:c};for(let k=0;k<p.dims;k++)f&&(1<<k&u)!==0&&p.numAddAxisAfterEllipsis++,1<<k&l&&(f=!0);f||(p.ellipsisMask|=1<<p.dims,p.dims++);const g={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};k4(p,g);let x=!0,b=!0,v=!0;const S=[],C=[];for(let k=0;k<n.length;++k){if(g.strides[k]===0)throw Error(`strides[${k}] must be non-zero`);const T=!!(g.shrinkAxisMask&1<<k),N=n[k];if(N===-1){S.push(T?1:-1);continue}const R=[g.beginMask&1<<k,g.endMask&1<<k],D=[g.strides[k]>0?0:-1,g.strides[k]>0?N:N-1];if(T&&g.strides[k]<=0)throw Error("only stride 1 allowed on non-range indexing.");v=v&&g.strides[k]===1;const z=!!(g.beginMask&1<<k&&g.endMask&1<<k);if(g.beginValid&&g.endValid){if(T){const U=g.begin[k]<0?N+g.begin[k]:g.begin[k];if(g.begin[k]=U,g.end[k]=g.begin[k]+1,U<0||U>=N)throw Error(`slice index ${g.begin[k]} of dimension ${k} out of bounds.`)}else g.begin[k]=JC(g.begin[k],0,g.strides[k],N,R,D),g.end[k]=JC(g.end[k],1,g.strides[k],N,R,D);const E=g.strides[k]===1&&g.begin[k]===0&&g.end[k]===N;x=x&&E,b=b&&(k===0&&g.strides[k]===1||E)}else x=x&&g.strides[k]===1&&z,b=b&&(k===0&&g.strides[k]===1||z);let O,F=!1;if(g.beginValid&&g.endValid?(O=g.end[k]-g.begin[k],F=!0):T?(O=1,F=!0):z&&N>=0&&(g.strides[k]<0?O=-N:O=N,F=!0),F){let E;O===0||O<0!=g.strides[k]<0?E=0:E=Math.trunc(O/g.strides[k])+(O%g.strides[k]!==0?1:0),S.push(E)}else S.push(-1)}for(let k=0;k<g.finalShapeGatherIndices.length;++k){const T=g.finalShapeGatherIndices[k];T>=0?C.push(S[T]):T===g0&&C.push(1)}return{finalShapeSparse:C.filter((k,T)=>g.finalShapeGatherIndices[T]!==g0),finalShape:C,isIdentity:x,sliceDim0:b,isSimpleSlice:v,begin:g.begin,end:g.end,strides:g.strides}}function k4(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const o=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<o;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(g0),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[s]),n.end!=null&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(T4),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}function JC(n,t,e,s,o,i){if(o[t])return e>0?i[t]:i[t+1&1];{const l=n<0?s+n:n;return l<i[0]?i[0]:l>i[1]?i[1]:l}}class I4{static sgd(t){return new iy(t)}static momentum(t,e,s=!1){return new XT(t,e,s)}static rmsprop(t,e=.9,s=0,o=null,i=!1){return new KT(t,e,s,o,i)}static adam(t=.001,e=.9,s=.999,o=null){return new qT(t,e,s,o)}static adadelta(t=.001,e=.95,s=null){return new WT(t,e,s)}static adamax(t=.002,e=.9,s=.999,o=null,i=0){return new jT(t,e,s,o,i)}static adagrad(t,e=.1){return new HT(t,e)}}const oa=I4;const N4=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function sk(){return new Promise(n=>N4(()=>n()))}function cy(n,t){const e=n[0].length;n.forEach((o,i)=>{_(o.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),_(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((o,i)=>{for(let l=0;l<e;l++)_(l===t||o[l]===s[l],()=>`Error in concat${e}D: Shape of tensors[${i}] (${o}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function Eo(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}var ao;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(ao||(ao={}));function ok(n,t,e){let s=new Array;if(e==null&&t==null)return s;if(t==null)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(e==null)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let o=1;o<e.length;++o){const i=e[o],l=s[s.length-e.length+o],u=s[l];if(i>=0)if(u>=0){if(u!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o+n}] = ${i} but shape[${o+n}] = ${u}`)}else s[l]=i}return s}function ak(n){const t={FIRST_DIM_SIZE:ao.FIRST_DIM_SIZE,VALUE_ROWIDS:ao.VALUE_ROWIDS,ROW_LENGTHS:ao.ROW_LENGTHS,ROW_SPLITS:ao.ROW_SPLITS,ROW_LIMITS:ao.ROW_LIMITS,ROW_STARTS:ao.ROW_STARTS},e=[];for(const s of n)if(s in t)e.push(t[s]);else break;return e}function ik(n){return n.length===0?0:n[0]===ao.FIRST_DIM_SIZE?n.length-1:n.length}function rk(n,t){if(n==null||t==null)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let o=0;o<Math.min(e,s-1);++o){const i=n[o],l=t[o+1];if(i>=0&&l>=0&&i!==1&&i!==l)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o-n.length}] = ${i} but ragged tensor input.flatValues.shape[${o-n.length}] = ${l}`)}}const hy=30;function Gp(n){return n<=hy?n:t0(n,Math.floor(Math.sqrt(n)))}function dy(n,t,e){const s=e*(typeof n=="number"?n:n[0]),o=t*(typeof n=="number"?n:n[1]);return[s,o]}function eh(n,t,e,s=!0){let o=[];if(s)o=o.concat(t.slice(0)),o.push(n[0]/e),o=o.concat(n.slice(1));else{o=o.concat(n[0]);const i=t.length;for(let l=0;l<i;++l)o=o.concat([n[l+1]/t[l],t[l]]);o=o.concat(n.slice(i+1))}return o}function nh(n,t,e=!0){const s=[];if(e){s.push(t);for(let o=t+1;o<n;++o)o<=2*t?(s.push(o),s.push(o-(t+1))):s.push(o)}else{const o=[],i=[];for(let l=1;l<n;++l)l>=t*2+1||l%2===1?i.push(l):o.push(l);s.push(...o),s.push(0),s.push(...i)}return s}function sh(n,t,e,s=!0){const o=[];s?o.push(n[0]/e):o.push(n[0]*e);for(let i=1;i<n.length;++i)i<=t.length?s?o.push(t[i-1]*n[i]):o.push(n[i]/t[i-1]):o.push(n[i]);return o}function fy(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function py(n,t,e){const s=n.slice(0,1);for(let o=0;o<e;++o)s.push(n[o+1]-t[o][0]-t[o][1]);return s}const Wp=1.7580993408473768,Hp=1.0507009873554805;const my=.3275911,gy=.254829592,xy=-.284496736,by=1.421413741,yy=-1.453152027,vy=1.061405429;function ca(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(n.length*2);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function lk(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function uk(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let o=0;o<n.length;o+=4)e[Math.floor(o/4)]=n[o],s[Math.floor(o/4)]=n[o+1];return{real:e,imag:s}}function ck(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let o=2;o<n.length;o+=4)e[Math.floor(o/4)]=n[o],s[Math.floor(o/4)]=n[o+1];return{real:e,imag:s}}function wy(n,t){const e=n[t*2],s=n[t*2+1];return{real:e,imag:s}}function hk(n,t,e,s){n[s*2]=t,n[s*2+1]=e}function dk(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let o=0;o<Math.ceil(n/2);o++){const i=(t?2:-2)*Math.PI*(o/n);e[o]=Math.cos(i),s[o]=Math.sin(i)}return{real:e,imag:s}}function fk(n,t,e){const s=(e?2:-2)*Math.PI*(n/t),o=Math.cos(s),i=Math.sin(s);return{real:o,imag:i}}const Fx="->",E4=/->/g,t2=",",e2="...";function Sy(n,t){n=n.replace(/\s/g,"");const e=(n.length-n.replace(E4,"").length)/Fx.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${Fx}").`);const[s,o]=n.split(Fx);_(s.indexOf(e2)===-1,()=>`The ellipsis notation ("${e2}") is not supported yet.`);const i=s.split(t2),l=i.length;if(t!==l)throw new Error(`Expected ${l} input tensors, received ${t}`);if(l>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const u=[];for(let g=0;g<o.length;++g){const x=o[g];if(!i.some(b=>b.indexOf(x)!==-1))throw new Error(`Output subscripts contain the label ${x} not present in the input subscripts.`);u.indexOf(x)===-1&&u.push(x)}for(let g=0;g<s.length;++g){const x=s[g];u.indexOf(x)===-1&&x!==t2&&u.push(x)}const c=new Array(i.length);for(let g=0;g<l;++g){if(new Set(i[g].split("")).size!==i[g].length)throw new Error(`Found duplicate axes in input component ${i[g]}. Support for duplicate axes in input is not implemented yet.`);c[g]=[];for(let x=0;x<i[g].length;++x)c[g].push(u.indexOf(i[g][x]))}const h=u.length,f=o.length,p=[];for(let g=f;g<h;++g)p.push(g);return{allDims:u,summedDims:p,idDims:c}}function Cy(n,t){let e=new Array(n);e.fill(-1);for(let o=0;o<t.length;++o)e[t[o]]=o;const s=[];for(let o=0;o<n;++o)e[o]===-1&&s.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:s}}function $y(n,t,e){const s=new Array(n);for(let o=0;o<e.length;++o){const i=e[o].shape;for(let l=0;l<t[o].length;++l)s[t[o][l]]===void 0?s[t[o][l]]=i[l]:_(s[t[o][l]]===i[l],()=>`Expected dimension ${s[t[o][l]]} at axis ${l} of input shaped ${JSON.stringify(i)}, but got dimension ${i[l]}`)}}function Ty(n,t){const e=n,s=[];let o=0;n.length===0&&e.push(-1),o=n.length+1;for(let l=0;l<o;++l)s.push([]);const i=[];for(let l=0;l<e.length;++l){const u=e[l],c=R4(t,u);for(const h of c)i.indexOf(h)===-1&&(s[l].push(h),i.push(h))}return{path:e,steps:s}}function ky(n){return n.every((t,e)=>t===e)}function R4(n,t){const e=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(t)!==-1||t===-1)&&e.push(s);return e}function Iy(n,t,e=0){let s=[];if(typeof t=="number")_(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{const o=t.reduce((l,u)=>(u===-1&&(l+=1),l),0);_(o<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(i!==-1){const l=t.reduce((u,c)=>c>0?u+c:u);t[i]=n.shape[e]-l}_(n.shape[e]===t.reduce((l,u)=>l+u),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function pk(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function mk(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function gk(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function xk(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function bk(n,t){return`size ${n} must be non-negative, not ${t}`}function yk(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function vk(n,t){const e=dt(n),s=dt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${t}`}function wk(n,t){const e=dt(n),s=dt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${t}`}function x0(){return"segment ids must be >= 0"}function Sk(){return"segment ids are not increasing"}function Ck(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function $k(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function A4(n,t){let e=!1,s;for(n<=hy?(s=n,e=!0):s=t0(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=t0(n,s+1);return s}function D4(n,t,e){const s=[],o=n.length;for(let i=0;i<o;i++)i!==t?s.push(n[i]):s.push(e);return s}function Tk(n,t,e,s){const o=t.shape.length,i=n.shape.length;if(s!==0&&(s<-o||s>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${s}`);if(s<0&&(s+=o),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let p=0;p<s;++p)if(n.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);const l=n.shape[e],u=[];let c=1,h=1,f=1;for(let p=0;p<s;++p)u.push(n.shape[p]),c*=n.shape[p];for(let p=s;p<e;p++)u.push(n.shape[p]),h*=n.shape[p];for(let p=s;p<o;p++)u.push(t.shape[p]);for(let p=e+1;p<i;p++)u.push(n.shape[p]),f*=n.shape[p];return{batchSize:c,sliceSize:f,outerSize:h,dimSize:l,outputShape:u}}function ha(n){try{return n.map(t=>Ka(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function kk(n){return n.map(t=>qa(t))}const O4=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:gy,ERF_A2:xy,ERF_A3:by,ERF_A4:yy,ERF_A5:vy,ERF_P:my,PARALLELIZE_THRESHOLD:hy,get RowPartitionType(){return ao},SELU_SCALE:Hp,SELU_SCALEALPHA:Wp,applyActivation:ty,assertAndGetBroadcastShape:Ut,assertAxesAreInnerMostDims:Sn,assertParamsConsistent:cy,assignToTypedArray:hk,axesAreInnerMostDims:zb,calculateShapes:ar,checkEinsumDimSizes:$y,checkPadOnDimRoundingMode:Zn,combineLocations:wT,combineRaggedTensorToTensorShapes:ok,complexWithEvenIndex:uk,complexWithOddIndex:ck,computeConv2DInfo:wn,computeConv3DInfo:oi,computeDefaultPad:Ab,computeDilation2DInfo:Yc,computeOptimalWindowSize:Gp,computeOutAndReduceShapes:gn,computeOutShape:Eo,computePool2DInfo:js,computePool3DInfo:fa,convertConv2DDataFormat:pa,decodeEinsumEquation:Sy,eitherStridesOrDilationsAreOne:Dn,expandShapeToKeepDim:Qe,exponent:fk,exponents:dk,fromStringArrayToUint8:kk,fromUint8ToStringArray:ha,getAxesPermutation:Be,getBroadcastDims:cl,getComplexWithIndex:wy,getEinsumComputePath:Ty,getEinsumPermutation:Cy,getFusedBiasGradient:Jb,getFusedDyActivation:Qb,getImageCenter:dy,getInnerMostAxes:qe,getPermuted:nh,getRaggedRank:ik,getReductionAxes:un,getReshaped:eh,getReshapedPermuted:sh,getRowPartitionTypesHelper:ak,getSliceBeginCoords:fy,getSliceSize:py,getSparseFillEmptyRowsIndicesDenseShapeMismatch:pk,getSparseFillEmptyRowsNegativeIndexErrorMessage:mk,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:gk,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:yk,getSparseReshapeInputOutputMismatchErrorMessage:wk,getSparseReshapeInputOutputMultipleErrorMessage:vk,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:xk,getSparseReshapeNegativeOutputDimErrorMessage:bk,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:$k,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:x0,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Sk,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Ck,getUndoAxesPermutation:ai,isIdentityPermutation:ky,mergeRealAndImagArrays:ca,prepareAndValidate:ly,prepareSplitSize:Iy,shouldFuse:ey,splitRealAndImagArrays:lk,stridesOrDilationsArePositive:ji,tupleValuesAreOne:qi,upcastType:us,validateDefaultValueShape:rk,warn:Ss},Symbol.toStringTag,{value:"Module"}));f4();const Ik={kernelName:_f,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(n,th($t(e,"float32"),-1))}}};const _4={kernelName:ec,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Ae($t(e,"float32")),o=An(Ft(ue(1),s));return We(Ot(n,o))}}}};const F4={kernelName:nc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=An(Ft(Ae($t(e,"float32")),1));return Ot(n,s)}}}};const M4={kernelName:wl,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,o=Ut(e.shape,s.shape);return{a:()=>{let u=n;const c=un(e.shape,o);return c.length>0&&(u=At(u,c)),J(u,e.shape)},b:()=>{let u=n;const c=un(s.shape,o);return c.length>0&&(u=At(u,c)),J(u,s.shape)}}}};const z4={kernelName:V0,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,o)=>{e[o]=()=>n.clone()}),e}};const L4={kernelName:Ff,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>te(e)}}};const B4={kernelName:Mf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>te(e)}}};const U4={kernelName:sc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ot(n,An(Ft(ue(1),Ae($t(e,"float32")))))}}};const V4={kernelName:oc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=An(vt(ue(1),Ae($t(e,"float32"))));return Ot(n,s)}}}};const P4={kernelName:rc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,o=Ut(e.shape,s.shape);return{a:()=>{const u=vt(Ae(e),Ae(s));let c=K(n,Ot(s,u));const h=un(e.shape,o);return h.length>0&&(c=At(c,h)),J(c,e.shape)},b:()=>{const u=vt(Ae(e),Ae(s));let c=We(K(n,Ot(e,u)));const h=un(s.shape,o);return h.length>0&&(c=At(c,h)),J(c,s.shape)}}}};const G4={kernelName:ac,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ot(n,vt(Ae($t(e,"float32")),1))}}};const W4={kernelName:ic,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ot(n,Ft(ue(1),Ae($t(e,"float32"))))}}};function H4(n,t,e,s,o,i){const l=B(n,"dy","avgPool3dGrad"),u=B(t,"input","avgPool3dGrad");let c=l,h=u,f=!1;u.rank===4&&(f=!0,c=J(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=J(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),_(c.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),_(h.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),Zn("avgPool3dGrad",o,i);const p={dy:c,input:h},g={filterSize:e,strides:s,pad:o,dimRoundingMode:i},x=Z.runKernel(H0,p,g);return f?J(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}const q4=tt({avgPool3dGrad_:H4});const j4={kernelName:Lf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=e;return{x:()=>q4(n,s,o,i,l,u)}}};function X4(n,t,e,s,o){const i=B(n,"dy","avgPoolGrad"),l=B(t,"input","avgPoolGrad");_(l.rank===i.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`);let u=l,c=i,h=!1;l.rank===3&&(h=!0,u=J(l,[1,l.shape[0],l.shape[1],l.shape[2]]),c=J(i,[1,i.shape[0],i.shape[1],i.shape[2]])),_(c.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),_(u.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${u.rank}.`);const f={dy:c,input:u},p={filterSize:e,strides:s,pad:o},g=Z.runKernel(W0,f,p);return h?J(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const K4=tt({avgPoolGrad_:X4});const Y4={kernelName:zf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:o,strides:i,pad:l}=e;return{x:()=>K4(n,s,o,i,l)}}};const Z4={kernelName:Bf,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,o]=t,{transposeA:i,transposeB:l}=e;return!i&&!l?{a:()=>le(n,o,!1,!0),b:()=>le(s,n,!0,!1)}:!i&&l?{a:()=>le(n,o,!1,!1),b:()=>le(n,s,!0,!1)}:i&&!l?{a:()=>le(o,n,!1,!0),b:()=>le(s,n,!1,!1)}:{a:()=>le(o,n,!0,!0),b:()=>le(n,s,!0,!0)}}};const Q4={kernelName:Uf,gradFunc:(n,t,e)=>{const{blockShape:s,crops:o}=e;return{x:()=>Hb(n,s,o)}}};const J4={kernelName:qO,gradFunc:(n,t,e)=>{const s=e,o=s.inputShape,i=s.shape,l=Array.from(i);for(let c=o.length-1;c>=0;c--)if(o[c]===i[c])l[c]=1;else if(o[c]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${i}].`);const u=[];for(let c=0;c<l.length;c++)l[c]>1&&u.push(c);return{x:()=>At(n,u,!0)}}};const tB={kernelName:lc,gradFunc:n=>({x:()=>n.clone()})};const eB={kernelName:uc,gradFunc:n=>({x:()=>te(n)})};const nB={kernelName:cc,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:o,clipValueMax:i}=e;return{x:()=>Bn(la(sr(s,o),Cl(s,i)),n,te(n))}}};const sB={kernelName:Vf,inputsToSave:["x"],gradFunc:Ik.gradFunc};const oB={kernelName:Pf,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(c=>c.shape),{axis:o}=e,i=qt(o,t[0].shape)[0],l=s.map(c=>c[i]);return $s(n,l,i).map(c=>()=>c)}};const aB={kernelName:Gf,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,o]=t,{dilations:i,strides:l,pad:u,dataFormat:c}=e;return _(qi(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>_b(s.shape,n,o,l,u,c),filter:()=>Zb(s,n,o.shape,l,u,c)}}};const iB={kernelName:Wf,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,o]=t,{strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=e;return{dy:()=>Xi(n,o,i,l,u,1,c),filter:()=>Zb(n,s,o.shape,i,l,u,c)}}};function rB(n,t,e,s,o){let i=n;n.rank===4&&(i=J(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let l=t;l.rank===4&&(l=J(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),_(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),_(l.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${l.shape}.`),_(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),_(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),_(l.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${l.shape[4]}) must match output depth for filter (${e[4]}).`);const u={x:i,dy:l},c={strides:s,pad:o,filterShape:e};return Z.runKernel(Y0,u,c)}const lB=tt({conv3DBackpropFilter_:rB});const uB={kernelName:Hf,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:o,pad:i}=e;_(qi(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[l,u]=t;return{x:()=>xT(l.shape,n,u,o,i),filter:()=>lB(l,n,u.shape,o,i)}}};const cB={kernelName:hc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(We(FT($t(e,"float32"))),n)}}};const hB={kernelName:dc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(MT($t(e,"float32")),n)}}};const dB={kernelName:qf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:o,exclusive:i,reverse:l}=e;return{x:()=>{const u=Be([o],s.rank);let c=yT(n,o,i,!l);return u!=null&&(c=Jt(c,u)),c}}}};const fB={kernelName:jf,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:o,pad:i,dimRoundingMode:l}=e,u=s??[1,1];_(qi(u),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${u}'`);const[c,h]=t;return _(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),_(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${h.rank}.`),_(c.shape[3]===h.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),_(Dn(o,u),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${u}'.`),Zn("depthwiseConv2d",i,l),{x:()=>vL(c.shape,n,h,o,i,u,l),filter:()=>bL(c,n,h.shape,o,i,u,l)}}};const pB={kernelName:Xf,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,o]=t,i={x:s,filter:o,dy:n},l={x:s,filter:o,dy:n};return{x:()=>Z.runKernel(e0,i,e),filter:()=>Z.runKernel(n0,l,e)}}};const mB={kernelName:pc,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>Z.runKernel(ab,s)}}};const gB={kernelName:mc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=K(_o(We(Ae(e))),2/Math.sqrt(Math.PI));return{x:()=>K(n,s)}}};const xB={kernelName:gc,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(n,e)}}};const bB={kernelName:Yf,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>J(n,e.shape)}}};const yB={kernelName:xc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(n,_o(e))}}};const vB={kernelName:bc,gradFunc:n=>({x:()=>te(n)})};const wB={kernelName:yc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,o=Ut(e.shape,s.shape);return{a:()=>{const u=Ot(n,$t(s,"float32")),c=un(e.shape,o);return c.length>0?J(At(u,c),e.shape):u},b:()=>{let u=K(n,$t(e,"float32"));const c=un(s.shape,o);c.length>0&&(u=J(At(u,c),s.shape));const h=Ae(s);return We(Ot(u,$t(h,"float32")))}}}};const SB={kernelName:Zf,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[o,i,l,u]=t,c=u??ue(1),h=un(i.shape,o.shape),f=[];if(i.rank===1){for(let T=0;T<o.shape.length-1;++T)f.push(o.shape[T]);f.push(1)}const p=Ft(o,i),g=K(n,c),x=DT(vt(l,ue(s))),b=K(K(K(x,x),x),ue(-.5));return{x:()=>i.rank===1?J(K(K(n,io(J(x,[1,1,1,i.shape[0]]),f)),c),o.shape):J(K(K(n,x),c),o.shape),mean:()=>{let T=K(K(x,ue(-1)),g);return i.rank===1&&(T=At(T,h)),J(T,i.shape)},variance:()=>{let T=K(K(b,p),g);return i.rank===1&&(T=At(T,h)),J(T,i.shape)},scale:()=>{const T=K(p,x);let N=K(n,T);return i.rank===1&&(N=At(N,h)),J(N,i.shape)},offset:()=>{let T=n;return i.rank===1&&(T=At(T,h)),J(T,i.shape)}}}};const CB={kernelName:Qf,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,o]=t,{axis:i,batchDims:l}=e,u=qt(i,s.shape)[0],c=(h,f,p)=>()=>{const g=h.shape,x=f.size,b=g.slice(0,u),v=b.length,S=g.slice(i,g.length).slice(1),C=S.length,$=n2(0,v),k=n2(v+1,v+1+C),T=s2([b,[x],S]),N=J(p,T),R=J(f,[x]),D=s2([[v],$,k]),z=Jt(N,D);let O=UT(z,R,h.shape[u]);const F=ai(D);return O=Jt(O,F),O};if(l===1){const h=s.shape[0],f=s.split(h,0);return{x:()=>ua(f.map((x,b)=>c(x,o.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>o}}else return{x:c(s,o,n),indices:()=>o}}};function n2(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function s2(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const $B={kernelName:vc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>te(e),b:()=>te(s)}}};const TB={kernelName:wc,gradFunc:n=>({x:()=>$t(n,"float32")})};const kB={kernelName:Sc,gradFunc:n=>({x:()=>te(n)})};const IB={kernelName:Cc,gradFunc:n=>({x:()=>te(n)})};const NB={kernelName:$c,gradFunc:n=>({x:()=>te(n)})};const EB={kernelName:tp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:o}=e,i=ks(s,0);return{x:()=>Bn(i,n,K(n,o))}}};const RB={kernelName:kc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ot(n,vt(e,1))}}};const AB={kernelName:Tc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ot(n,$t(e,"float32"))}}};const DB={kernelName:XO,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:o}=e;return{logits:()=>{const l=_o(s);return Ft(n,K(At(n,o,!0),l))}}}};function OB(n,t,e,s=5,o=1,i=1,l=.5){const u={x:n,y:t,dy:e},c={depthRadius:s,bias:o,alpha:i,beta:l};return Z.runKernel(hb,u,c)}const _B=tt({localResponseNormalizationBackprop_:OB});const FB={kernelName:ip,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,o]=t,{depthRadius:i,bias:l,alpha:u,beta:c}=e;return{x:()=>_B(s,o,n,i,l,u,c)}}};function Nk(n,t,e,s){return t.rank<e.rank&&(t=J(t,Qe(t.shape,s))),n.rank<e.rank&&(n=J(n,Qe(n.shape,s))),{x:()=>K(n,$t(Oo(e,t),n.dtype))}}const o2={kernelName:rp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:o}=s,i=t[0],l=t[1],u=qt(o,i.shape),c=Nk(n,l,i,u);return{x:()=>c.x()}}};const MB={kernelName:Ic,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>K(n,$t(sr(e,s),"float32")),b:()=>K(n,$t(hf(e,s),"float32"))}}};function zB(n,t,e,s,o,i,l){const u=B(n,"dy","maxPool3dGrad"),c=B(t,"input","maxPool3dGrad"),h=B(e,"output","maxPool3dGrad");let f=u,p=c,g=h,x=!1;c.rank===4&&(x=!0,f=J(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=J(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),g=J(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),_(f.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${f.rank}.`),_(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),_(g.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${g.rank}.`),Zn("maxPool3dGrad",i,l);const b={dy:f,input:p,output:g},v={filterSize:s,strides:o,pad:i,dimRoundingMode:l},S=Z.runKernel(fb,b,v);return x?J(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}const LB=tt({maxPool3dGrad_:zB});const BB={kernelName:up,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,o]=t,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=e;return{x:()=>LB(n,s,o,i,l,u,c)}}};function UB(n,t,e,s,o,i,l){const u=B(n,"dy","maxPoolGrad"),c=B(t,"input","maxPoolGrad"),h=B(e,"output","maxPoolGrad");_(c.rank===u.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${u.rank})`),_(u.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),_(c.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),Zn("maxPoolGrad",i,l);const f={dy:u,input:c,output:h},p={filterSize:s,strides:o,pad:i,dimRoundingMode:l};return Z.runKernel(db,f,p)}const VB=tt({maxPoolGrad_:UB});const PB={kernelName:lp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,o]=t,{filterSize:i,strides:l,pad:u}=e;return{x:()=>VB(n,s,o,i,l,u)}}};const GB={kernelName:cp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:o}=e,i=qt(o,s.shape),u=gn(s.shape,i)[1],c=dt(u);return{x:()=>{const f=s.shape.slice();i.forEach(x=>{f[x]=1});const p=J(n,f);return Ot(K(p,ri(s.shape,"float32")),c)}}}};const WB={kernelName:hp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:o}=s,[i,l]=t,u=qt(o,i.shape),c=Nk(n,l,i,u);return{x:()=>c.x()}}};const HB={kernelName:Nc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>K(n,$t(Cl(e,s),"float32")),b:()=>K(n,$t(ks(e,s),"float32"))}}};const qB={kernelName:dp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:o}=e,i=o.map(l=>l[0]);return{x:()=>Ne(n,i,s.shape)}}};const jB={kernelName:Ec,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,o=Ut(e.shape,s.shape);return{a:()=>{const u=un(e.shape,o);return u.length>0?J(At(n,u),e.shape):n},b:()=>{const u=K(n,We(Pp(Ot(e,s)))),c=un(s.shape,o);return c.length>0?J(At(u,c),s.shape):u}}}};const XB={kernelName:Rc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,o=Ut(e.shape,s.shape);return{a:()=>{const u=K(n,$t(s,"float32")),c=un(e.shape,o);return c.length>0?J(At(u,c),e.shape):u},b:()=>{const u=K(n,$t(e,"float32")),c=un(s.shape,o);return c.length>0?J(At(u,c),s.shape):u}}}};const KB={kernelName:fp,gradFunc:n=>({x:()=>We(n)})};const YB={kernelName:gp,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>pn(e.shape,"float32")}}};const ZB={kernelName:mp,gradFunc:n=>({x:()=>te(n)})};const QB={kernelName:xp,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return Zi(n,s).map(i=>()=>i)}};const a2={kernelName:bp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:o}=e,i=o.map(l=>l[0]);return{x:()=>Ne(n,i,s.shape)}}};const JB={kernelName:Ac,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,o]=t,i=e,l=s,u=Ut(i.shape,l.shape);return{a:()=>{const f=$t(l,"float32");let p=K(n,K(f,Ki(i,Ft(f,ue(1)))));const g=un(i.shape,u);return g.length>0&&(p=At(p,g)),J(p,i.shape)},b:()=>{const f=ks(i,0),p=Bn(f,Fo(i),te(i));let g=K(n,K(o,p));const x=un(l.shape,u);return x.length>0&&(g=At(g,x)),J(g,l.shape)}}}};const tU={kernelName:yp,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,o=ks(e,0);return{x:()=>Bn(o,n,K(n,s)),alpha:()=>{let i=Bn(o,te(n),K(n,e));const l=un(s.shape,n.shape);return l.length>0&&(i=At(i,l)),J(i,s.shape)}}}};function eU(n,t,e){const s=n.shape.slice();s[e]=1;const o=J(t,s),i=p0(n,e,!0,!1),l=p0(n,e,!0,!0),u=K(i,l);return K(o,u)}function nU(n,t,e){const s=n.shape.length,o=s-e.length,i=Be(e,s);let l=n;i!=null&&(l=Jt(n,i));const u=l.shape.slice(),h=u.splice(s-e.length,e.length).reduce((g,x)=>g*x,1);u.push(h);const f=l.reshape(u);let p=eU(f,t,o);if(p=p.reshape(l.shape),i!=null){const g=ai(i);p=Jt(p,g)}return p}const sU={kernelName:vp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:o}=e;let i=[];return o==null?i=s.shape.map((l,u)=>u):typeof o=="number"?i=[o]:i=o,{x:()=>nU(s,n,i)}}};const oU={kernelName:fc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,o=Ut(e.shape,s.shape);return{a:()=>{const u=Ot(n,$t(s,"float32")),c=un(e.shape,o);return c.length>0?J(At(u,c),e.shape):u},b:()=>{let u=K(n,$t(e,"float32"));const c=un(s.shape,o);c.length>0&&(u=J(At(u,c),s.shape));const h=Ae(s);return We(Ot(u,$t(h,"float32")))}}}};const aU={kernelName:Dc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ot(n,We(Ae(e)))}}};const iU={kernelName:_c,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=K(Cl(e,6),th(e));return{x:()=>K(n,$t(s,"float32"))}}};const rU={kernelName:Oc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(n,$t(th(e),"float32"))}}};const lU={kernelName:wp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>J(n,e.shape)}}};const uU={kernelName:Cp,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,o={dy:n,images:s};return{images:()=>Z.runKernel(vb,o,e)}}};const cU={kernelName:Sp,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,o={dy:n,images:s};return{images:()=>Z.runKernel(yb,o,e)}}};const hU={kernelName:$p,gradFunc:(n,t,e)=>{const{dims:s}=e,o=qt(s,n.shape);return{x:()=>Yi(n,o)}}};const dU={kernelName:Fc,gradFunc:n=>({x:()=>te(n)})};const fU={kernelName:Mc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>We(Ot(n,K(Ki(e,1.5),2)))}}};const pU={kernelName:Tp,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>$t(te(e),"float32"),t:()=>K(n,$t(e,n.dtype)),e:()=>K(n,$t(Vb(e),n.dtype))}}};const mU={kernelName:zc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ks(e,ue(0)),o=ue(Wp),i=ue(Hp),l=K(n,i),u=K(K(n,o),_o($t(e,"float32")));return Bn(s,l,u)}}}};const gU={kernelName:Vc,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(n,K(e,Ft(ue(1),e)))}}};const xU={kernelName:Uc,gradFunc:n=>({x:()=>te(n)})};const bU={kernelName:Lc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(Fb($t(e,"float32")),n)}}};const yU={kernelName:Bc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(bT($t(e,"float32")),n)}}};const vU={kernelName:kp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:o,size:i}=e,l=s.shape,[u,c]=uy(s,o,i),h=[];for(let f=0;f<n.rank;f++)h.push([u[f],l[f]-u[f]-c[f]]);return{x:()=>Wb(n,h)}}};const wU={kernelName:Rp,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:o}=e,i=!0,l=K(n,s);return{logits:()=>Ft(l,K(At(l,[o],i),s))}}};const SU={kernelName:Pc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(n,Sl(e))}}};const i2={kernelName:Np,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:o}=e;return{x:()=>Ob(n,s,o)}}};const r2={kernelName:Ep,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>Xn(n,s)}}};const CU={kernelName:Gc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ot(n,K(An($t(e,"float32")),2))}}};const $U={kernelName:wb,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(n,K($t(e,"float32"),2))}}};const TU={kernelName:Wc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,o=ue(2);return{a:()=>K(n,K(o,Ft(e,s))),b:()=>K(n,K(o,Ft(s,e)))}}};const kU={kernelName:Kc,gradFunc:n=>({x:()=>te(n)})};const IU={kernelName:Hc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,o=Ut(e.shape,s.shape);return{a:()=>{let u=n;const c=un(e.shape,o);return c.length>0&&(u=At(u,c)),J(u,e.shape)},b:()=>{let u=n;const c=un(s.shape,o);return c.length>0&&(u=At(u,c)),J(We(u),s.shape)}}}};const NU={kernelName:Ip,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,o=s.shape.slice(),{axis:i}=e;qt(i,s.shape).forEach(h=>{o[h]=1});const u=J(n,o),c=K(u,ri(s.shape,"float32"));return{x:()=>c}}};const EU={kernelName:qc,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ot(n,Ae(Fb(e)))}}};const RU={kernelName:jc,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>K(Ft(ue(1),Ae(e)),n)}}};const AU={kernelName:Xc,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:o}=e;return{x:()=>{let l=te(s);if(s.rank===1)for(let u=0;u<o[0];++u)l=vt(l,Ne(n,[u*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let u=0;u<o[0];++u)for(let c=0;c<o[1];++c)l=vt(l,Ne(n,[u*s.shape[0],c*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let u=0;u<o[0];++u)for(let c=0;c<o[1];++c)for(let h=0;h<o[2];++h)l=vt(l,Ne(n,[u*s.shape[0],c*s.shape[1],h*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let u=0;u<o[0];++u)for(let c=0;c<o[1];++c)for(let h=0;h<o[2];++h)for(let f=0;f<o[3];++f)l=vt(l,Ne(n,[u*s.shape[0],c*s.shape[1],h*s.shape[2],f*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return l}}}};const DU={kernelName:sl,gradFunc:(n,t,e)=>{const s=e,{perm:o}=s,i=ai(o);return{x:()=>Jt(n,i)}}};const OU={kernelName:Ap,gradFunc:(n,t,e)=>{const s=e,{axis:o}=s;return{value:()=>ua(n,o)}}};const _U={kernelName:Dp,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>FU(n,e)}}};function FU(n,t){const e=ii(t,te(t)),s=Lb(n,e);let o=sr(t,ue(0,"int32"));const i=s.rank-o.rank;for(let u=0;u<i;++u)o=qn(o,u+1);o=la(o,ri(s.shape,"bool"));const l=te(s);return Bn(o,s,l)}const MU={kernelName:Op,gradFunc:n=>({x:()=>te(n)})};const zU=[Ik,_4,F4,M4,z4,L4,B4,U4,V4,P4,G4,W4,j4,Y4,Z4,Q4,J4,tB,eB,nB,sB,oB,iB,aB,uB,cB,hB,dB,fB,pB,oU,mB,gB,xB,bB,yB,wB,vB,SB,CB,$B,TB,kB,IB,NB,EB,RB,AB,DB,FB,o2,o2,MB,BB,PB,GB,WB,HB,qB,jB,XB,KB,YB,ZB,QB,a2,a2,JB,tU,sU,aU,iU,rU,lU,uU,cU,hU,dU,fU,pU,mU,gU,xU,bU,yU,vU,wU,SU,i2,i2,r2,r2,CU,TU,$U,kU,IU,NU,EU,RU,AU,DU,OU,_U,MU];for(const n of zU)YO(n);ht().prototype.abs=function(){return this.throwIfDisposed(),Mn(this)};ht().prototype.acos=function(){return this.throwIfDisposed(),u3(this)};ht().prototype.acosh=function(){return this.throwIfDisposed(),h3(this)};ht().prototype.add=function(n){return this.throwIfDisposed(),vt(this,n)};ht().prototype.all=function(n,t){return this.throwIfDisposed(),pT(this,n,t)};ht().prototype.any=function(n,t){return this.throwIfDisposed(),d0(this,n,t)};ht().prototype.argMax=function(n){return this.throwIfDisposed(),Pu(this,n)};ht().prototype.argMin=function(n){return this.throwIfDisposed(),g3(this,n)};ht().prototype.asScalar=function(){return this.throwIfDisposed(),_(this.size===1,()=>"The array must have only 1 element."),J(this,[])};ht().prototype.asType=function(n){return this.throwIfDisposed(),$t(this,n)};ht().prototype.as1D=function(){return this.throwIfDisposed(),J(this,[this.size])};ht().prototype.as2D=function(n,t){return this.throwIfDisposed(),J(this,[n,t])};ht().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),J(this,[n,t,e])};ht().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),J(this,[n,t,e,s])};ht().prototype.as5D=function(n,t,e,s,o){return this.throwIfDisposed(),J(this,[n,t,e,s,o])};ht().prototype.asin=function(){return this.throwIfDisposed(),b3(this)};ht().prototype.asinh=function(){return this.throwIfDisposed(),v3(this)};ht().prototype.atan=function(){return this.throwIfDisposed(),S3(this)};ht().prototype.atan2=function(n){return this.throwIfDisposed(),$3(this,n)};ht().prototype.atanh=function(){return this.throwIfDisposed(),k3(this)};ht().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),Db(this,n,t,e,s)};ht().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Ob(this,n,t)};ht().prototype.batchNorm=function(n,t,e,s,o){return this.throwIfDisposed(),Lp(this,n,t,e,s,o)};ht().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Uu(this,n)};ht().prototype.cast=function(n){return this.throwIfDisposed(),$t(this,n)};ht().prototype.ceil=function(){return this.throwIfDisposed(),J3(this)};ht().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Ts(this,n,t)};ht().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof sn&&(n=[n]),Xn([this,...n],t)};ht().prototype.conv1d=function(n,t,e,s,o,i){return this.throwIfDisposed(),mT(this,n,t,e,s,o,i)};ht().prototype.conv2dTranspose=function(n,t,e,s,o){return this.throwIfDisposed(),gT(this,n,t,e,s,o)};ht().prototype.conv2d=function(n,t,e,s,o,i){return this.throwIfDisposed(),Xi(this,n,t,e,s,o,i)};ht().prototype.cos=function(){return this.throwIfDisposed(),Fb(this)};ht().prototype.cosh=function(){return this.throwIfDisposed(),bT(this)};ht().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),p0(this,n,t,e)};ht().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),yT(this,n,t,e)};ht().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),$F(this,n,t)};ht().prototype.depthwiseConv2d=function(n,t,e,s,o,i){return this.throwIfDisposed(),Mb(this,n,t,e,s,o,i)};ht().prototype.dilation2d=function(n,t,e,s,o){return this.throwIfDisposed(),IF(this,n,t,e,s,o)};ht().prototype.divNoNan=function(n){return this.throwIfDisposed(),DF(this,n)};ht().prototype.div=function(n){return this.throwIfDisposed(),Ot(this,n)};ht().prototype.dot=function(n){return this.throwIfDisposed(),_F(this,n)};ht().prototype.elu=function(){return this.throwIfDisposed(),Up(this)};ht().prototype.equal=function(n){return this.throwIfDisposed(),Oo(this,n)};ht().prototype.erf=function(){return this.throwIfDisposed(),vT(this)};ht().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),qF(this,n,t)};ht().prototype.exp=function(){return this.throwIfDisposed(),_o(this)};ht().prototype.expandDims=function(n){return this.throwIfDisposed(),qn(this,n)};ht().prototype.expm1=function(){return this.throwIfDisposed(),YF(this)};ht().prototype.fft=function(){return this.throwIfDisposed(),LT(this)};ht().prototype.flatten=function(){return this.throwIfDisposed(),J(this,[this.size])};ht().prototype.floor=function(){return this.throwIfDisposed(),Pp(this)};ht().prototype.floorDiv=function(n){return this.throwIfDisposed(),fT(this,n)};ht().prototype.gather=function(n,t,e){return this.throwIfDisposed(),Lb(this,n,t,e)};ht().prototype.greaterEqual=function(n){return this.throwIfDisposed(),sr(this,n)};ht().prototype.greater=function(n){return this.throwIfDisposed(),ks(this,n)};ht().prototype.ifft=function(){return this.throwIfDisposed(),m0(this)};ht().prototype.irfft=function(){return this.throwIfDisposed(),Gz(this)};ht().prototype.isFinite=function(){return this.throwIfDisposed(),aM(this)};ht().prototype.isInf=function(){return this.throwIfDisposed(),rM(this)};ht().prototype.isNaN=function(){return this.throwIfDisposed(),uM(this)};ht().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Ub(this,n)};ht().prototype.lessEqual=function(n){return this.throwIfDisposed(),Cl(this,n)};ht().prototype.less=function(n){return this.throwIfDisposed(),hf(this,n)};ht().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),pM(this,n,t,e,s)};ht().prototype.logSigmoid=function(){return this.throwIfDisposed(),wM(this)};ht().prototype.logSoftmax=function(n){return this.throwIfDisposed(),TT(this,n)};ht().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),kT(this,n,t)};ht().prototype.log=function(){return this.throwIfDisposed(),Fo(this)};ht().prototype.log1p=function(){return this.throwIfDisposed(),$T(this)};ht().prototype.logicalAnd=function(n){return this.throwIfDisposed(),la(this,n)};ht().prototype.logicalNot=function(){return this.throwIfDisposed(),Vb(this)};ht().prototype.logicalOr=function(n){return this.throwIfDisposed(),IT(this,n)};ht().prototype.logicalXor=function(n){return this.throwIfDisposed(),EM(this,n)};ht().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),le(this,n,t,e)};ht().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),Pb(this,n,t,e,s)};ht().prototype.max=function(n,t){return this.throwIfDisposed(),lo(this,n,t)};ht().prototype.maximum=function(n){return this.throwIfDisposed(),ii(this,n)};ht().prototype.mean=function(n,t){return this.throwIfDisposed(),Ze(this,n,t)};ht().prototype.min=function(n,t){return this.throwIfDisposed(),cf(this,n,t)};ht().prototype.minimum=function(n){return this.throwIfDisposed(),Hu(this,n)};ht().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),zM(this,n,t)};ht().prototype.mod=function(n){return this.throwIfDisposed(),BM(this,n)};ht().prototype.mul=function(n){return this.throwIfDisposed(),K(this,n)};ht().prototype.neg=function(){return this.throwIfDisposed(),We(this)};ht().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Vp(this,n,t,e)};ht().prototype.notEqual=function(n){return this.throwIfDisposed(),df(this,n)};ht().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),NT(this,n,t,e)};ht().prototype.onesLike=function(){return this.throwIfDisposed(),qs(this)};ht().prototype.pad=function(n,t){return this.throwIfDisposed(),Wb(this,n,t)};ht().prototype.pool=function(n,t,e,s,o,i){return this.throwIfDisposed(),KM(this,n,t,e,s,o,i)};ht().prototype.pow=function(n){return this.throwIfDisposed(),Ki(this,n)};ht().prototype.prelu=function(n){return this.throwIfDisposed(),qb(this,n)};ht().prototype.prod=function(n,t){return this.throwIfDisposed(),QM(this,n,t)};ht().prototype.reciprocal=function(){return this.throwIfDisposed(),Cz(this)};ht().prototype.relu=function(){return this.throwIfDisposed(),or(this)};ht().prototype.relu6=function(){return this.throwIfDisposed(),RT(this)};ht().prototype.reshapeAs=function(n){return this.throwIfDisposed(),J(this,n.shape)};ht().prototype.reshape=function(n){return this.throwIfDisposed(),J(this,n)};ht().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),PT(this,n,t,e)};ht().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),GT(this,n,t,e)};ht().prototype.reverse=function(n){return this.throwIfDisposed(),Yi(this,n)};ht().prototype.rfft=function(){return this.throwIfDisposed(),qz(this)};ht().prototype.round=function(){return this.throwIfDisposed(),AT(this)};ht().prototype.rsqrt=function(){return this.throwIfDisposed(),DT(this)};ht().prototype.selu=function(){return this.throwIfDisposed(),OT(this)};ht().prototype.separableConv2d=function(n,t,e,s,o,i){return this.throwIfDisposed(),_T(this,n,t,e,s,o,i)};ht().prototype.sigmoid=function(){return this.throwIfDisposed(),Sl(this)};ht().prototype.sign=function(){return this.throwIfDisposed(),Dz(this)};ht().prototype.sin=function(){return this.throwIfDisposed(),FT(this)};ht().prototype.sinh=function(){return this.throwIfDisposed(),MT(this)};ht().prototype.slice=function(n,t){return this.throwIfDisposed(),Ne(this,n,t)};ht().prototype.softmax=function(n){return this.throwIfDisposed(),Yb(this,n)};ht().prototype.softplus=function(){return this.throwIfDisposed(),Zc(this)};ht().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),Hb(this,n,t)};ht().prototype.split=function(n,t){return this.throwIfDisposed(),$s(this,n,t)};ht().prototype.sqrt=function(){return this.throwIfDisposed(),An(this)};ht().prototype.square=function(){return this.throwIfDisposed(),Ae(this)};ht().prototype.squaredDifference=function(n){return this.throwIfDisposed(),Xz(this,n)};ht().prototype.squeeze=function(n){return this.throwIfDisposed(),Jc(this,n)};ht().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof sn?[this,n]:[this,...n];return ua(e,t)};ht().prototype.step=function(n){return this.throwIfDisposed(),th(this,n)};ht().prototype.stridedSlice=function(n,t,e,s,o,i,l,u){return this.throwIfDisposed(),Jz(this,n,t,e,s,o,i,l,u)};ht().prototype.sub=function(n){return this.throwIfDisposed(),Ft(this,n)};ht().prototype.sum=function(n,t){return this.throwIfDisposed(),At(this,n,t)};ht().prototype.tan=function(){return this.throwIfDisposed(),eL(this)};ht().prototype.tanh=function(){return this.throwIfDisposed(),zp(this)};ht().prototype.tile=function(n){return this.throwIfDisposed(),io(this,n)};ht().prototype.toBool=function(){return this.throwIfDisposed(),$t(this,"bool")};ht().prototype.toFloat=function(){return this.throwIfDisposed(),$t(this,"float32")};ht().prototype.toInt=function(){return this.throwIfDisposed(),$t(this,"int32")};ht().prototype.topk=function(n,t){return this.throwIfDisposed(),sL(this,n,t)};ht().prototype.transpose=function(n){return this.throwIfDisposed(),Jt(this,n)};ht().prototype.unique=function(n){return this.throwIfDisposed(),iL(this,n)};ht().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),UT(this,n,t)};ht().prototype.unstack=function(n){return this.throwIfDisposed(),Zi(this,n)};ht().prototype.where=function(n,t){return this.throwIfDisposed(),Bn(n,this,t)};ht().prototype.zerosLike=function(){return this.throwIfDisposed(),te(this)};class Co extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Co.prototype)}}class Gs extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Gs.prototype)}}class H extends Error{constructor(t){super(t),Object.setPrototypeOf(this,H.prototype)}}class Pt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Pt.prototype)}}class Ny extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ny.prototype)}}class Ek{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}function Qi(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function $o(n,t){if(!n)throw new Ny(t)}function l2(n,t){let e=0;for(const s of n)s===t&&e++;return e}function jn(n){return n.length===1?n[0]:n}function me(n){return Array.isArray(n)?n:[n]}function aa(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Fi(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Bs={};function Ey(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function b0(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>b0(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:b0(s))}}}function oh(n,t={},e={},s="object",o=!1){if(typeof n=="string"){const i=n;let l;if(i in e)l=e[i];else if(i in Bs)l=Bs[i];else if(l=t[i],l==null)throw new H(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return l}else{const i=n;if(i.className==null||i.config==null)throw new H(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const l=i.className;let u,c;if(l in e?[u,c]=e[l]:l in Bs?[u,c]=Bs.className:l in t&&([u,c]=t[l]),u==null)throw new H(`Unknown ${s}: ${l}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(c!=null){const h={};for(const x of Object.keys(Bs))h[x]=Bs[x];for(const x of Object.keys(e))h[x]=e[x];const f=i.config;f.customObjects=h;const p=Object.assign({},Bs);for(const x of Object.keys(e))Bs[x]=e[x];b0(i.config);const g=c(u,i.config,e,o);return Bs=Object.assign({},p),g}else{const h=Object.assign({},Bs);for(const p of Object.keys(e))Bs[p]=e[p];const f=new u(i.config);return Bs=Object.assign({},h),f}}}function LU(n,t){return n<t?-1:n>t?1:0}function Fd(n,t){return-1*LU(n,t)}function ja(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function BU(n){if(n==null)throw new H(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function ir(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new H(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function Ry(n,t,e=0,s=1/0){return $o(e>=0),$o(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(o=>typeof o===t)}function mn(n,t){Array.isArray(n)?(_(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>mn(e,`element ${s+1} of ${t}`))):_(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${Rk(n)}.`)}function Rk(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>Rk(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function UU(n,t,e){let s=e!=null?e():Hn(),o;return(...l)=>{const u=e!=null?e():Hn();return u-s<t||(s=u,o=n(...l)),o}}function Ak(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let VU=0;function Dk(){return VU++}const Md={};function qp(n=""){return n in Md||(Md[n]=0),Md[n]+=1,n+Md[n].toString()}const PU=["channelsFirst","channelsLast"],GU=["nearest","bilinear"],WU=["valid","same","causal"],HU=["max","avg"],qU=["sum","mul","concat","ave"];const Zr=new Map;function je(n){ir(PU,"DataFormat",n)}function jU(n){ir(GU,"InterpolationFormat",n)}function Is(n){ir(WU,"PaddingMode",n)}function Ok(n){ir(HU,"PoolMode",n)}const Vu=[],u2="/";function Ui(n,t){Vu.push(n);try{const e=t();return Vu.pop(),e}catch(e){throw Vu.pop(),e}}function XU(){return Vu.length===0?"":Vu.join(u2)+u2}function _k(n){if(!Mk(n))throw new Error("Not a valid tensor name: '"+n+"'");return XU()+n}function Fk(n){if(!Mk(n))throw new Error("Not a valid tensor name: '"+n+"'");Zr.has(n)||Zr.set(n,0);const t=Zr.get(n);if(Zr.set(n,Zr.get(n)+1),t>0){const e=`${n}_${t}`;return Zr.set(e,1),e}else return n}const KU=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Mk(n){return!!n.match(KU)}function YU(n){return n===parseInt(n.toString(),10)}function Xa(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let o=t;o<e;++o)s*=n[o];return s}function dl(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function Ya(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function co(n,t){if(t<n)throw new H(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let Mx;function on(){return Mx==null&&(Mx=S_().epsilon()),Mx}function ho(){return"channelsLast"}function Ro(n,t){return $t(n,t)}function ah(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),J(n,e)}function ZU(n,t){return st(()=>{if(n.shape.length!==2)throw new H(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=ah(n,1);return y0(e,[1,t,1])})}function QU(n){const t=[Xa(n.shape)];return J(n,t)}function JU(n){if(n.rank<=1)throw new H(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Xa(n.shape,1)];return J(n,t)}function Vi(n,t,e){return st(()=>{switch(n.rank){case 1:return Xb(n,t,e);case 2:return zT(n,[t,0],[e,n.shape[1]]);case 3:return Kb(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return pf(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Ne(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Ne(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new H(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function zx(n,t,e){return st(()=>{switch(n.rank){case 1:return Xb(n,t,e);case 2:return zT(n,[0,t],[n.shape[0],e]);case 3:return Kb(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return pf(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function zd(n,t,e,s){return st(()=>{switch(n.rank){case 1:return Xb(n,t,e);case 2:switch(s){case 1:return Vi(n,t,e);case 2:return zx(n,t,e);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Vi(n,t,e);case 2:return Kb(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return zx(n,t,e);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Vi(n,t,e);case 2:return pf(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return pf(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return zx(n,t,e);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ay(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),Xn(n,t)}function c2(n,t){switch(n.rank){case 1:return nF([n,t]);case 2:return oF([n,t],0);case 3:return iF([n,t],0);case 4:return lF([n,t],0);default:throw new H(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function y0(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new H(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return io(n,t)}function jp(n,t=0,e=1,s,o){return yz(n,t,e,s,o)}function Ao(n,t,e,s){if(n.rank<2||t.rank<2)throw new Pt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const o=n.shape.slice(-1)[0],i=t.shape.slice(-2)[0];if(o!==i)throw new Pt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return XC({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?v0(n.rank,s,ho()):null,activation:e});{const o=n.shape.slice(),i=o.pop();n=J(n,[-1,i]);const l=t.shape.slice(),u=l.pop(),c=l.pop(),h=[...l,u],f=Array.from({length:t.rank},(b,v)=>v===0?t.rank-2:v<=t.rank-2?v-1:v);t=J(Jt(t,f),[c,-1]);const p=[...o,...h];return J(XC({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?v0(n.rank,s,ho()):null,activation:e}),p)}}function zk(n,t,e){return st(()=>(Array.isArray(t)?t=ls(t,"int32"):t=$t(t,"int32"),Lb(n,t,e)))}function ih(n){return K(n,n)}function v0(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new H(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?J(t,[1,s[0],1,1,1]):J(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?J(t,[1,1,1,1,s[0]]):J(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?J(t,[1,s[0],1,1]):J(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?J(t,[1,1,1,s[0]]):J(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?J(t,[1,s[0],1]):J(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?J(t,[1,1,s[0]]):J(t,[1].concat(s))}else if(n<3)return t;throw new H(`Unsupported input rank by biasAdd: ${t.rank}`)}function po(n,t,e){return st(()=>(e==null&&(e=ho()),je(e),vt(n,v0(n.rank,t,e))))}function tV(n,t=1){if(t!==1)throw new Pt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Up(n)}function eV(n){return st(()=>Ot(n,vt(Mn(n),1)))}function Lk(n,t,e,s){return st(()=>fL(n,t,e,s))}function nV(n){return st(()=>{const t=vt(.5,K(.2,n));return Ts(t,0,1)})}function rh(n,t,e=!1){return e?n():t()}const sV=["fanIn","fanOut","fanAvg"],oV=["normal","uniform","truncatedNormal"];function aV(n){ir(sV,"FanMode",n)}function iV(n){ir(oV,"Distribution",n)}class Xs extends Tl{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Bk extends Xs{apply(t,e){return pn(t,e)}}Bk.className="Zeros";bt(Bk);class Dy extends Xs{apply(t,e){return ri(t,e)}}Dy.className="Ones";bt(Dy);class Uk extends Xs{constructor(t){if(super(),typeof t!="object")throw new H(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new H(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return st(()=>K(ue(this.value),ri(t,e)))}getConfig(){return{value:this.value}}}Uk.className="Constant";bt(Uk);class Vk extends Xs{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Qc(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Vk.className="RandomUniform";bt(Vk);class Pk extends Xs{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Pt(`randomNormal does not support dType ${e}.`);return jp(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Pk.className="RandomNormal";bt(Pk);class Gk extends Xs{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Pt(`truncatedNormal does not support dType ${e}.`);return BT(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Gk.className="TruncatedNormal";bt(Gk);class Wk extends Xs{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return st(()=>{if(t.length!==2||t[0]!==t[1])throw new H("Identity matrix initializer can only be used for 2D square matrices.");return K(this.gain,CT(t[0]))})}getConfig(){return{gain:this.gain}}}Wk.className="Identity";bt(Wk);function rV(n,t="channelsLast"){let e,s;if(je(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const o=Xa(n,2);e=n[1]*o,s=n[0]*o}else if(t==="channelsLast"){const o=Xa(n,0,n.length-2);e=n[n.length-2]*o,s=n[n.length-1]*o}}else{const o=Xa(n);e=Math.sqrt(o),s=Math.sqrt(o)}return[e,s]}class cs extends Xs{constructor(t){if(super(),t.scale<0)throw new H(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,aV(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,iV(this.distribution),this.seed=t.seed}apply(t,e){const s=rV(t),o=s[0],i=s[1];let l=this.scale;if(this.mode==="fanIn"?l/=Math.max(1,o):this.mode==="fanOut"?l/=Math.max(1,i):l/=Math.max(1,(o+i)/2),this.distribution==="normal"){const u=Math.sqrt(l);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Pt(`${this.getClassName()} does not support dType ${e}.`);return BT(t,0,u,e,this.seed)}else{const u=Math.sqrt(3*l);return Qc(t,-u,u,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}cs.className="VarianceScaling";bt(cs);class Oy extends cs{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return cs.className}}Oy.className="GlorotUniform";bt(Oy);class _y extends cs{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return cs.className}}_y.className="GlorotNormal";bt(_y);class Fy extends cs{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return cs.className}}Fy.className="HeNormal";bt(Fy);class My extends cs{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return cs.className}}My.className="HeUniform";bt(My);class zy extends cs{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return cs.className}}zy.className="LeCunNormal";bt(zy);class Ly extends cs{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return cs.className}}Ly.className="LeCunUniform";bt(Ly);class Hk extends Xs{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return st(()=>{if(t.length<2)throw new Pt("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const s=dt(t.slice(0,-1)),o=t[t.length-1],i=s*o;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const l=[Math.max(o,s),Math.min(o,s)],u=jp(l,0,1,e,this.seed),c=u4.qr(u,!1);let h=c[0];const p=c[1].flatten().stridedSlice([0],[Math.min(o,s)*Math.min(o,s)],[Math.min(o,s)+1]);return h=K(h,p.sign()),s<o&&(h=h.transpose()),K(ue(this.gain),h.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Hk.className="Orthogonal";bt(Hk);const h2={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function d2(n,t={}){return oh(n,Ps.getMap().classNameMap,t,"initializer")}function Le(n){return Ey(n)}function Fe(n){if(typeof n=="string"){const t=n in h2?h2[n]:n;if(t==="GlorotNormal")return new _y;if(t==="GlorotUniform")return new Oy;if(t==="HeNormal")return new Fy;if(t==="HeUniform")return new My;if(t==="LeCunNormal")return new zy;if(t==="LeCunUniform")return new Ly;{const e={};return e.className=t,e.config={},d2(e)}}else return n instanceof Xs?n:d2(n)}function w0(n){return Array.isArray(n)&&Array.isArray(n[0])}function mf(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Mt(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new H(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function se(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new H(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function gf(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,o)=>s*o);return t}const f2="Variable";class lV{constructor(t,e="float32",s=f2,o=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=Dk(),s=s??f2,this.originalName=_k(s),this.name=Fk(this.originalName),this.trainable_=o,this.constraint=i,this.val=uL(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),uV(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function uV(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function S0(n){return n.map(t=>t.read())}function By(n){n.forEach(t=>{t[0].write(t[1])})}class an{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Mo{constructor(t,e,s,o,i,l,u){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=o,this.callArgs=i,this.outputTensorIndex=u,this.id=Dk(),l!=null&&(this.originalName=_k(l),this.name=Fk(this.originalName)),this.rank=e.length}}let cV=0;class Xp{constructor(t,e){this.callArgs=e,this.id=cV++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let hV=0;class jt extends Tl{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=hV++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=aa(s)+"_"+qp(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),s=[i].concat(t.inputShape)}this.batchInputShape=s;let o=t.dtype;o==null&&(o=t.inputDType),o==null&&(o="float32"),this.dtype=o}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new Gs(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new H(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return jn(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return jn(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Co(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Co(`Layer ${this.name} is not connected, no input to return.`);return jn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Co(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Co(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return jn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=me(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=me(this.inputSpec);if(e.length!==s.length)throw new H(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let o=0;o<e.length;o++){const i=e[o],l=s[o];if(l==null)continue;const u=i.rank;if(l.ndim!=null&&u!==l.ndim)throw new H(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${l.ndim}, found ndim=${u}`);if(l.maxNDim!=null&&u>l.maxNDim)throw new H(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${l.maxNDim}, found ndim=${u}`);if(l.minNDim!=null&&u<l.minNDim)throw new H(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${l.minNDim}, found ndim=${u}.`);if(l.dtype!=null&&i.dtype!==l.dtype)throw new H(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${l.dtype}, found dtype=${i.dtype}.`);if(l.axes){const c=i.shape;for(const h in l.axes){const f=Number(h),p=l.axes[h],g=f>=0?c[f]:c[c.length+f];if(p!=null&&[p,null].indexOf(g)===-1)throw new H(`Input ${o} is incompatible with layer ${this.name}: expected axis ${f} of input shape to have value ${p} but got shape ${c}.`)}}if(l.shape!=null)for(let c=0;c<l.shape.length;++c){const h=l.shape[c],f=i.shape[c];if(h!=null&&f!=null&&h!==f)throw new H(`Input ${o} is incompatible with layer ${this.name}: expected shape=${l.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=me(t),o=pV(t),i=mV(t);if(o===i)throw new H("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ui(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const l=[];for(const u of me(t))l.push(u.shape);this.build(jn(l)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let l=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,l);const u=me(l),c=[];for(let h of u)s.indexOf(h)!==-1&&(h=h.clone()),c.push(h);if(l=jn(c),this.activityRegularizer!=null)throw new Pt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}else{const l=dV(t),u=this.computeOutputShape(l);let c;const h=fV(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?l[0]:l),u!=null&&u.length>0&&Array.isArray(u[0])?c=u.map((f,p)=>new Mo(h,f,this,me(t),e,this.name,p)):c=new Mo(h,u,this,me(t),e,this.name),this.addInboundNode(t,c,null,null,l,u,e),this._refCount++,this.activityRegularizer!=null)throw new Pt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,o)=>{s!=null&&t[o]!=null&&t[o]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Co(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Co(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Gs(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return gf(this.weights)}build(t){this.built=!0}getWeights(t=!1){return S0(t?this.trainableWeights:this.weights)}setWeights(t){st(()=>{const e=this.weights;if(e.length!==t.length)throw new H(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],o=S0(e);for(let i=0;i<o.length;++i){const l=o[i],u=e[i],c=t[i];if(!ce(l.shape,c.shape))throw new H(`Layer weight shape ${l.shape} not compatible with provided weight shape ${c.shape}`);s.push([u,c])}By(s)})}addWeight(t,e,s,o,i,l,u,c){if(this._addedWeightNames.indexOf(t)!==-1)throw new H(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(o=c!=null?c():Fe("zeros"));const h=o.apply(e,s),f=new lV(h,s,t,l,u);return h.dispose(),i!=null&&this.addLoss(()=>i.apply(f.read())),l==null&&(l=!0),l?this._trainableWeights.push(f):this._nonTrainableWeights.push(f),f}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=me(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,s){if(!this.supportsMasking)return;const o=this.computeMask(t,s),i=me(e),l=me(o);if(i.length!==l.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let u=0;u<i.length;u++)i[u].kerasMask=l[u]}addInboundNode(t,e,s,o,i,l,u=null){const c=me(t);e=me(e),s=me(s),o=me(o),i=mf(i),l=mf(l);const h=[],f=[],p=[];for(const g of c)h.push(g.sourceLayer),f.push(g.nodeIndex),p.push(g.tensorIndex);new Xp({outboundLayer:this,inboundLayers:h,nodeIndices:f,tensorIndices:p,inputTensors:c,outputTensors:e,inputMasks:s,outputMasks:o,inputShapes:i,outputShapes:l},u);for(let g=0;g<e.length;g++)e[g].sourceLayer=this,e[g].nodeIndex=this.inboundNodes.length-1,e[g].tensorIndex=g}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function dV(n){n=me(n);const t=[];for(const e of n)t.push(e.shape);return jn(t)}function fV(n){return"float32"}function qk(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const o=[];for(let i=0;i<s.inboundLayers.length;i++){const l=s.inputTensors[i],u=s.inboundLayers[i],c=s.nodeIndices[i],h=qk(l,u,c);for(const f of h)o.indexOf(f)===-1&&o.push(f)}return o}}}function pV(n){let t=!0;for(const e of me(n))if(!(e instanceof Mo)){t=!1;break}return t}function mV(n){let t=!0;for(const e of me(n))if(e instanceof Mo){t=!1;break}return t}class lh extends jt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:qp("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new H("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new H("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new H("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const o=new Mo(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new Xp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new H(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}lh.className="InputLayer";bt(lh);function gV(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new H("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new lh({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function xV(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return $t(t,n.dtype)}catch{throw new H(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Ga{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Ga)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=xV(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new H(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Mo){if(this.id2Value[t.id]==null)throw new H(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new H(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Mo){if(this.id2Value[t.id]==null)throw new H(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new H(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Wt(this.id2Mask)}}const xf=new Ek,bf=new Ek;function bV(n){xf?.setMaxEntries(n),bf?.setMaxEntries(n)}function Fu(n,t,e,s){const o=e==null?!1:e.training,i=Array.isArray(n),l=i?n:[n],u=l.map(b=>b.name),c=[],h=t.names();for(const b of u)h.indexOf(b)!==-1?c.push(t.getValue(b)):c.push(null);const f=u.join(",")+"|"+t.names().sort().join(",");let p=xf.get(f),g;if(p==null){const b=yV(l,t);p=b.sorted,g=b.recipientCounts,xf.put(f,p),bf.put(f,g)}g={},o||Object.assign(g,bf.get(f));const x=new Ga(t);for(let b=0;b<p.length;++b){const v=p[b],S=v.sourceLayer;if(S instanceof lh)continue;const C=[],$=[],k=[];let T=!1;for(const O of v.inputs){const F=x.getValue(O),E=x.getMask(O);C.push(F),$.push(E),E!=null&&(T=!0),o||(g[O.name]--,g[O.name]===0&&!t.hasKey(O)&&u.indexOf(O.name)===-1&&!F.isDisposed&&O.sourceLayer.stateful!==!0&&k.push(F))}T&&(e=e||{},e.mask=$[0]);const N=me(S.apply(C,e));let R=null;S.supportsMasking&&(R=S.computeMask(C,$));const D=wV(v),z=Array.isArray(D)?D:[D];for(let O=0;O<z.length;++O){x.hasKey(z[O])||x.add(z[O],N[O],Array.isArray(R)?R[0]:R);const F=u.indexOf(z[O].name);F!==-1&&(c[F]=N[O])}o||Wt(k)}return x.disposeMasks(),i?c:c[0]}function yV(n,t){_(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const o=p2(n[0],t);e=o.sorted,s=o.recipientMap}else{const o=new Set;for(const i of n){const{sorted:l,recipientMap:u}=p2(i,t);for(const c of l)o.has(c.name)||(e.push(c),o.add(c.name));for(const c in u)s[c]==null&&(s[c]=new Set),u[c].forEach(h=>s[c].add(h))}}return{sorted:e,recipientCounts:vV(s)}}function vV(n){const t={};for(const e in n)t[e]=n[e].size;return t}function p2(n,t){const e=new Set,s=[],o={};for(const u of t.names())e.add(u);const i=[],l=[];for(i.push(n);i.length>0;){const u=i[i.length-1];if(e.has(u.name)){i.pop();continue}const c=l[l.length-1]===i.length-1;if(u.inputs.length===0||c)i.pop(),s.push(u),e.add(u.name),c&&l.pop();else{l.push(i.length-1);for(const h of u.inputs)o[h.name]==null&&(o[h.name]=new Set),o[h.name].add(u.name),!e.has(h.name)&&i.push(h)}}return{sorted:s,recipientMap:o}}function wV(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const o of n.sourceLayer.inboundNodes[s].outputTensors)if(o.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}const SV=lt();SV.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,bV);function Uy(n,t){return st(()=>An(At(K(n,n),t,!0)))}class uh extends Tl{getConfig(){return{}}}class jk extends uh{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return st(()=>{const e=Uy(t,this.axis),s=Ts(e,0,this.maxValue);return K(t,Ot(s,vt(on(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}jk.className="MaxNorm";bt(jk);class Xk extends uh{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return st(()=>Ot(t,vt(on(),Uy(t,this.axis))))}getConfig(){return{axis:this.axis}}}Xk.className="UnitNorm";bt(Xk);class Kk extends uh{apply(t){return or(t)}}Kk.className="NonNeg";bt(Kk);class Yk extends uh{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return st(()=>{const e=Uy(t,this.axis),s=vt(K(this.rate,Ts(e,this.minValue,this.maxValue)),K(1-this.rate,e));return K(t,Ot(s,vt(on(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Yk.className="MinMaxNorm";bt(Yk);const m2={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function rn(n){return Ey(n)}function g2(n,t={}){return oh(n,Ps.getMap().classNameMap,t,"constraint")}function ln(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in m2?m2[n]:n,config:{}};return g2(e)}else return n instanceof uh?n:g2(n)}async function Ai(n){if(n==null)return;const t=[],e=[],s=[];for(const o in n){const i=n[o];if(typeof i!="number"){const l=i;t.push(l.data()),e.push(o),s.push(l)}}if(t.length>0){const o=await Promise.all(t);for(let i=0;i<o.length;++i)n[e[i]]=o[i][0];Wt(s)}}function Zk(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}var x2;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(x2||(x2={}));const CV=125;class ju{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class $V{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class TV extends ju{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const o in e){const i=e[o];if(typeof i=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+i*s;else{let l;o in this.totals?l=this.totals[o]:this.totals[o]=0;const u=st(()=>vt(this.totals[o],K(i,s)));this.totals[o]=u,l?.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:st(()=>{const o=K(Ot(1,this.seen),this.totals[s]);e[s]=o,this.totals[s].dispose(),No(e[s])}))}}class kV extends ju{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const i in this.history){const l=this.history[i];for(let u=0;u<l.length;++u)if(typeof l[u]!="number"){const c=l[u];t.push(c.data()),e.push(i),s.push(u)}}const o=await Promise.all(t);for(let i=0;i<o.length;++i)this.history[e[i]][s[i]].dispose(),this.history[e[i]][s[i]]=o[i][0]}}class IV extends ju{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||sk,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=CV),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Qx(this.yieldEvery)&&(this.maybeWait=UU(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const o=[];this.yield!=null&&(await Ai(s),o.push(this.yield(t,e,s))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Ai(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await Ai(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Ai(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await Ai(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Qx(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await Ai(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Ai(t),await this.trainEnd(t))}}function Qk(n,t){return n==null&&(n={}),n instanceof ju?[n]:Array.isArray(n)&&n[0]instanceof ju?n:me(n).map(s=>new IV(s,t))}class Vs{constructor(){}static registerCallbackConstructor(t,e){_(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Vs.checkForDuplicate(e),Vs.constructors[t]==null&&(Vs.constructors[t]=[]),Vs.constructors[t].push(e)}static checkForDuplicate(t){for(const e in Vs.constructors)Vs.constructors[+e].forEach(o=>{if(o===t)throw new H("Duplicate callback constructor.")})}static clear(){Vs.constructors={}}static createCallbacks(t){const e=[];for(const s in Vs.constructors){const o=+s;t>=o&&e.push(...Vs.constructors[o])}return e.map(s=>new s)}}Vs.constructors={};function Jk(n,t,e,s,o,i,l,u,c){const h=new kV,f=[new TV,...Vs.createCallbacks(t)];n!=null&&f.push(...n),f.push(h);const p=new $V(f);return p.setParams({epochs:e,initialEpoch:s,samples:o,steps:i,batchSize:l,verbose:t,doValidation:u,metrics:c}),{callbackList:p,history:h}}function Do(n,t={},e=!1){return oh(n,Ps.getMap().classNameMap,t,"layer",e)}function yf(n,t){return st(()=>{n.dtype!=="float32"&&(n=$t(n,"float32"));const e=At(ih(n),t,!0),s=Bp(e.shape,on()),o=An(ii(e,s));return Ot(n,o)})}function Kp(n,t){return st(()=>Ze(ih(Ft(t,n)),-1))}function Vy(n,t){return st(()=>Ze(Mn(Ft(t,n)),-1))}function Py(n,t){return st(()=>{const e=Ft(n,t),s=Ts(Mn(n),on(),Number.MAX_VALUE),o=Mn(Ot(e,s));return K(100,Ze(o,-1))})}function NV(n,t){return st(()=>{const e=Ts(t,on(),Number.MAX_VALUE),s=Fo(vt(1,e)),o=Ts(n,on(),Number.MAX_VALUE),i=Fo(vt(1,o));return Ze(ih(Ft(s,i)),-1)})}function EV(n,t){return st(()=>{const e=ii(0,Ft(1,K(n,t)));return Ze(ih(e),-1)})}function RV(n,t){return st(()=>{const e=ii(0,Ft(1,K(n,t)));return Ze(e,-1)})}function AV(n,t){return st(()=>{const e=At(K(n,t),-1),s=lo(K(Ft(1,n),t),-1);return ii(0,vt(1,Ft(s,e)))})}function DV(n,t){return st(()=>{const e=Math.log(2),s=Ft(t,n),o=Ft(vt(s,Zc(K(-2,s))),e);return Ze(o,-1)})}function Xu(n,t,e=!1){return st(()=>{if(e)t=Yb(t);else{const s=At(t,t.shape.length-1,!0);t=Ot(t,s)}return t=Ts(t,on(),1-on()),We(At(K($t(n,"float32"),Fo(t)),t.shape.length-1))})}function vf(n,t,e=!1){return st(()=>{const s=$t(Pp(QU(n)),"int32");t=Ts(t,on(),1-on());const o=t.shape,i=J(NT(s,o[o.length-1]),o);return Xu(i,t,e)})}function OV(n,t){if(!ce(n.shape,t.shape))throw new H(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return st(()=>{const e=or(t),s=We(Mn(t));return vt(Ft(e,K(t,n)),$T(_o(s)))})}function Yp(n,t){return st(()=>{let e;return e=Ts(t,on(),1-on()),e=Fo(Ot(e,Ft(1,e))),Ze(OV(n,e),-1)})}function _V(n,t){return st(()=>{const e=Ts(n,on(),1),s=Ts(t,on(),1);return At(K(n,Fo(Ot(e,s))),-1)})}function FV(n,t){return st(()=>{const e=Fo(vt(on(),t));return Ze(Ft(t,K(n,e)),-1)})}function tI(n,t){return st(()=>{const e=yf(n,-1),s=yf(t,-1),o=K(e,s);return We(At(o,-1))})}const wf={meanSquaredError:Kp,meanAbsoluteError:Vy,meanAbsolutePercentageError:Py,meanSquaredLogarithmicError:NV,squaredHinge:EV,hinge:RV,categoricalHinge:AV,logcosh:DV,categoricalCrossentropy:Xu,sparseCategoricalCrossentropy:vf,binaryCrossentropy:Yp,kullbackLeiblerDivergence:_V,poisson:FV,cosineProximity:tI};function Lx(n){if(typeof n=="string"){if(n in wf)return wf[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new H(t)}else return n}function eI(n,t){return st(()=>{const e=K(.5,qs(t)),s=Ro(ks(t,e),n.dtype);return Ze(Oo(n,s),-1)})}function nI(n,t){return st(()=>Ro(Oo(Pu(n,-1),Pu(t,-1)),"float32"))}function MV(n,t){return st(()=>$t(At(la(Oo(n,1),Oo(t,1))),"float32"))}function zV(n,t){return st(()=>$t(At(la(Oo(n,0),Oo(t,1))),"float32"))}function LV(n,t){return st(()=>{const e=MV(n,t),s=zV(n,t),o=vt(e,s);return $t(Bn(ks(o,0),Ot(e,o),0),"float32")})}function BV(n,t){return Yp(n,t)}function UV(n,t){return n.rank===t.rank&&(n=Jc(n,[n.rank-1])),t=Pu(t,-1),t.dtype!==n.dtype&&(t=$t(t,n.dtype)),$t(Oo(n,t),"float32")}const VV=Kp,PV=Kp,GV=Vy,WV=Vy,HV=Py,qV=Py,sI=Xu,jV=tI,oI=vf,Sf={binaryAccuracy:eI,categoricalAccuracy:nI,precision:LV,categoricalCrossentropy:sI,sparseCategoricalCrossentropy:oI,mse:VV,MSE:PV,mae:GV,MAE:WV,mape:HV,MAPE:qV,cosine:jV};function XV(n){if(typeof n=="string"&&n in Sf)return Sf[n];if(typeof n!="string"&&n!=null)return n;throw new H(`Unknown metric ${n}`)}function Ld(n){if($o(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(wf))if(wf[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(Sf))if(Sf[e]===n){t=e;break}return t!==void 0?t:n.name}}function KV(n){const t={Adagrad:()=>oa.adagrad(.01),Adadelta:()=>oa.adadelta(1,.95,on()),Adam:()=>oa.adam(.001,.9,.999,on()),Adamax:()=>oa.adamax(.002,.9,.999,on(),0),RMSProp:()=>oa.rmsprop(.001,.9,0,on()),SGD:()=>oa.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new H(`Unknown Optimizer ${n}`)}const b2=1*1024*1024;function y2(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!C0(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>b2&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${b2}.`)}}function C0(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!C0(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!C0(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function YV(n,t,e,s=console.log){const o=QV(n),i=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(f=>Math.floor(t*f)));let l;if(!o){i.push("Receives inputs"),l=[];for(const f in n.nodesByDepth)l.push(...n.nodesByDepth[f])}s("_".repeat(t)),Cf(i,e,s),s("=".repeat(t));const u=n.layers;for(let f=0;f<u.length;++f)o?JV(u[f],e,s):tP(u[f],e,l,s),s((f===u.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const c=ZV(n),h=gf(n.nonTrainableWeights);s(`Total params: ${c+h}`),s(`Trainable params: ${c}`),s(`Non-trainable params: ${h}`),s("_".repeat(t))}function ZV(n){let t;return n.collectedTrainableWeights!=null?t=gf(n.collectedTrainableWeights):t=gf(n.trainableWeights),t}function QV(n){let t=!0;const e=[],s=[];for(const o in n.nodesByDepth)e.push(n.nodesByDepth[o]);for(const o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}s.push(...o)}if(t)for(const o of n.layers){let i=!1;for(const l of o.inboundNodes)if(s.indexOf(l)!==-1)if(i){t=!1;break}else i=!0;if(!t)break}return t}function Cf(n,t,e=console.log){let s="";for(let o=0;o<n.length;++o)o>0&&(s=s.slice(0,s.length-1)+" "),s+=n[o],s=s.slice(0,t[o]),s+=" ".repeat(t[o]-s.length);e(s)}function JV(n,t,e){let s,o;try{o=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{o="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,l=n.getClassName(),u=[`${i} (${l})`,o,s,n.countParams().toString()];Cf(u,t,e)}function tP(n,t,e,s){let o,i;try{i=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{i="multiple"}try{o=JSON.stringify(n.outputShape)}catch{o="multiple"}const l=[];for(const p of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let g=0;g<p.inboundLayers.length;++g){const x=p.inboundLayers[g].name,b=p.nodeIndices[g],v=p.tensorIndices[g];l.push(`${x}[${b}][${v}]`)}const u=n.name,c=n.getClassName(),h=l.length===0?"":l[0],f=[`${u} (${c})`,i,o,n.countParams().toString(),h];Cf(f,t,s);for(let p=1;p<l.length;++p)Cf(["","","","",l[p]],t,s)}function aI(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function $f(n,t){if(n===null)return null;if(typeof n=="string")return Fi(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let o=0;o<s;++o){const i=n[o];aI(t,o,i)?e.push(i):e.push($f(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const o=n[s];if(s==="name"&&typeof o=="string")e[s]=o;else{const i=Fi(s);e[i]=$f(o,i)}}return e}}function $0(n,t){if(n==null)return null;if(typeof n=="string")return aa(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let o=0;o<s;++o){const i=n[o];aI(t,o,i)?e.push(i):e.push($0(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const o=n[s],i=aa(s);(s==="name"||s==="className")&&typeof o=="string"?e[i]=o:e[i]=$0(o,s)}return e}}const iI="4.22.0";const eP=n=>{const t=Object.keys(n);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class so extends jt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const $=this.getClassName().toLowerCase();this.name=qp($)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],ja(this.inputs).length!==this.inputs.length)throw new H(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map($=>$.name)}`);ja(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map($=>$.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const $ of this.outputs){const k=$.sourceLayer,T=$.nodeIndex,N=$.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push(T),this.outputLayersTensorIndices.push(N)}for(const $ of this.inputs){const k=$.sourceLayer,T=$.nodeIndex,N=$.tensorIndex;$o(T===0,"input layer has >1 nodes"),$o(N===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push(T),this.inputLayersTensorIndices.push(N)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let $=0;$<this.inputLayers.length;$++){const k=this.inputLayers[$];if(!(k instanceof lh))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${$} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(const $ of this.outputLayers)this.outputNames.push($.name);this.internalInputShapes=this.inputs.map($=>$.shape),this.internalOutputShapes=this.outputs.map($=>$.shape);const e={},s={},o={},i={},l={},u=[],c=($,k,T,N,R,D)=>{(N==null||R==null||D==null)&&(N=$.sourceLayer,R=$.nodeIndex,D=$.tensorIndex);const z=N.inboundNodes[R];if(T.indexOf(z)!==-1)throw new Gs(`The tensor ${$.name} at layer "${N.name}" is part of a cycle.`);if(k.indexOf(z)!==-1)return;this.containerNodes.add(so.nodeKey(N,R)),N.id in l||(l[N.id]=Object.keys(l).length),T.indexOf(z)===-1&&T.push(z);const O=z.inboundLayers.length;for(let F=0;F<O;F++){const E=z.inputTensors[F],U=z.inboundLayers[F],Y=z.nodeIndices[F],X=z.tensorIndices[F];c(E,k,T,U,Y,X)}for(k.push(z);T.indexOf(z)>=0;)T.splice(T.indexOf(z),1);u.push(z)},h=[],f=[];for(const $ of this.outputs)c($,h,f);const p=u.slice().reverse();for(const $ of p){s[$.id]=$,$.id in e||(e[$.id]=0);let k=e[$.id];const T=o[$.outboundLayer.id]==null?0:o[$.outboundLayer.id];k=Math.max(k,T),o[$.outboundLayer.id]=k,i[$.outboundLayer.id]=$.outboundLayer,e[$.id]=k;for(let N=0;N<$.inboundLayers.length;N++){const R=$.inboundLayers[N],D=$.nodeIndices[N],z=R.inboundNodes[D],O=e[z.id]==null?0:e[z.id];e[z.id]=Math.max(k+1,O),s[z.id]=z}}const g={};for(const $ in e){const k=e[$];k in g||(g[k]=[]),g[k].push(s[$])}const x={};for(const $ in o){const k=o[$];k in x||(x[k]=[]),x[k].push(i[$])}let b=Object.keys(x).map($=>parseInt($,10)).sort(Fd);this.layers=[];for(const $ of b){const k=x[$];k.sort((T,N)=>{const R=l[T.id],D=l[N.id];return R<D?-1:R>D?1:0});for(const T of k)T instanceof so&&this.internalContainerRefs.push(T),this.layers.push(T)}this.layersByDepth=x,b=Object.keys(g).map($=>parseInt($,10)).sort(Fd);const v=this.inputs.slice(),S=[];for(const $ of b)for(const k of g[$]){const T=k.outboundLayer;if(T!=null){for(const N of k.inputTensors)if(v.indexOf(N)===-1)throw new Gs(`Graph disconnected: cannot obtain value for tensor ${N} at layer "${T.name}". The following previous layers were accessed without issue: ${S}`);for(const N of k.outputTensors)v.push(N);S.push(T.name)}}this.nodesByDepth=g;const C=this.layers.map($=>$.name);for(const $ of C){const k=C.filter(T=>T===$).length;if(k!==1)throw new Gs(`The name "${$}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(C))}this.outboundNodes=[],this.inboundNodes=[],new Xp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map($=>null),outputMasks:this.outputs.map($=>null),inputShapes:this.inputs.map($=>$.shape),outputShapes:this.outputs.map($=>$.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new H("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let o=0;const i=eP(t);i&&this.parseWeights(t);for(const u of this.layers)for(const[c,h]of u.weights.entries()){const f=i?`${h.name.split("/").slice(0,-1).join("/")+"/"}${c}`:h.originalName;if(s[f]!=null)throw new H(`Duplicate weight name: ${f}`);s[f]=h,o++}const l=[];for(const u in t){let c=u;if(s[u]==null){const h=u.split("/");c=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[c]!=null)l.push([s[c],t[u]]);else if(e)throw new H(`Provided weight data has no target variable: ${u}`);delete s[c]}if(e){const u=[];for(const c in s)u.push(c);if(u.length>0)throw new H(`${u.length} of ${o} weights are not set: ${u}`)}By(l)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),o=["vars","layer_checkpoint_dependencies"],i=s.map(l=>l.startsWith("_")?l.slice(1):l).filter(l=>!o.includes(l)).join("/");i!==e&&(t[i]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${iI}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=$0(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return st(()=>{t=me(t);const s=new Ga;for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],t[o]);return Fu(this.outputs,s,e)})}computeMask(t,e){return st(()=>{t=me(t);let s;return e==null?s=Qi(null,t.length):s=me(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=mf(t);if(e.length!==this.inputLayers.length)throw new H(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let u=0;u<e.length;u++){const c=this.inputLayers[u],h=e[u],f=c.name+"_0_0";s[f]=h}const o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Fd);if(o.length>1)for(const u of o){const c=this.nodesByDepth[u];for(const h of c){const f=h.outboundLayer;if(this.inputLayers.map(v=>v.id).indexOf(f.id)!==-1)continue;const p=[];for(let v=0;v<h.inboundLayers.length;v++){const S=h.inboundLayers[v],C=h.nodeIndices[v],$=h.tensorIndices[v],k=`${S.name}_${C}_${$}`,T=s[k];p.push(T)}const g=f.computeOutputShape(jn(p)),x=mf(g),b=f.inboundNodes.indexOf(h);for(let v=0;v<x.length;v++){const S=`${f.name}_${b}_${v}`;s[S]=x[v]}}}const i=[],l=[];for(let u=0;u<this.outputLayers.length;u++){const c=this.outputLayers[u],h=this.outputLayersNodeIndices[u],f=this.outputLayersTensorIndices[u],p=`${c.name}_${h}_${f}`;l.push(p)}for(let u=0;u<l.length;u++){const c=l[u];$o(c in s),i.push(s[c])}return jn(i)}runInternalGraph(t,e){e==null&&(e=Qi(null,t.length));const s={};for(let c=0;c<this.inputs.length;++c){const h=this.inputs[c],f=t[c],p=e[c];s[h.id]=[f,p]}const o=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(Fd);for(const c of o){const h=this.nodesByDepth[c];for(const f of h){const p=f.outboundLayer,g=f.inputTensors,x=f.outputTensors,b=new Array;for(const v of g)v.id in s&&b.push(s[v.id]);if(b.length===g.length){let v={},S,C,$,k;if(f.callArgs!=null&&(v=f.callArgs),b.length===1){const[T,N]=b[0];v.mask==null&&(v.mask=N),$=me(p.call(T,v)),k=me(p.computeMask(T,N)),S=[T],C=[N]}else S=b.map(T=>T[0]),C=b.map(T=>T[1]),v.mask==null&&(v.mask=C),$=me(p.call(S,v)),k=me(p.computeMask(S,C));if(p.activityRegularizer)throw new Pt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let T=0;T<x.length;++T){const N=x[T],R=$[T],D=k[T];s[N.id]=[R,D]}}}}const i=[],l=[],u=[];for(const c of this.outputs){$o(c.id in s,`Could not compute output ${c.name} : ${c.id}`);const[h,f]=s[c.id];u.push(h.shape),i.push(h),l.push(f)}return[i,l,u]}buildNodeConversionMap(t){const e={};let s;for(const o of this.layers){s=o instanceof so?1:0;for(let i=0;i<o.inboundNodes.length;i++){const l=so.nodeKey(o,i);this.containerNodes.has(l)&&(e[l]=s,s+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new H("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new H(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new H(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return st(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const o=so.nodeKey(e,s);this.containerNodes.has(o)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const l of this.layers){const u=l.getClassName(),c=l.getConfig(),h=[];for(let p=0;p<l.inboundNodes.length;p++){const g=l.inboundNodes[p],x=so.nodeKey(l,p);let b={};if(this.containerNodes.has(x)){if(g.callArgs)try{JSON.stringify(g.callArgs),b=g.callArgs}catch{console.warn(`Layer ${l.name} was passed non-serializable keyword arguments: ${g.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(g.inboundLayers.length>0){const v=[];for(let S=0;S<g.inboundLayers.length;S++){const C=g.inboundLayers[S],$=g.nodeIndices[S],k=g.tensorIndices[S],T=so.nodeKey(C,$);let N=e[T];N==null&&(N=0),v.push([C.name,N,k,b])}h.push(v)}}}const f={};f.name=l.name,f.className=u,f.config=c,f.inboundNodes=h,s.push(f)}t.layers=s;const o=[];for(let l=0;l<this.inputLayers.length;l++){const u=this.inputLayers[l],c=this.inputLayersNodeIndices[l],h=so.nodeKey(u,c);if(!this.containerNodes.has(h))continue;let f=e[h];f==null&&(f=0);const p=this.inputLayersTensorIndices[l];o.push([u.name,f,p])}t.inputLayers=o;const i=[];for(let l=0;l<this.outputLayers.length;l++){const u=this.outputLayers[l],c=this.outputLayersNodeIndices[l],h=so.nodeKey(u,c);if(!this.containerNodes.has(h))continue;let f=e[h];f==null&&(f=0);const p=this.outputLayersTensorIndices[l];i.push([u.name,f,p])}return t.outputLayers=i,t}static fromConfig(t,e,s={},o=!1){const i={},l={};function u(S,C){S.name in l?l[S.name].push(C):l[S.name]=[C]}function c(S,C){const $=[];let k;for(const T of C){const N=T[0],R=T[1],D=T[2];if(k=T[3]==null?{}:T[3],!(N in i)){u(S,C);return}const z=i[N];if(z.inboundNodes.length<=R){u(S,C);return}const O=z.inboundNodes[R];$.push(O.outputTensors[D])}$.length>0&&S.apply(jn($),k)}function h(S){const C=S.name,$=Do(S,e.customObjects!=null?e.customObjects:{});$.setFastWeightInitDuringBuild(o),i[C]=$,S.inboundNodes.forEach(T=>{if(!(T instanceof Array))throw new H(`Corrupted configuration, expected array for nodeData: ${T}`);u($,T)})}const f=e.name,p=e.layers;for(const S of p)h(S);for(;!BU(l);)for(const S of p){const C=i[S.name];if(C.name in l){const $=l[C.name];delete l[C.name];for(const k of $)c(C,k)}}const g=[],x=[],b=e.inputLayers;for(const S of b){const C=S[0],$=S[1],k=S[2];$o(C in i);const N=i[C].inboundNodes[$].outputTensors;g.push(N[k])}const v=e.outputLayers;for(const S of v){const C=S[0],$=S[1],k=S[2];$o(C in i);const N=i[C].inboundNodes[$].outputTensors;x.push(N[k])}return new t({inputs:g,outputs:x,name:f})}get stateful(){if(this._stateful)throw new H("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){st(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function nP(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(o=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const o=[];return t.forEach(i=>{i in n?o.push(n[i]):o.push(null)}),o}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function rI(n,t){return nP(n,t,"classWeight")}async function lI(n,t,e,s){if(e!=null){const o=st(()=>{if(n.shape.length===1)return Bi(n);if(n.shape.length===2){if(n.shape[1]>1)return Pu(n,1);if(n.shape[1]===1)return J(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await o.data());Wt(o);const l=[];return i.forEach(u=>{if(e[u]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${u} exists in the data but not in classWeight`);l.push(e[u])}),ls(l,"float32")}else return null}function sP(n,t){return K(n,t)}const oP=32;function uI(n,t){let e,s;const o=t;e=o.xs,s=o.ys,_(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=v2("input",n.inputNames,e),l=v2("output",n.outputNames,s),u=i[0].shape[0];_(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),_(l.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${l.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let c=0;c<i.length;c++)_(i[c].shape[0]===u,()=>`Batch size mismatch: input ${n.inputNames[c]} has ${i[c].shape[0]}; expected  ${u} based on input ${n.inputNames[0]}.`);for(let c=0;c<l.length;c++)_(l[c].shape[0]===u,()=>`Batch size mismatch: output ${n.outputNames[c]} has ${l[c].shape[0]}; expected  ${u} based on input ${n.inputNames[0]}.`);return{xs:i,ys:l}}function v2(n,t,e){if(e instanceof sn)return[e];if(Array.isArray(e))return _(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const o of t){if(e[o]==null)throw new H(`The feature data generated by the dataset lacks the required ${n} key '${o}'.`);s.push(e[o])}return s}}function aP(n){if(n.length===3)throw new Pt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function iP(n,t,e){const s=e.batchesPerEpoch!=null;if(_(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),_(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),_(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),_(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),_(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const o=e.validationData!=null;let i,l;if(o)if(w2(e.validationData))_(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const S=aP(e.validationData);i=S.xs,l=S.ys}const u=n.makeTrainFunction(),c=n.getDedupedMetricsNames();let h;o?h=c.slice().concat(c.map(S=>"val_"+S)):h=c.slice();const f=Qk(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:g,history:x}=Jk(f,p,e.epochs,null,null,rP(t,e),null,o,h);g.setModel(n),n.history=x,await g.onTrainBegin(),n.stopTraining_=!1;let b=e.initialEpoch==null?0:e.initialEpoch,v=await t.iterator();for(;b<e.epochs;){const S={};await g.onEpochBegin(b);let C=0,$=0;for(s||(v=await t.iterator());!s||C<e.batchesPerEpoch;){const k=await v.next();if(s&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${C} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){const{xs:T,ys:N}=uI(n,k.value),R={};R.batch=$,R.size=T[0].shape[0],await g.onBatchBegin($,R);const D=[];if(e.classWeight!=null){const F=rI(e.classWeight,n.outputNames);for(let E=0;E<F.length;++E)D.push(await lI(N[E],null,F[E]))}const z=T.concat(N).concat(D),O=u(z);Wt(z);for(let F=0;F<c.length;++F){const E=c[F],U=O[F];R[E]=U,No(U)}await g.onBatchEnd($,R),Zk(R),$++,C++}if(s?C>=e.batchesPerEpoch:k.done){if(o){let T;w2(e.validationData)?T=me(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):T=me(n.evaluate(i,l,{batchSize:e.validationBatchSize==null?oP:e.validationBatchSize,verbose:0}));for(let N=0;N<n.metricsNames.length;++N)S[`val_${n.metricsNames[N]}`]=T[N]}break}if(n.stopTraining_)break}if(await g.onEpochEnd(b,S),b++,n.stopTraining_)break}return await g.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function rP(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function w2(n){return typeof n.iterator=="function"}function lP(n){return typeof n.next=="function"}async function uP(n,t,e){e=e||{};const s=e.batches!=null,o=n.testFunction;let i=[];if(e.verbose>0)throw new Pt("Verbose mode is not implemented yet.");_(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const l=lP(t)?t:await t.iterator();let u=0,c=0;for(;!s||c<e.batches;){const h=await l.next();if(i=st(()=>{if(h.value){const{xs:f,ys:p}=uI(n,h.value),g=f.concat(p),x=st(()=>o(g));if(Wt(g),c===0)for(let v=0;v<x.length;++v)i.push(ue(0));const b=g[0].shape[0];for(let v=0;v<x.length;++v){const S=x[v],C=i[v];i[v]=st(()=>vt(i[v],K(b,S))),c>0&&Wt(C)}Wt(x),u+=b,++c}return i}),h.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let h=0;h<i.length;++h){const f=i[h];i[h]=Ot(i[h],u),Wt(f)}return jn(i)}function Bx(n){_(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Au(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>Vi(s,t,e-t)):Vi(n,t,e-t)}function T0(n,t){return st(()=>n==null?null:Array.isArray(n)?n.map(e=>T0(e,t)):zk(n,t.dtype==="int32"?t:$t(t,"int32")))}function Ux(n,t){const e=[];let s=0,o=null;for(;s<n;)o=s+t,o>=n&&(o=n),e.push([s,o]),s=o;return e}function cI(n){const t=[];n instanceof sn&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(ah(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function no(n,t){if(n==null)return;const e=[];if(t instanceof sn)e.push(t.id);else if(Array.isArray(t))t.forEach(o=>e.push(o.id));else if(t!=null)for(const o in t){const i=t[o];e.push(i.id)}const s=[];if(n instanceof sn)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(o=>{e.indexOf(o.id)===-1&&s.push(o)});else if(n!=null)for(const o in n){const i=n[o];e.indexOf(i.id)===-1&&s.push(i)}s.forEach(o=>{o.isDisposed||o.dispose()})}function cP(n){return n instanceof sn}function k0(n){return Array.isArray(n)}function S2(n){return!cP(n)&&!k0(n)}function C2(n,t,e,s=!0,o=""){if(t==null||t.length===0){if(n!=null){let l=!1;if(k0(n)&&n.length>0)l=!0;else if(S2(n)){for(const u in n)if(n.hasOwnProperty(u)){l=!0;break}}else l=!0;if(l)throw new H(`Error when checking model ${o} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(l=>null);let i;if(S2(n)){n=n,i=[];for(const l of t){if(n[l]==null)throw new H(`No data provided for "${l}". Need data for each key in: ${t}`);i.push(n[l])}}else if(k0(n)){if(n=n,n.length!==t.length)throw new H(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,t.length>1)throw new H(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=cI(i),e!=null)for(let l=0;l<t.length;++l){if(e[l]==null)continue;const u=i[l];if(u.shape.length!==e[l].length)throw new H(`Error when checking ${o}: expected ${t[l]} to have ${e[l].length} dimension(s). but got array with shape ${u.shape}`);for(let c=0;c<e[l].length;++c){if(c===0&&!s)continue;const h=u.shape[c],f=e[l][c];if(f!=null&&f>=0&&h!==f)throw new H(`${o} expected a batch of elements where each example has shape [${e[l].slice(1,e[l].length)}] (i.e.,tensor shape [*,${e[l].slice(1,e[l].length)}]) but the ${o} received an input with ${u.shape[0]} examples, each with shape [${u.shape.slice(1,u.shape.length)}] (tensor shape [${u.shape}])`)}}return i}function hP(n,t,e){const s=ja(n.map(i=>i.shape[0]));s.sort();const o=ja(t.map(i=>i.shape[0]));if(o.sort(),s.length>1)throw new H(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(o.length>1)throw new H(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(s.length>0&&o.length>0&&!ce(s,o))throw new H(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${o[0]} target sample(s).`)}function dP(n,t,e){const s=[Kp,Yp,Xu];for(let o=0;o<n.length;++o){const i=n[o],l=t[o],u=e[o];if(l!=null){if(l===Xu&&i.shape[i.shape.length-1]===1)throw new H(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(l)!==-1){const c=i.shape.slice(1),h=u.slice(1);for(let f=0;f<c.length;++f){const p=c[f],g=h[f];if(g!=null&&p!==g)throw new H(`A target Tensor with shape ${i.shape} was passed for an output of shape ${u}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function $2(n,t,e,s=!0,o=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new H(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new H(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(e!=null)for(let l=0;l<t.length;++l){if(e[l]==null)continue;const u=i[l];if(u.shape.length!==e[l].length)throw new H(`Error when checking ${o}: expected ${t[l]} to have ${e[l].length} dimension(s), but got array with shape ${JSON.stringify(u.shape)}`);for(let c=0;c<e[l].length;++c){if(c===0&&!s)continue;const h=u.shape[c],f=e[l][c];if(f!=null&&f!==h)throw new H(`Error when checking ${o}: expected ${t[l]} to have shape ${JSON.stringify(e[l])} but got array with shape ${JSON.stringify(u.shape)}.`)}}}function fP(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const o of t){let i=e.hasOwnProperty(o)?e[o]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const pP="layers-model";class al extends so{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new H("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");YV(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=KV(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof li))throw new H("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const l in t.loss)if(this.outputNames.indexOf(l)===-1)throw new H(`Unknown entry in loss dictionary: "${l}". Only expected the following keys: ${this.outputNames}`);for(const l of this.outputNames)t.loss[l]==null&&console.warn(`Output "${l}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${l} during training`),e.push(Lx(t.loss[l]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new H(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(u=>Lx(u))}else{const l=Lx(t.loss);this.outputs.forEach(u=>{e.push(l)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let l=0;l<this.outputs.length;++l){const u=this.internalOutputShapes[l],c=this.outputNames[l];this.feedOutputNames.push(c),this.feedOutputShapes.push(u),this.feedLossFns.push(this.lossFunctions[l])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ui("loss",()=>{for(let l=0;l<this.outputs.length;++l){if(s.indexOf(l)!==-1)continue;const u=this.lossFunctions[l];this.outputs.length>1&&(this.metricsTensors.push([u,l]),this.metricsNames.push(this.outputNames[l]+"_loss"))}});const o=fP(t.metrics,this.outputNames),i=(l,u,c)=>{this.outputNames.length>1&&(u=this.outputNames[l]+"_"+u),this.metricsNames.push(u),this.metricsTensors.push([c,l])};Ui("metric",()=>{for(let l=0;l<this.outputs.length;++l){if(s.indexOf(l)!==-1)continue;const u=o[l];(h=>{let p,g,x;for(const b of h){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const S=this.internalOutputShapes[l];S[S.length-1]===1||this.lossFunctions[l]===Yp?["accuracy","acc"].indexOf(b)!==-1?g=eI:["crossentropy","ce"].indexOf(b)!==-1&&(g=BV):this.lossFunctions[l]===vf?["accuracy","acc"].indexOf(b)!==-1?g=UV:["crossentropy","ce"].indexOf(b)!==-1&&(g=oI):["accuracy","acc"].indexOf(b)!==-1?g=nI:["crossentropy","ce"].indexOf(b)!==-1&&(g=sI);let C;["accuracy","acc"].indexOf(b)!==-1?C="acc":["crossentropy","ce"].indexOf(b)!==-1&&(C="ce"),x=g,p=""+C}else x=XV(b),p=""+Ld(b);let v;Ui(p,()=>{v=x}),i(l,p,v)}})(u)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const o=s.batchSize==null?32:s.batchSize;Bx(o);const l=this.standardizeUserDataXY(t,e,!0,o);try{const u=l[0].concat(l[1]);this.makeTestFunction();const c=this.testFunction,h=this.testLoop(c,u,o,s.verbose,s.steps);return jn(h)}finally{no(l[0],t),no(l[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),uP(this,t,e)}checkNumSamples(t,e,s,o="steps"){let i;if(s!=null){if(i=null,e!=null)throw new H(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?i=t[0].shape[0]:i=t.shape[0];else throw new H(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return i}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new H("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),o=s?e:[e],i=this.retrieveSymbolicTensors(o),l=new Ga;if(t instanceof sn&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new H(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)l.add(this.inputs[c],t[c])}else for(const c of this.inputs){const h=t[c.name];if(h==null)throw new H(`No value is provided for the model's input ${c.name}`);l.add(c,h)}const u=Fu(i,l);return s?u:u[0]}retrieveSymbolicTensors(t){const e=Qi(null,t.length);let s=t.length;for(const o of this.layers){const i=Array.isArray(o.output)?o.output:[o.output],l=i.map(u=>u.name);for(let u=0;u<t.length;++u){const c=l.indexOf(t[u]);if(c!==-1&&(e[u]=i[c],s--),s===0)break}if(s===0)break}if(s>0){const o=[];throw e.forEach((i,l)=>{i==null&&o.push(t[l])}),new H(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return e}predictLoop(t,e=32,s=!1){return st(()=>{const o=this.checkNumSamples(t);if(s)throw new Pt("Verbose predictLoop() is not implemented yet.");const i=Ux(o,e),l=this.outputs.map(u=>[]);for(let u=0;u<i.length;++u)st(()=>{const h=i[u][0],f=i[u][1],p=Au(t,h,f),g=[];if(Array.isArray(p))for(let b=0;b<p.length;++b)g.push({key:this.inputs[b],value:p[b]});else g.push({key:this.inputs[0],value:p});const x=new Ga(g);return Fu(this.outputs,x)}).forEach((h,f)=>l[f].push(h));return jn(l.map(u=>Xn(u,0)))})}predict(t,e={}){const s=cI(t);$2(s,this.inputNames,this.feedInputShapes,!1);try{const o=e.batchSize==null?32:e.batchSize;return Bx(o),this.predictLoop(s,o)}finally{no(s,t)}}predictOnBatch(t){$2(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,o){if(this.optimizer_==null)throw new Gs("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let l=0;l<this.feedOutputShapes.length;++l){const u=this.feedOutputShapes[l];this.feedLossFns[l]===vf?i.push(u.slice(0,u.length-1).concat([1])):i.push(u)}if(t=C2(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=C2(e,this.feedOutputNames,i,!1,"target"),hP(t,e),dP(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&t[0].shape[0]%o!==0)throw new H(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,o,i=!0,l){const[u,c]=this.standardizeUserDataXY(t,e,i,l);if(s!=null)throw new Error("sample weight is not supported yet.");let h=null;if(o!=null){const f=rI(o,this.outputNames);h=[];for(let p=0;p<f.length;++p)h.push(await lI(c[p],null,f[p]))}return[u,c,h]}testLoop(t,e,s,o=0,i){return st(()=>{const l=this.checkNumSamples(e,s,i,"steps"),u=[];if(o>0)throw new Pt("Verbose mode is not implemented yet.");if(i!=null)throw new Pt("steps mode in testLoop() is not implemented yet");{const c=Ux(l,s),h=ls(co(0,l));for(let f=0;f<c.length;++f){const p=c[f][0],g=c[f][1],x=Vi(h,p,g-p),b=T0(e,x),v=t(b);if(f===0)for(let S=0;S<v.length;++S)u.push(ue(0));for(let S=0;S<v.length;++S){const C=v[S];u[S]=vt(u[S],K(g-p,C))}}for(let f=0;f<u.length;++f)u[f]=Ot(u[f],l)}return u})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const o=t[s];let i=o;if(l2(t,o)>1){const l=l2(t.slice(0,s),o);i+=`_${l}`}e.push(i)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),l=[],u=()=>{const p=[];for(let v=0;v<this.inputs.length;++v)p.push({key:this.inputs[v],value:s[v]});const g=new Ga(p),x=Fu(this.outputs,g,{training:!0});let b;for(let v=0;v<this.lossFunctions.length;++v){const S=this.lossFunctions[v];let C=S(o[v],x[v]);i[v]!=null&&(C=sP(C,i[v]));const $=Ze(C);e.push($),v===0?b=C:b=vt(b,C)}for(let v=0;v<this.metricsTensors.length;++v){let S;if(this.outputs.length>1&&v<this.outputs.length)S=e[v];else{const C=this.metricsTensors[v][0],$=this.metricsTensors[v][1];S=Ze(C(o[$],x[$]))}No(S),l.push(S)}return b=Ze(b),this.calculateLosses().forEach(v=>{b=vt(b,v)}),b},c=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(u,!0,c)].concat(l)}}makeTestFunction(){this.testFunction=t=>st(()=>{const e=[];let s;const o=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),l=[];for(let h=0;h<this.inputs.length;++h)l.push({key:this.inputs[h],value:o[h]});const u=new Ga(l),c=Fu(this.outputs,u);for(let h=0;h<this.lossFunctions.length;++h){const f=this.lossFunctions[h],p=Ze(f(i[h],c[h]));h===0?s=p:s=vt(s,p),e.push(s)}for(let h=0;h<this.metricsTensors.length;++h){const f=this.metricsTensors[h][0],p=this.metricsTensors[h][1],g=Ze(f(i[p],c[p]));e.push(g)}return e})}async fit(t,e,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let o,i,l,u,c,h,f,p,g;try{const x=s.batchSize==null?32:s.batchSize;Bx(x);const v=await this.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,x);o=v[0],i=v[1],g=v[2];let S=!1,C;if(s.validationData!=null&&s.validationData.length>0){if(S=!0,s.validationData.length===2)c=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new Pt("validationData including sample weights is not supported yet."):new H(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const F=await this.standardizeUserData(c,h,null,null,!0,x);f=F[0],p=F[1],C=f.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){S=!0;const O=Math.floor(o[0].shape[0]*(1-s.validationSplit)),F=o[0].shape[0];f=Au(o,O,F),l=o,o=Au(o,0,O),p=Au(i,O,F),u=i,i=Au(i,0,O),C=f.concat(p)}else s.validationSteps!=null&&(S=!0);const $=o.concat(i).concat(g);this.checkTrainableWeightsConsistency();const k=this.makeTrainFunction(),T=this.getDedupedMetricsNames();let N,R;S?(this.makeTestFunction(),N=this.testFunction,R=T.slice().concat(T.map(O=>"val_"+O))):(N=null,C=[],R=T.slice());const D=Qk(s.callbacks,s.yieldEvery);return await this.fitLoop(k,$,T,x,s.epochs,s.verbose,D,N,C,s.shuffle,R,s.initialEpoch,null,null)}finally{this.isTraining=!1,no(o,t),no(i,e),no(l,t),no(u,e),no(f,c),no(p,h),g!=null&&Wt(g)}}async fitLoop(t,e,s,o,i,l,u,c,h,f,p,g,x,b){o==null&&(o=32),i==null&&(i=1),f==null&&(f=!0),g==null&&(g=0);let v=!1;if(c!=null&&h!=null&&(v=!0),b!=null&&(v=!0,x==null))throw new H("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const S=this.checkNumSamples(e,o,x,"steps_per_epoch");let C;S!=null&&(C=co(0,S)),l==null&&(l=1);const{callbackList:$,history:k}=Jk(u,l,i,g,S,x,o,v,p);$.setModel(this),this.history=k,await $.onTrainBegin(),this.stopTraining_=!1;for(let T=g;T<i;++T){await $.onEpochBegin(T);const N={};if(x!=null)throw new Pt("stepsPerEpoch mode is not implemented yet.");{if(f==="batch")throw new Pt("batch shuffling is not implemneted yet");f&&OO(C);const R=ls(C),D=Ux(S,o);for(let z=0;z<D.length;++z){const O={};if(await $.onBatchBegin(z,O),st(()=>{const F=D[z][0],E=D[z][1],U=Vi(R,F,E-F);O.batch=z,O.size=E-F;const Y=T0(e,U),X=t(Y);for(let q=0;q<s.length;++q){const L=s[q],P=X[q];O[L]=P,No(P)}if(z===D.length-1&&v){const q=this.testLoop(c,h,o);for(let L=0;L<s.length;++L){const P=s[L],W=q[L];No(W),N["val_"+P]=W}}}),await $.onBatchEnd(z,O),Zk(O),this.stopTraining_)break}R.dispose()}if(await $.onEpochEnd(T,N),this.stopTraining_)break}return await $.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return iP(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),o=s[0],i=s[1],u=this.makeTrainFunction()(o.concat(i)),c=[];for(const h of u){const f=await h.data();c.push(f[0])}return Wt(u),no(s[0],t),no(s[1],e),jn(c)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,o=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let l=0;l<o.length;++l)s&&!o[l].trainable||e.push({name:o[l].originalName,tensor:i[l]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=_C().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-_C().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=aa(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>aa(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const o of e)if(typeof s[o]=="string")t[o]=aa(s[o]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[aa(Ld(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>aa(Ld(t)));{const t={};for(const e in this.metrics)t[e]=aa(Ld(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=$f(t.optimizer_config),s=Do(e);let o;if(typeof t.loss=="string")o=Fi(t.loss);else if(Array.isArray(t.loss))o=t.loss.map(l=>Fi(l));else if(t.loss!=null){o={};for(const l in t.loss)o[l]=Fi(t.loss[l])}let i;if(Array.isArray(t.metrics))i=t.metrics.map(l=>Fi(l));else if(t.metrics!=null){i={};for(const l in t.metrics)i[l]=Fi(t.metrics[l])}this.compile({loss:o,metrics:i,optimizer:s})}async save(t,e){if(typeof t=="string"){const h=z_(t);if(h.length===0)throw new H(`Cannot find any save handlers for URL '${t}'`);if(h.length>1)throw new H(`Found more than one (${h.length}) save handlers for URL '${t}'`);t=h[0]}if(t.save==null)throw new H("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await FC(this.getNamedWeights(e)),u={modelTopology:this.toJSON(null,!1),format:pP,generatedBy:`TensorFlow.js tfjs-layers v${iI}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){u.trainingConfig=this.getTrainingConfig();const h="optimizer",{data:f,specs:p}=await FC(await this.optimizer.getWeights(),h);s.specs.push(...p),s.data=E_([s.data,f])}return this.userDefinedMetadata!=null&&(y2(this.userDefinedMetadata,this.name,!0),u.userDefinedMetadata=this.userDefinedMetadata),u.weightData=s.data,u.weightSpecs=s.specs,t.save(u)}setUserDefinedMetadata(t){y2(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}al.className="Model";bt(al);class hI extends al{}hI.className="Functional";bt(hI);async function T2(n,t){if(t==null&&(t={}),typeof n=="string"){const e=L_(n,t);if(e.length===0)e.push(y4(n,t));else if(e.length>1)throw new H(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return mP(n,void 0,t)}async function mP(n,t,e){if(e==null&&(e={}),n.load==null)throw new H("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let o=s.modelTopology;o.model_config!=null&&(o=o.model_config);const i=e.strict==null?!0:e.strict,l=s.weightData!=null&&s.weightSpecs!=null&&i,u=Do($f(o),t,l),c=s.trainingConfig;if(c!=null&&u.loadTrainingConfig(c),s.userDefinedMetadata!=null&&u.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new H("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:h,optimizerWeights:f}=gP(s.weightData,s.weightSpecs);u.loadWeights(h,i),u.optimizer!=null&&f.length>0&&await u.optimizer.setWeights(f),Wt(h),Wt(f.map(p=>p.tensor))}return u}function gP(n,t){const e=C_(n,t),s={},o=[];return t.forEach(i=>{i.group==="optimizer"?o.push({name:i.name,tensor:e[i.name]}):s[i.name]=e[i.name]}),{modelWeights:s,optimizerWeights:o}}class fl extends al{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:qp("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new H(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof fl||t instanceof al;let s;if(e){if(s=t,s.outputs.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new H("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new H("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=gV({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(o)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new H(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=qk(this.outputs[0])}this.inboundNodes=[],new Xp({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Qi(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=t.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(se(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new al({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new Gs("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new Gs("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new Gs("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new Gs("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},o=!1){let i,l={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new H("Legacy serialization format not supported yet.");i=e}else _(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,l=e;const u=new t(l);if(!(u instanceof fl))throw new Pt(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(const c of i){const f=Do(c,void 0,o);o&&f.setFastWeightInitDuringBuild(!0),u.add(f)}return u}set stopTraining(t){if(this.model==null)throw new H("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new H("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}fl.className="Sequential";bt(fl);function xP(n){return new fl(n)}let On=class extends Tl{getConfig(){return{}}};class dI extends On{apply(t,e=1){return tV(t,e)}}dI.className="elu";bt(dI);class fI extends On{apply(t){return OT(t)}}fI.className="selu";bt(fI);class pI extends On{apply(t){return or(t)}}pI.className="relu";bt(pI);class mI extends On{apply(t){return st(()=>Hu(6,or(t)))}}mI.className="relu6";bt(mI);class gI extends On{apply(t){return t}}gI.className="linear";bt(gI);class xI extends On{apply(t){return Sl(t)}}xI.className="sigmoid";bt(xI);class bI extends On{apply(t){return nV(t)}}bI.className="hardSigmoid";bt(bI);class yI extends On{apply(t){return Zc(t)}}yI.className="softplus";bt(yI);class vI extends On{apply(t){return eV(t)}}vI.className="softsign";bt(vI);class wI extends On{apply(t){return zp(t)}}wI.className="tanh";bt(wI);let Gy=class extends On{apply(t,e=-1){return Yb(t,e)}};Gy.className="softmax";bt(Gy);class SI extends On{apply(t,e=-1){return TT(t,e)}}SI.className="logSoftmax";bt(SI);class CI extends On{apply(t){return st(()=>st(()=>{const e=Math.sqrt(2),s=K(.5,vt(1,vT(Ot(t,e))));return K(t,s)}))}}CI.className="gelu";bt(CI);class $I extends On{apply(t){return st(()=>K(.5,K(t,vt(1,zp(K(An(Ot(2,Math.PI)),vt(t,K(.044715,Ki(t,3)))))))))}}$I.className="gelu_new";bt($I);class TI extends On{apply(t){return st(()=>K(t,zp(Zc(t))))}}TI.className="mish";bt(TI);class kI extends On{apply(t,e=1){return st(()=>K(Sl(K(t,e)),t))}}kI.className="swish";bt(kI);function Za(n){return n.getClassName()}function Vx(n,t={}){return oh(n,Ps.getMap().classNameMap,t,"activation")}function Qa(n){if(n==null){const t={};return t.className="linear",t.config={},Vx(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},Vx(t)}else return n instanceof On?n:Vx(n)}function bP(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class II extends Tl{}class NI extends II{constructor(t){super(),bP(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return st(()=>{let e=pn([1]);return this.hasL1&&(e=vt(e,At(K(this.l1,Mn(t))))),this.hasL2&&(e=vt(e,At(K(this.l2,ih(t))))),J(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}NI.className="L1L2";bt(NI);const k2={l1l2:"L1L2"};function Te(n){return Ey(n)}function I2(n,t={}){return oh(n,Ps.getMap().classNameMap,t,"regularizer")}function Me(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in k2?k2[n]:n,config:{}};return I2(e)}else return n instanceof II?n:I2(n)}class EI extends jt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=Mt(t);let s=or(t);return this.maxValue!=null&&(s=Ts(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}EI.className="ReLU";bt(EI);class RI extends jt{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=Mt(t);return Ub(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}RI.className="LeakyReLU";bt(RI);class AI extends jt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Fe(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Me(t.alphaRegularizer),this.alphaConstraint=ln(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new H(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=se(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const o of this.sharedAxes)e[o-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let o=1;o<t.length;++o)s[o]=t[o];this.inputSpec=[new an({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=Mt(t),qb(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Le(this.alphaInitializer),alphaRegularizer:Te(this.alphaRegularizer),alphaConstraint:rn(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}AI.className="PReLU";bt(AI);let DI=class extends jt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Pt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=Mt(t);return Up(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};DI.className="ELU";bt(DI);class OI extends jt{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=Mt(t);return K(s,$t(ks(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}OI.className="ThresholdedReLU";bt(OI);class _I extends jt{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new Gy().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return st(()=>{let s=Mt(t);const o=e.mask;if(o!=null){const i=K(Ft(ri(s.shape),$t(o,s.dtype)),ue(-1e9));s=vt(s,i)}return this.axis instanceof Array?this.axis.length>1?_o(Ft(s,kT(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}_I.className="Softmax";bt(_I);function il(n,t,e){if(typeof n=="number")return Qi(n,t);if(n.length!==t)throw new H(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const o=n[s];if(!YU(o))throw new H(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${o}`)}return n}function uo(n,t,e,s,o=1){if(n==null)return n;const i=t+(t-1)*(o-1);let l;return e==="same"?l=n:l=n-i+1,Math.floor((l+s-1)/s)}function To(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+Ya([e-t,0]);else if(s==="same")n=n*t;else throw new H(`Unsupport padding mode: ${s}.`);return n}function Wy(n,t){return st(()=>(je(t),t==="channelsFirst"?Jt(n,[0,2,3,1]):n))}function FI(n,t){return st(()=>(je(t),t==="channelsFirst"?Jt(n,[0,2,3,4,1]):n))}function yP(n,t,e,s=1,o="valid",i,l=1){return st(()=>{if(i==null&&(i=ho()),je(i),n.shape.length!==3)throw new H(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new H(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new H(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=Jt(n,[0,2,1])),o==="causal")throw new Pt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let u=mT(n,t,s,o==="same"?"same":"valid","NWC",l);return e!=null&&(u=po(u,e)),u})}function N2(n,t,e,s=[1,1],o="valid",i,l,u=null){return st(()=>{if(i==null&&(i=ho()),je(i),n.rank!==3&&n.rank!==4)throw new H(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new H(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let c=Wy(n,i);if(o==="causal")throw new Pt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=gL({x:c,filter:t,strides:s,pad:o==="same"?"same":"valid",dilations:l,dataFormat:"NHWC",bias:e,activation:u}),i==="channelsFirst"&&(c=Jt(c,[0,3,1,2])),c})}function vP(n,t,e,s=[1,1,1],o="valid",i,l){return st(()=>{if(i==null&&(i=ho()),je(i),n.rank!==4&&n.rank!==5)throw new H(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new H(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let u=FI(n,i);if(o==="causal")throw new Pt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return u=pF(u,t,s,o==="same"?"same":"valid","NDHWC",l),e!=null&&(u=po(u,e)),i==="channelsFirst"&&(u=Jt(u,[0,4,1,2,3])),u})}class Zp extends jt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Zp.verifyArgs(e),this.rank=t,mn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Pt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=il(e.kernelSize,t,"kernelSize"),this.strides=il(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,Is(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,je(this.dataFormat),this.activation=Qa(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Fe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ln(e.biasConstraint),this.biasRegularizer=Me(e.biasRegularizer),this.activityRegularizer=Me(e.activityRegularizer),this.dilationRate=il(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new H(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new H(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new H(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if($o("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!Ry(t.kernelSize,"number",1,3))throw new H(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Za(this.activation),useBias:this.useBias,biasInitializer:Le(this.biasInitializer),biasRegularizer:Te(this.biasRegularizer),activityRegularizer:Te(this.activityRegularizer),biasConstraint:rn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class kl extends Zp{constructor(t,e){super(t,e),this.kernel=null,kl.verifyArgs(e),this.filters=e.filters,mn(this.filters,"filters"),this.kernelInitializer=Fe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ln(e.kernelConstraint),this.kernelRegularizer=Me(e.kernelRegularizer)}build(t){t=se(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new H(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],o=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return st(()=>{t=Mt(t);let s;const o=this.bias==null?null:this.bias.read(),i=Ak(this.activation.getClassName());if(i!=null&&this.rank===2)s=N2(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=yP(t,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=N2(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=vP(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Pt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=se(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<s.length;++i){const l=uo(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);e.push(l)}let o=[t[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){const t={filters:this.filters,kernelInitializer:Le(this.kernelInitializer),kernelRegularizer:Te(this.kernelRegularizer),kernelConstraint:rn(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new H(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class ch extends kl{constructor(t){super(2,t),ch.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Ry(t.kernelSize,"number",1,2))throw new H(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}ch.className="Conv2D";bt(ch);class hh extends kl{constructor(t){super(3,t),hh.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new H(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}hh.className="Conv3D";bt(hh);class MI extends ch{constructor(t){if(super(t),this.inputSpec=[new an({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=se(t),t.length!==4)throw new H("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new an({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return st(()=>{let s=Mt(t);if(s.shape.length!==4)throw new H(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape,i=o[0];let l,u;this.dataFormat==="channelsFirst"?(l=2,u=3):(l=1,u=2);const c=o[l],h=o[u],f=this.kernelSize[0],p=this.kernelSize[1],g=this.strides[0],x=this.strides[1],b=To(c,g,f,this.padding),v=To(h,x,p,this.padding),S=[i,b,v,this.filters];this.dataFormat!=="channelsLast"&&(s=Jt(s,[0,2,3,1]));let C=gT(s,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(C=Jt(C,[0,3,1,2])),this.bias!=null&&(C=po(C,this.bias.read(),this.dataFormat)),this.activation!=null&&(C=this.activation.apply(C)),C})}computeOutputShape(t){t=se(t);const e=t.slice();let s,o,i;this.dataFormat==="channelsFirst"?(s=1,o=2,i=3):(s=3,o=1,i=2);const l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],h=this.strides[1];return e[s]=this.filters,e[o]=To(e[o],c,l,this.padding),e[i]=To(e[i],h,u,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}MI.className="Conv2DTranspose";bt(MI);class zI extends hh{constructor(t){if(super(t),this.inputSpec=[new an({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=se(t),t.length!==5)throw new H("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new an({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return st(()=>{let s=Mt(t);if(s.shape.length!==5)throw new H(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape,i=o[0];let l,u,c;this.dataFormat==="channelsFirst"?(c=2,l=3,u=4):(c=1,l=2,u=3);const h=o[c],f=o[l],p=o[u],g=this.kernelSize[0],x=this.kernelSize[1],b=this.kernelSize[2],v=this.strides[0],S=this.strides[1],C=this.strides[2],$=To(h,v,g,this.padding),k=To(f,S,x,this.padding),T=To(p,C,b,this.padding),N=[i,$,k,T,this.filters];this.dataFormat!=="channelsLast"&&(s=Jt(s,[0,2,3,4,1]));let R=xF(s,this.kernel.read(),N,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(R=Jt(R,[0,4,1,2,3])),this.bias!==null&&(R=po(R,this.bias.read(),this.dataFormat)),this.activation!==null&&(R=this.activation.apply(R)),R})}computeOutputShape(t){t=se(t);const e=t.slice();let s,o,i,l;this.dataFormat==="channelsFirst"?(s=1,o=2,i=3,l=4):(s=4,o=1,i=2,l=3);const u=this.kernelSize[0],c=this.kernelSize[1],h=this.kernelSize[2],f=this.strides[0],p=this.strides[1],g=this.strides[2];return e[s]=this.filters,e[o]=To(e[o],f,u,this.padding),e[i]=To(e[i],p,c,this.padding),e[l]=To(e[l],g,h,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}zI.className="Conv3DTranspose";bt(zI);class LI extends kl{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new H("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new H("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new H(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Fe(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Me(e.depthwiseRegularizer),this.depthwiseConstraint=ln(e.depthwiseConstraint),this.pointwiseInitializer=Fe(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Me(e.pointwiseRegularizer),this.pointwiseConstraint=ln(e.pointwiseConstraint)}build(t){if(t=se(t),t.length<this.rank+2)throw new H(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new H(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],o=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let u=0;u<this.rank;++u)i.push(1);i.push(s*this.depthMultiplier,this.filters);const l=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,l,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,l,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,l,this.biasConstraint):this.bias=null,this.inputSpec=[new an({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return st(()=>{t=Mt(t);let s;if(this.rank===1)throw new Pt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Jt(t,[0,2,3,1])),s=_T(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=po(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Jt(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Le(this.depthwiseInitializer),t.pointwiseInitializer=Le(this.pointwiseInitializer),t.depthwiseRegularizer=Te(this.depthwiseRegularizer),t.pointwiseRegularizer=Te(this.pointwiseRegularizer),t.depthwiseConstraint=rn(this.depthwiseConstraint),t.pointwiseConstraint=rn(this.pointwiseConstraint),t}}LI.className="SeparableConv";class BI extends LI{constructor(t){super(2,t)}}BI.className="SeparableConv2D";bt(BI);class Qp extends kl{constructor(t){super(1,t),Qp.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Ry(t.kernelSize,"number",1,1))throw new H(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}Qp.className="Conv1D";bt(Qp);class UI extends jt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return st(()=>{if(t=Mt(t),this.dataFormat==="channelsLast"){const s=zd(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return zd(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=zd(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return zd(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}UI.className="Cropping2D";bt(UI);class VI extends jt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,je(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,jU(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return st(()=>{let s=Mt(t);const o=s.shape;if(this.dataFormat==="channelsFirst"){s=Jt(s,[0,2,3,1]);const i=this.size[0]*o[2],l=this.size[1]*o[3],u=this.interpolation==="nearest"?ra.resizeNearestNeighbor(s,[i,l]):ra.resizeBilinear(s,[i,l]);return Jt(u,[0,3,1,2])}else{const i=this.size[0]*o[1],l=this.size[1]*o[2];return this.interpolation==="nearest"?ra.resizeNearestNeighbor(s,[i,l]):ra.resizeBilinear(s,[i,l])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}VI.className="UpSampling2D";bt(VI);function wP(n,t,e=[1,1],s="valid",o,i){return st(()=>{o==null&&(o=ho()),je(o);let l=Wy(n,o);if(n.rank!==4)throw new H(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new H(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return l=Mb(l,t,e,s==="same"?"same":"valid","NHWC",i),o==="channelsFirst"&&(l=Jt(l,[0,3,1,2])),l})}class PI extends Zp{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Fe(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ln(t.depthwiseConstraint),this.depthwiseRegularizer=Me(t.depthwiseRegularizer)}build(t){if(t=se(t),t.length<4)throw new H(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new H(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],o=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return st(()=>{t=Mt(t);let s=wP(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=po(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=se(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=uo(e,this.kernelSize[0],this.padding,this.strides[0]),l=uo(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],o,i,l]:[t[0],i,l,o]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Le(this.depthwiseInitializer),t.depthwiseRegularizer=Te(this.depthwiseRegularizer),t.depthwiseConstraint=rn(this.depthwiseRegularizer),t}}PI.className="DepthwiseConv2D";bt(PI);function GI(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new H("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function o(i){return i==null||Array.isArray(i)?i:[i]}return t=o(t),e=o(e),{inputs:n,initialState:t,constants:e}}function WI(n,t,e,s=!1,o,i,l=!1,u=!1){return st(()=>{const c=t.shape.length;if(c<3)throw new H(`Input should be at least 3D, but is ${c}D.`);const h=[1,0].concat(co(2,c));t=Jt(t,h),l&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=$t($t(o,"bool"),"float32"),o.rank===c-1&&(o=qn(o,-1)),o=Jt(o,h)),s&&(t=Yi(t,0),o!=null&&(o=Yi(o,0)));const f=[];let p,g=e;const x=t.shape[0],b=Zi(t);let v;o!=null&&(v=Zi(o));for(let C=0;C<x;++C){const $=b[C],k=st(()=>n($,g));if(o==null)p=k[0],g=k[1];else{const T=st(()=>{const N=v[C],R=Ft(qs(N),N),D=vt(K(k[0],N),K(g[0],R)),z=g.map((O,F)=>vt(K(k[1][F],N),K(O,R)));return{output:D,newStates:z}});p=T.output,g=T.newStates}u&&f.push(p)}let S;return u&&(S=ua(f,1)),[p,S,g]})}class ui extends jt{constructor(t){super(t);let e;if(t.cell==null)throw new H("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new jy({cells:t.cell}):e=t.cell,e.stateSize==null)throw new H("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new an({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return co(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){w0(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let o;if(this.returnSequences?o=[t[0],t[1],s]:o=[t[0],s],this.returnState){const i=[];for(const l of e)i.push([t[0],l]);return[o].concat(i)}else return o}computeMask(t,e){return st(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const o=this.states.map(i=>null);return[s].concat(o)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Pt("Constants support is not implemented in RNN yet.");w0(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new an({shape:[e,null,...s]});const o=[t[0]].concat(t.slice(2));this.cell.build(o);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!ce(this.stateSpec.map(l=>l.shape[l.shape.length-1]),i))throw new H(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(l=>new an({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){st(()=>{if(!this.stateful)throw new Co("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>pn([s,o])):this.states_=[pn([s,this.cell.stateSize])];else if(t==null)Wt(this.states_),this.keptStates!=null&&(Wt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>pn([s,o])):this.states_[0]=pn([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):Wt(this.states_);for(let o=0;o<this.states_.length;++o){const i=t[o],l=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,u=[s,l];if(!ce(i.shape,u))throw new H(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>No(o.clone()))})}apply(t,e){let s=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});const i=GI(t,s,o,this.numConstants);t=i.inputs,s=i.initialState,o=i.constants;let l=[],u=[];if(s!=null){e.initialState=s,l=l.concat(s),this.stateSpec=[];for(const h of s)this.stateSpec.push(new an({shape:h.shape}));u=u.concat(this.stateSpec)}if(o!=null&&(e.constants=o,l=l.concat(o),this.numConstants=o.length),l[0]instanceof Mo){const h=[t].concat(l),f=this.inputSpec.concat(u),p=this.inputSpec;this.inputSpec=f;const g=super.apply(h,e);return this.inputSpec=p,g}else return super.apply(t,e)}call(t,e){return st(()=>{const s=e==null?null:e.mask,o=e==null?null:e.training;let i=e==null?null:e.initialState;t=Mt(t),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(t));const l=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==l)throw new H(`RNN Layer has ${l} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const u={training:o},h=WI((b,v)=>{const S=this.cell.call([b].concat(v),u);return[S[0],S.slice(1)]},t,i,this.goBackwards,s,null,this.unroll,this.returnSequences),f=h[0],p=h[1],g=h[2];this.stateful&&this.resetStates(g,o);const x=this.returnSequences?p:f;return this.returnState?[x].concat(g):x})}getInitialState(t){return st(()=>{let e=pn(t.shape);return e=At(e,[1,2]),e=ah(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?y0(e,[1,s]):e):this.cell.stateSize>1?[y0(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===ui.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),e)}static fromConfig(t,e,s={}){const o=e.cell,i=Do(o,s);return new t(Object.assign(e,{cell:i}))}}ui.className="RNN";bt(ui);class Jp extends jt{}class Hy extends Jp{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,mn(this.units,"units"),this.activation=Qa(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Fe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Fe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Fe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Me(t.kernelRegularizer),this.recurrentRegularizer=Me(t.recurrentRegularizer),this.biasRegularizer=Me(t.biasRegularizer),this.kernelConstraint=ln(t.kernelConstraint),this.recurrentConstraint=ln(t.recurrentConstraint),this.biasConstraint=ln(t.biasConstraint),this.dropout=dl([1,Ya([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dl([1,Ya([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=se(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return st(()=>{if(t=t,t.length!==2)throw new H(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const o=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ja({ones:()=>qs(t),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ja({ones:()=>qs(s),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let i;const l=this.dropoutMask,u=this.recurrentDropoutMask;l!=null?i=Ao(K(t,l),this.kernel.read()):i=Ao(t,this.kernel.read()),this.bias!=null&&(i=po(i,this.bias.read())),u!=null&&(s=K(s,u));let c=vt(i,Ao(s,this.recurrentKernel.read()));return this.activation!=null&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Za(this.activation),useBias:this.useBias,kernelInitializer:Le(this.kernelInitializer),recurrentInitializer:Le(this.recurrentInitializer),biasInitializer:Le(this.biasInitializer),kernelRegularizer:Te(this.kernelRegularizer),recurrentRegularizer:Te(this.recurrentRegularizer),biasRegularizer:Te(this.biasRegularizer),activityRegularizer:Te(this.activityRegularizer),kernelConstraint:rn(this.kernelConstraint),recurrentConstraint:rn(this.recurrentConstraint),biasConstraint:rn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}Hy.className="SimpleRNNCell";bt(Hy);class HI extends ui{constructor(t){t.cell=new Hy(t),super(t)}call(t,e){return st(()=>{this.cell.dropoutMask!=null&&(Wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,o=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:o,initialState:i})})}static fromConfig(t,e){return new t(e)}}HI.className="SimpleRNN";bt(HI);class qy extends Jp{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new H("GRUCell does not support reset_after parameter set to true.");this.units=t.units,mn(this.units,"units"),this.activation=Qa(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Qa(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Fe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Fe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Fe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Me(t.kernelRegularizer),this.recurrentRegularizer=Me(t.recurrentRegularizer),this.biasRegularizer=Me(t.biasRegularizer),this.kernelConstraint=ln(t.kernelConstraint),this.recurrentConstraint=ln(t.recurrentConstraint),this.biasConstraint=ln(t.biasConstraint),this.dropout=dl([1,Ya([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dl([1,Ya([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=se(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return st(()=>{if(t=t,t.length!==2)throw new H(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let o=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ja({ones:()=>qs(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ja({ones:()=>qs(o),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,l=this.recurrentDropoutMask;let u,c,h;0<this.dropout&&this.dropout<1&&(t=K(t,i[0]));let f=Ao(t,this.kernel.read());this.useBias&&(f=po(f,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=K(o,l[0]));const p=this.recurrentKernel.read(),[g,x]=$s(p,[2*this.units,this.units],p.rank-1),b=Ao(o,g),[v,S,C]=$s(f,3,f.rank-1),[$,k]=$s(b,2,b.rank-1);u=this.recurrentActivation.apply(vt(v,$)),c=this.recurrentActivation.apply(vt(S,k));const T=Ao(K(c,o),x);h=this.activation.apply(vt(C,T));const N=vt(K(u,o),K(vt(1,We(u)),h));return[N,N]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Za(this.activation),recurrentActivation:Za(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Le(this.kernelInitializer),recurrentInitializer:Le(this.recurrentInitializer),biasInitializer:Le(this.biasInitializer),kernelRegularizer:Te(this.kernelRegularizer),recurrentRegularizer:Te(this.recurrentRegularizer),biasRegularizer:Te(this.biasRegularizer),activityRegularizer:Te(this.activityRegularizer),kernelConstraint:rn(this.kernelConstraint),recurrentConstraint:rn(this.recurrentConstraint),biasConstraint:rn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}qy.className="GRUCell";bt(qy);class qI extends ui{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new qy(t),super(t)}call(t,e){return st(()=>{this.cell.dropoutMask!=null&&(Wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,o=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:o,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}qI.className="GRU";bt(qI);class tm extends Jp{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,mn(this.units,"units"),this.activation=Qa(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Qa(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Fe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Fe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Fe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Me(t.kernelRegularizer),this.recurrentRegularizer=Me(t.recurrentRegularizer),this.biasRegularizer=Me(t.biasRegularizer),this.kernelConstraint=ln(t.kernelConstraint),this.recurrentConstraint=ln(t.recurrentConstraint),this.biasConstraint=ln(t.biasConstraint),this.dropout=dl([1,Ya([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=dl([1,Ya([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=se(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,l=this.units;o=new(e=class extends Xs{apply(c,h){const f=i.apply([l]),p=new Dy().apply([l]),g=i.apply([l*2]);return c2(c2(f,p),g)}},e.className="CustomInit",e)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return st(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new H(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let o=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ja({ones:()=>qs(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ja({ones:()=>qs(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=this.recurrentDropoutMask;let c,h,f,p;0<this.dropout&&this.dropout<1&&(t=K(t,l[0]));let g=Ao(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=K(o,u[0])),g=vt(g,Ao(o,this.recurrentKernel.read())),this.useBias&&(g=po(g,this.bias.read()));const[x,b,v,S]=$s(g,4,g.rank-1);c=this.recurrentActivation.apply(x),h=this.recurrentActivation.apply(b),f=vt(K(h,i),K(c,this.activation.apply(v))),p=this.recurrentActivation.apply(S);const C=K(p,this.activation.apply(f));return[C,C,f]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Za(this.activation),recurrentActivation:Za(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Le(this.kernelInitializer),recurrentInitializer:Le(this.recurrentInitializer),biasInitializer:Le(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Te(this.kernelRegularizer),recurrentRegularizer:Te(this.recurrentRegularizer),biasRegularizer:Te(this.biasRegularizer),activityRegularizer:Te(this.activityRegularizer),kernelConstraint:rn(this.kernelConstraint),recurrentConstraint:rn(this.recurrentConstraint),biasConstraint:rn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}tm.className="LSTMCell";bt(tm);class jI extends ui{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new tm(t),super(t)}call(t,e){return st(()=>{this.cell.dropoutMask!=null&&(Wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,o=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:o,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}jI.className="LSTM";bt(jI);class jy extends Jp{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return st(()=>{t=t;let s=t.slice(1);const o=[];for(const u of this.cells.slice().reverse())Array.isArray(u.stateSize)?o.push(s.splice(0,u.stateSize.length)):o.push(s.splice(0,1));o.reverse();const i=[];let l;for(let u=0;u<this.cells.length;++u){const c=this.cells[u];s=o[u],u===0?l=[t[0]].concat(s):l=[l[0]].concat(s),l=c.call(l,e),i.push(l.slice(1))}s=[];for(const u of i.slice().reverse())s.push(...u);return[l[0]].concat(s)})}build(t){w0(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,o)=>{Ui(`RNNCell_${o}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=i=>({className:i.getClassName(),config:i.getConfig()}),o={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),o)}static fromConfig(t,e,s={}){const o=[];for(const i of e.cells)o.push(Do(i,s));return new t({cells:o})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return S0(t)}setWeights(t){const e=[];for(const s of this.cells){const o=s.weights.length,i=t.splice(o);for(let l=0;l<s.weights.length;++l)e.push([s.weights[l],i[l]])}By(e)}}jy.className="StackedRNNCells";bt(jy);function Ja(n){const{ones:t,rate:e,training:s=!1,count:o=1,dropoutFunc:i}=n,l=()=>i!=null?i(t(),e):Lk(t(),e),u=()=>rh(l,t,s);return!o||o<=1?No(u().clone()):Array(o).fill(void 0).map(u).map(h=>No(h.clone()))}var SP=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,s=Object.getOwnPropertySymbols(n);o<s.length;o++)t.indexOf(s[o])<0&&Object.prototype.propertyIsEnumerable.call(n,s[o])&&(e[s[o]]=n[s[o]]);return e};class XI extends ui{constructor(t){if(t.unroll)throw new Pt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Pt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new an({ndim:5})]}call(t,e){return st(()=>{if(this.cell.dropoutMask!=null&&(Wt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Wt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new H("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,o=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:o,initialState:i})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return st(()=>{const{stateSize:e}=this.cell,s=t.shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)],l=pn(i);return Array.isArray(e)?Array(e.length).fill(l):[l]})}resetStates(t,e=!1){st(()=>{if(!this.stateful)throw new Co("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)];if(s[0]==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>pn(i)):this.states_=[pn(i)];else if(t==null)Wt(this.states_),this.keptStates!=null&&(Wt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>pn(i)):this.states_[0]=pn(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Wt(this.states_);for(let u=0;u<this.states_.length;++u){const c=t[u],h=i;if(!ce(c.shape,h))throw new H(`State ${u} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${c.shape}`);this.states_[u]=c}}this.states_=this.states_.map(u=>No(u.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:o,padding:i,strides:l,dilationRate:u}=this.cell,c=e==="channelsFirst",h=t[c?3:2],f=t[c?4:3],p=uo(h,o[0],i,l[0],u[0]),g=uo(f,o[1],i,l[1],u[1]);return[...t.slice(0,2),...c?[s,p,g]:[p,g,s]]}}XI.className="ConvRNN2D";class Xy extends tm{constructor(t){const{filters:e,kernelSize:s,strides:o,padding:i,dataFormat:l,dilationRate:u}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,mn(this.filters,"filters"),this.kernelSize=il(s,2,"kernelSize"),this.kernelSize.forEach(c=>mn(c,"kernelSize")),this.strides=il(o||1,2,"strides"),this.strides.forEach(c=>mn(c,"strides")),this.padding=i||"valid",Is(this.padding),this.dataFormat=l||"channelsLast",je(this.dataFormat),this.dilationRate=il(u||1,2,"dilationRate"),this.dilationRate.forEach(c=>mn(c,"dilationRate"))}build(t){var e;t=se(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new H(`The channel dimension of the input should be defined. Found ${t[s]}`);const o=t[s],i=4,l=this.kernelSize.concat([o,this.filters*i]);this.kernel=this.addWeight("kernel",l,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const u=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",u,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const h=this.biasInitializer,f=this.filters;c=new(e=class extends Xs{apply(g,x){const b=h.apply([f]),v=ri([f]),S=h.apply([f*2]);return Ay([b,v,S])}},e.className="CustomInit",e)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return st(()=>{if(t.length!==3)throw new H(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,o=t[0],i=t[1],l=t[2],u=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ja({ones:()=>qs(o),rate:this.dropout,training:s,count:u,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,h=(it,M,G)=>!M||!M[G]?it:K(M[G],it);let f=h(o,c,0),p=h(o,c,1),g=h(o,c,2),x=h(o,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ja({ones:()=>qs(i),rate:this.recurrentDropout,training:s,count:u,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let v=h(i,b,0),S=h(i,b,1),C=h(i,b,2),$=h(i,b,3);const k=3,[T,N,R,D]=$s(this.kernel.read(),u,k),[z,O,F,E]=this.useBias?$s(this.bias.read(),u):[null,null,null,null];f=this.inputConv(f,T,z,this.padding),p=this.inputConv(p,N,O,this.padding),g=this.inputConv(g,R,F,this.padding),x=this.inputConv(x,D,E,this.padding);const[U,Y,X,q]=$s(this.recurrentKernel.read(),u,k);v=this.recurrentConv(v,U),S=this.recurrentConv(S,Y),C=this.recurrentConv(C,X),$=this.recurrentConv($,q);const L=this.recurrentActivation.apply(vt(f,v)),P=this.recurrentActivation.apply(vt(p,S)),W=vt(K(P,l),K(L,this.activation.apply(vt(g,C)))),nt=K(this.recurrentActivation.apply(vt(x,$)),this.activation.apply(W));return[nt,nt,W]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=SP(t,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),o)}inputConv(t,e,s,o){const i=Xi(t,e,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?po(i,s,this.dataFormat):i}recurrentConv(t,e){return Xi(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}Xy.className="ConvLSTM2DCell";bt(Xy);class KI extends XI{constructor(t){const e=new Xy(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}KI.className="ConvLSTM2D";bt(KI);class Ky extends jt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(this.noiseShape[o]==null?e[o]:this.noiseShape[o]);return s}call(t,e){return st(()=>{this.invokeCallHook(t,e);const s=Mt(t);if(0<this.rate&&this.rate<1){const o=e.training==null?!1:e.training,i=this.getNoiseShape(s);return rh(()=>Lk(s,this.rate,i,this.seed),()=>s,o)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}Ky.className="Dropout";bt(Ky);class YI extends Ky{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}YI.className="SpatialDropout1D";bt(YI);class Yy extends jt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,mn(this.units,"units"),this.activation=Qa(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Fe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Fe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ln(t.kernelConstraint),this.biasConstraint=ln(t.biasConstraint),this.kernelRegularizer=Me(t.kernelRegularizer),this.biasRegularizer=Me(t.biasRegularizer),this.activityRegularizer=Me(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=se(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=se(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return st(()=>{this.invokeCallHook(t,e);const s=Mt(t),o=Ak(this.activation.getClassName());let i;return o!=null?i=Ao(s,this.kernel.read(),o,this.bias?this.bias.read():null):(i=Ao(s,this.kernel.read()),this.bias!=null&&(i=po(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:Za(this.activation),useBias:this.useBias,kernelInitializer:Le(this.kernelInitializer),biasInitializer:Le(this.biasInitializer),kernelRegularizer:Te(this.kernelRegularizer),biasRegularizer:Te(this.biasRegularizer),activityRegularizer:Te(this.activityRegularizer),kernelConstraint:rn(this.kernelConstraint),biasConstraint:rn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}Yy.className="Dense";bt(Yy);class ZI extends jt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=se(t);for(const e of t.slice(1))if(e==null)throw new H(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Xa(t,1)]}call(t,e){return st(()=>{this.invokeCallHook(t,e);let s=Mt(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const o=[0];for(let i=2;i<s.rank;++i)o.push(i);o.push(1),s=Jt(s,o)}return JU(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}ZI.className="Flatten";bt(ZI);class QI extends jt{constructor(t){super(t),this.supportsMasking=!0,this.activation=Qa(t.activation)}call(t,e){return st(()=>{this.invokeCallHook(t,e);const s=Mt(t);return this.activation.apply(s)})}getConfig(){const t={activation:Za(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}QI.className="Activation";bt(QI);class JI extends jt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return st(()=>(t=Mt(t),ZU(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}JI.className="RepeatVector";bt(JI);class tN extends jt{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",o=e.slice();let i=1,l=null;for(let c=0;c<o.length;++c){const h=o[c];if(this.isUnknown(h))if(l===null)l=c;else throw new H("Can only specifiy one unknown dimension.");else i*=h}const u=Xa(t);if(l!==null){if(i===0||u%i!==0)throw new H(s);o[l]=u/i}else if(u!==i)throw new H(s);return o}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return st(()=>{this.invokeCallHook(t,e);const s=Mt(t),o=s.shape,i=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return J(s,i)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}tN.className="Reshape";bt(tN);class eN extends jt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=co(1,t.dims.length+1);if(!ce(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new an({ndim:this.dims.length+1})]}computeOutputShape(t){t=se(t);const e=t.slice();return this.dims.forEach((s,o)=>{e[o+1]=t[s]}),e}call(t,e){return Jt(Mt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}eN.className="Permute";bt(eN);class nN extends jt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=Mt(t);return d0(df(s,this.maskValue),-1)}call(t,e){return st(()=>{this.invokeCallHook(t,e);const s=Mt(t),l=d0(df(s,this.maskValue),-1,!0);return K(s,$t(l,s.dtype))})}}nN.className="Masking";bt(nN);class sN extends jt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(me(t.inputLength))}this.inputDim=t.inputDim,mn(this.inputDim,"inputDim"),this.outputDim=t.outputDim,mn(this.outputDim,"outputDim"),this.embeddingsInitializer=Fe(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Me(t.embeddingsRegularizer),this.activityRegularizer=Me(t.activityRegularizer),this.embeddingsConstraint=ln(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return st(()=>this.maskZero?(t=Mt(t),df(t,te(t))):null)}computeOutputShape(t){if(t=se(t),this.inputLength==null)return[...t,this.outputDim];const e=me(this.inputLength);if(e.length!==t.length-1)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let o=0;o<e.length;++o){const i=e[o],l=t[o+1];if(i!=null&&l!=null&&i!==l)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);i==null&&(e[s]=l),s++}}return[t[0],...e,this.outputDim]}call(t,e){return st(()=>{this.invokeCallHook(t,e);let s=Mt(t);s.dtype!=="int32"&&(s=Ro(s,"int32"));const o=zk(this.embeddings.read(),J(s,[s.size]));return J(o,se(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Le(this.embeddingsInitializer),embeddingsRegularizer:Te(this.embeddingsRegularizer),activityRegularizer:Te(this.activityRegularizer),embeddingsConstraint:rn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}sN.className="Embedding";bt(sN);class rr extends jt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Pt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let o=0;o<e.length;++o){const i=t[t.length-e.length+o],l=e[o];if(i==null||l==null||i<0||l<0)s.push(null);else if(i===1)s.push(l);else if(l===1)s.push(i);else{if(i!==l)throw new H("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(i)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[se(t)]),t=t,t.length<2)throw new H(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)i!=null&&i[0]!==null&&e.push(i[0]);if(e=ja(e),e.length>1)throw new H(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let i=1;i<t.length;++i){const l=t[i]==null?null:t[i].slice(1);s=this.computeElementwiseOpOutputShape(s,l)}const o=t.map(i=>i.length);t.indexOf(null)===-1&&ja(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return st(()=>{if(t=t,this.reshapeRequired){const s=[],o=t.map(i=>i.rank);if(o.indexOf(null)===-1){const i=Ya(o);for(let l of t){const u=l.rank;for(let c=0;c<i-u;++c)l=ah(l,1);s.push(l)}return this.mergeFunction(s)}else{let i=!1;for(const c of t){const h=c.rank;if(h==null){const f=c.shape,p=f[0],g=f.slice(1).concat([p]);let x=J(c,[p].concat(Xa(f.slice(1))));x=Jt(x,[1,0]),x=J(x,g),s.push(x),i=!0}else if(h>1){const f=co(1,h).concat([0]);s.push(Jt(c,f)),i=!0}else s.push(c)}let l=this.mergeFunction(s);const u=l.rank;if(i){if(u==null){const c=l.shape,h=c.length,f=c[h-1],p=[f].concat(c.slice(0,c.length-1));l=J(Jt(J(l,[-1,f]),[1,0]),p)}else if(u>1){const c=[u-1].concat(co(0,u-1));l=Jt(l,c)}}return l}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let o=1;o<t.length;++o){const i=t[o]==null?null:t[o].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let s=[];for(const o of t)o!=null&&o[0]!==null&&s.push(o[0]);return s=ja(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return st(()=>{if(e==null)return null;if(!Array.isArray(e))throw new H("`mask` should be an Array");if(!Array.isArray(t))throw new H("`inputs` should be an Array");if(e.length!==t.length)throw new H(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:qn(o,0));let s=e[0];for(let o=1;o<e.length-1;++o)s=la(s,e[o]);return s})}}class oN extends rr{constructor(t){super(t)}mergeFunction(t){return st(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=vt(e,t[s]);return e})}}oN.className="Add";bt(oN);class aN extends rr{constructor(t){super(t)}mergeFunction(t){return st(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=K(e,t[s]);return e})}}aN.className="Multiply";bt(aN);class iN extends rr{constructor(t){super(t)}mergeFunction(t){return st(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=vt(e,t[s]);return K(1/t.length,e)})}}iN.className="Average";bt(iN);class rN extends rr{constructor(t){super(t)}mergeFunction(t){return st(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=ii(e,t[s]);return e})}}rN.className="Maximum";bt(rN);class lN extends rr{constructor(t){super(t)}mergeFunction(t){return st(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Hu(e,t[s]);return e})}}lN.className="Minimum";bt(lN);class uN extends rr{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new H("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const o of t)if(o!=null){e=!1;break}if(e)return;const s=[];for(let o=0;o<t.length;++o){const i=t[o].slice();i.splice(this.axis,1);let l=!1;for(const u of s)if(ce(u,i)){l=!0;break}l||s.push(i)}if(s.length>1)throw new H("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return st(()=>Ay(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new H("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const i of e.slice(1)){if(s[o]==null||i[o]==null){s[o]=null;break}s[o]+=i[o]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new H("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new H("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new H(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return st(()=>{let s=!0;if(e.forEach(l=>{if(l!=null){s=!1;return}}),s)return null;const o=[];for(let l=0;l<t.length;++l)e[l]==null?o.push($t(qs(t[l]),"bool")):e[l].rank<t[l].rank?o.push(qn(e[l],-1)):o.push(e[l]);const i=Xn(o,this.axis);return pT(i,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}uN.className="Concatenate";bt(uN);function Du(n,t){for(;n<0;)n+=t;return n}function CP(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Pt("batchDot is not implemented for tensors of 4D or higher rank yet");if(_(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),_(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new Pt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,o=t.shape.length;e==null&&(e=[s-1,o-2]);const i=e;return st(()=>{let l;if(s>o){l=s-o;const c=[];for(let h=0;h<l;++h)c.push(1);t=J(t,t.shape.concat(c))}else if(o>s){l=o-s;const c=[];for(let h=0;h<l;++h)c.push(1);n=J(n,n.shape.concat(c))}else l=0;let u;if(n.shape.length===2&&t.shape.length===2)i[0]===i[1]?u=At(K(n,t),i[0]):u=At(K(Jt(n,[1,0]),t),i[1]);else{const c=i[0]!==n.shape.length-1,h=i[1]===t.shape.length-1;u=le(n,t,c,h)}if(l>0){let c;s>o?c=s+o-3:c=s-1;const h=[];for(let f=c;f<c+l;++f)h.push(f);u=Jc(u,h)}return u.shape.length===1&&(u=qn(u,1)),u})}class cN extends rr{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){_(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new Pt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(e,s);if(e[o[0]]!==s[o[1]])throw new H(`Dimension incompatibility: ${e[o[0]]} !== ${s[o[1]]}`)}mergeFunction(t){if(t.length!==2)throw new H(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],o;return Array.isArray(this.axes)?o=this.axes.map((i,l)=>Du(i,t[l].shape.length)):o=[Du(this.axes,e.shape.length),Du(this.axes,s.shape.length)],this.normalize&&(e=yf(e,o[0]),s=yf(s,o[1])),CP(e,s,o)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[Du(this.axes,t.length),Du(this.axes,e.length)],s}computeOutputShape(t){_(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new Pt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(e,s);e.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const i=e.concat(s);return i.length===1&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}cN.className="Dot";bt(cN);class hN extends jt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return st(()=>{this.invokeCallHook(t,e);const s=Mt(t);return rh(()=>vt(jp(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}}hN.className="GaussianNoise";bt(hN);class dN extends jt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return st(()=>{this.invokeCallHook(t,e);const s=Mt(t);return this.rate>0&&this.rate<1?rh(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return K(s,jp(s.shape,1,i))},()=>s,e.training||!1):s})}}dN.className="GaussianDropout";bt(dN);class fN extends jt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Mt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return st(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return rh(()=>{const i=Mt(t),u=-1.6732632423543772*1.0507009873554805;let c=sr(Qc(s),this.rate);c=Ro(c,"float32");const h=((1-this.rate)*(1+this.rate*u**2))**-.5,f=-h*u*this.rate,p=vt(K(i,c),K(vt(c,-1),u));return vt(K(p,h),f)},()=>Mt(t),e.training||!1)}return t})}}fN.className="AlphaDropout";bt(fN);function Ku(n,t,e,s,o,i=.001){let l;if(n.rank===2)l=W3(n,t,e,s,o,i);else if(n.rank===3)l=q3(n,t,e,s,o,i);else if(n.rank===4)l=X3(n,t,e,s,o,i);else throw new Pt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return l}function $P(n,t,e,s,o=.001){return st(()=>{const i=Gb(n,s),l=i.mean,u=i.variance;return[Ku(n,l,u,e,t,o),l,u]})}function TP(n,t,e,s,o=.001){return st(()=>{const i=Gb(n,s),l=i.mean,u=i.variance,c=[];for(const b of co(0,n.rank))s.indexOf(b)!==-1?c.push(1):c.push(n.shape[b]);const h=J(l,c),f=J(u,c),p=t==null?null:J(t,c),g=e==null?null:J(e,c);return[Ku(n,h,f,g,p,o),l,u]})}function kP(n,t,e,s,o=.001){return ce(s.slice().sort(),co(0,n.rank-1))?$P(n,t,e,s,o):TP(n,t,e,s,o)}class pN extends jt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Fe(t.betaInitializer||"zeros"),this.gammaInitializer=Fe(t.gammaInitializer||"ones"),this.movingMeanInitializer=Fe(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Fe(t.movingVarianceInitializer||"ones"),this.betaConstraint=ln(t.betaConstraint),this.gammaConstraint=ln(t.gammaConstraint),this.betaRegularizer=Me(t.betaRegularizer),this.gammaRegularizer=Me(t.gammaRegularizer)}build(t){t=se(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new H(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new an({ndim:t.length,axes:{[e]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return st(()=>{const s=e.training==null?!1:e.training,o=Mt(t),i=o.shape,l=i.length,u=co(0,l),c=this.axis>=0?this.axis:this.axis+l;u.splice(c,1);const h=Qi(1,l);h[c]=i[c];const f=u.slice();f.sort();const p=!ce(f,co(0,l).slice(0,l-1)),g=()=>{if(p){const $=J(this.movingMean.read(),h),k=J(this.movingVariance.read(),h),T=this.center?J(this.beta.read(),h):null,N=this.scale?J(this.gamma.read(),h):null;return Ku(o,$,k,T,N,this.epsilon)}else return Ku(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return g();const[x,b,v]=kP(o,this.gamma.read(),this.beta.read(),u,this.epsilon),S=($,k,T)=>{st(()=>{const N=1-T,R=$.read(),D=K(Ft(R,k),N);$.write(Ft(R,D))})};return S(this.movingMean,b,this.momentum),S(this.movingVariance,v,this.momentum),x})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Le(this.betaInitializer),gammaInitializer:Le(this.gammaInitializer),movingMeanInitializer:Le(this.movingMeanInitializer),movingVarianceInitializer:Le(this.movingVarianceInitializer),betaRegularizer:Te(this.betaRegularizer),gammaRegularizer:Te(this.gammaRegularizer),betaConstraint:rn(this.betaConstraint),gammaConstraint:rn(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}pN.className="BatchNormalization";bt(pN);class mN extends jt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Fe(t.betaInitializer||"zeros"),this.gammaInitializer=Fe(t.gammaInitializer||"ones"),this.betaRegularizer=Me(t.betaRegularizer),this.gammaRegularizer=Me(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=se(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=e);for(const i of this.axis)if(i<0||i>=e)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==ja(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>t[i]),o=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(t,e){const s=Mt(t),o=s.shape,i=o.length;return st(()=>{let{mean:u,variance:c}=Gb(s,this.axis,!0);const h=Qi(1,i);for(const v of this.axis)h[v]=o[v];const f=v=>v!=null&&v.shape.length!==i?J(v,h):v;let p=this.scale?f(this.gamma.read()):null,g=this.center?f(this.beta.read()):null;const x=[],b=[];for(let v=0;v<i;++v)this.axis.indexOf(v)!==-1?(x.push(o[v]),b.push(1)):(x.push(1),b.push(o[v]));return u=io(u,x),c=io(c,x),p!=null&&(p=io(p,b)),g!=null&&(g=io(g,b)),Ku(s,u,c,g,p,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Le(this.betaInitializer),gammaInitializer:Le(this.gammaInitializer),betaRegularizer:Te(this.betaRegularizer),gammaRegularizer:Te(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}mN.className="LayerNormalization";bt(mN);function IP(n,t,e){return st(()=>{if(n.rank!==4)throw new H(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new H("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=ho()),e!=="channelsLast"&&e!=="channelsFirst")throw new H(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],Wb(n,s)})}class gN extends jt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?ho():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new H(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new H(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new H(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new an({ndim:4})]}computeOutputShape(t){t=se(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return st(()=>IP(Mt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}gN.className="ZeroPadding2D";bt(gN);function em(n,t,e,s,o,i){return st(()=>{je(o),Ok(i),Is(s),e==null&&(e=[1,1]),s==null&&(s="valid"),o==null&&(o=ho()),i==null&&(i="max"),n=Wy(n,o);let l;const u=s==="same"?"same":"valid";return i==="max"?l=Pb(n,t,e,u):l=Db(n,t,e,u),o==="channelsFirst"&&(l=Jt(l,[0,3,1,2])),l})}function xN(n,t,e,s,o,i){return st(()=>{je(o),Ok(i),Is(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),o==null&&(o=ho()),i==null&&(i="max"),n=FI(n,o);let l;const u=s==="same"?"same":"valid";return i==="max"?l=DM(n,t,e,u):l=_3(n,t,e,u),o==="channelsFirst"&&(l=Jt(l,[0,4,1,2,3])),l})}class bN extends jt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new H(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(mn(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new H(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);mn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Is(this.padding),this.inputSpec=[new an({ndim:3})]}computeOutputShape(t){t=se(t);const e=uo(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return st(()=>{this.invokeCallHook(t,e),t=ah(Mt(t),2);const s=this.poolingFunction(Mt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Jc(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class yN extends bN{constructor(t){super(t)}poolingFunction(t,e,s,o,i){return je(i),Is(o),em(t,e,s,o,i,"max")}}yN.className="MaxPooling1D";bt(yN);class vN extends bN{constructor(t){super(t)}poolingFunction(t,e,s,o,i){return je(i),Is(o),em(t,e,s,o,i,"avg")}}vN.className="AveragePooling1D";bt(vN);class wN extends jt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new H(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];mn(this.poolSize,"poolSize"),mn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,je(this.dataFormat),Is(this.padding),this.inputSpec=[new an({ndim:4})]}computeOutputShape(t){t=se(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=uo(e,this.poolSize[0],this.padding,this.strides[0]),s=uo(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return st(()=>(this.invokeCallHook(t,e),this.poolingFunction(Mt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class SN extends wN{constructor(t){super(t)}poolingFunction(t,e,s,o,i){return je(i),Is(o),em(t,e,s,o,i,"max")}}SN.className="MaxPooling2D";bt(SN);class CN extends wN{constructor(t){super(t)}poolingFunction(t,e,s,o,i){return je(i),Is(o),em(t,e,s,o,i,"avg")}}CN.className="AveragePooling2D";bt(CN);class $N extends jt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new H(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];mn(this.poolSize,"poolSize"),mn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,je(this.dataFormat),Is(this.padding),this.inputSpec=[new an({ndim:5})]}computeOutputShape(t){t=se(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=uo(e,this.poolSize[0],this.padding,this.strides[0]),s=uo(s,this.poolSize[1],this.padding,this.strides[1]),o=uo(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,o]:[t[0],e,s,o,t[4]]}call(t,e){return st(()=>(this.invokeCallHook(t,e),this.poolingFunction(Mt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class TN extends $N{constructor(t){super(t)}poolingFunction(t,e,s,o,i){return je(i),Is(o),xN(t,e,s,o,i,"max")}}TN.className="MaxPooling3D";bt(TN);class kN extends $N{constructor(t){super(t)}poolingFunction(t,e,s,o,i){return je(i),Is(o),xN(t,e,s,o,i,"avg")}}kN.className="AveragePooling3D";bt(kN);class IN extends jt{constructor(t){super(t),this.inputSpec=[new an({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Pt}}class NN extends IN{constructor(t){super(t||{})}call(t,e){return st(()=>{const s=Mt(t);return Ze(s,1)})}}NN.className="GlobalAveragePooling1D";bt(NN);class EN extends IN{constructor(t){super(t||{})}call(t,e){return st(()=>{const s=Mt(t);return lo(s,1)})}}EN.className="GlobalMaxPooling1D";bt(EN);class RN extends jt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,je(this.dataFormat),this.inputSpec=[new an({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Pt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class AN extends RN{call(t,e){return st(()=>{const s=Mt(t);return this.dataFormat==="channelsLast"?Ze(s,[1,2]):Ze(s,[2,3])})}}AN.className="GlobalAveragePooling2D";bt(AN);class DN extends RN{call(t,e){return st(()=>{const s=Mt(t);return this.dataFormat==="channelsLast"?lo(s,[1,2]):lo(s,[2,3])})}}DN.className="GlobalMaxPooling2D";bt(DN);class ON extends jt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const o=e.layer,i=Do(o,s);delete e.layer;const l={layer:i};return Object.assign(l,e),new t(l)}}class _N extends ON{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=se(t),t.length<3)throw new H(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=se(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),o=t[1];return[s[0],o].concat(s.slice(1))}call(t,e){return st(()=>(t=Mt(t),WI((l,u)=>[Mt(this.layer.call(l,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}_N.className="TimeDistributed";bt(_N);function NP(n){ir(qU,"BidirectionalMergeMode",n)}const EP="concat";class FN extends ON{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=Do(s),e.goBackwards=e.goBackwards!==!0;const o={};if(o.className=t.layer.getClassName(),o.config=e,this.backwardLayer=Do(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?EP:t.mergeMode,NP(this.mergeMode),t.weights)throw new Pt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,o,i;return this.returnState&&(i=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,o=[s]):this.mergeMode==null?o=[s,s.slice()]:o=[s],this.returnState?this.mergeMode==null?o.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):jn(o)}apply(t,e){let s=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});const i=GI(t,s,o,this.numConstants);if(t=i.inputs,s=i.initialState,o=i.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&o==null)return super.apply(t,e);const l=[],u=[];if(s!=null){const h=s.length;if(h%2>0)throw new H("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,l.push(...s);const f=s.map(p=>new an({shape:p.shape}));this.forwardLayer.stateSpec=f.slice(0,h/2),this.backwardLayer.stateSpec=f.slice(h/2),u.push(...f)}if(o!=null)throw new Pt("Support for constants in Bidirectional layers is not implemented yet.");const c=l[0]instanceof Mo;for(const h of l)if(h instanceof Mo!==c)throw new H("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const h=[t].concat(l),f=this.inputSpec.concat(u),p=this.inputSpec;this.inputSpec=f;const g=super.apply(h,e);return this.inputSpec=p,g}else return super.apply(t,e)}call(t,e){return st(()=>{const s=e.initialState;let o,i;if(s==null)o=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{const c=s.slice(0,s.length/2),h=s.slice(s.length/2);o=this.forwardLayer.call(t,Object.assign(e,{initialState:c})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:h}))}let l;this.returnState&&(Array.isArray(o)&&(l=o.slice(1).concat(i.slice(1))),o=o[0],i=i[0]),this.returnSequences&&(i=Yi(i,1));let u;return this.mergeMode==="concat"?u=Ay([o,i]):this.mergeMode==="sum"?u=vt(o,i):this.mergeMode==="ave"?u=K(.5,vt(o,i)):this.mergeMode==="mul"?u=K(o,i):this.mergeMode==null&&(u=[o,i]),this.returnState?this.mergeMode==null?u.concat(l):[u].concat(l):u})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Ui(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Ui(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(l=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=Do(e.layer);if(delete e.layer,e.numConstants!=null)throw new Pt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=e;return o.layer=s,new t(o)}}FN.className="Bidirectional";bt(FN);class MN extends jt{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return st(()=>(t=Mt(t),t.dtype!=="float32"&&(t=Ro(t,"float32")),vt(K(t,this.scale),this.offset)))}}MN.className="Rescaling";bt(MN);const{resizeBilinear:RP,cropAndResize:AP}=ra;class zN extends jt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,s,o,i,l,u,c){return st(()=>{let h,f=!1;const p=e/l,g=s/u,x=(o+e)/l,b=(i+s)/u,v=[p,g,x,b],S=[];t.rank===3?(f=!0,h=ua([t])):h=t;for(let N=0;N<h.shape[0];N++)S.push(v);const C=Bu(S,[S.length,4]),$=qu(0,S.length,1,"int32"),T=AP(h,C,$,[o,i],"nearest");return Ro(f?Mt(Zi(T)):T,c)})}upsize(t,e,s,o){return st(()=>{const i=RP(t,[e,s]);return Ro(i,o)})}call(t,e){return st(()=>{const s=Mt(t),o=s.dtype,i=s.shape,l=i[i.length-3],u=i[i.length-2];let c=0;l!==this.height&&(c=Math.floor((l-this.height)/2));let h=0;return u!==this.width&&(h=Math.floor((u-this.width)/2),h===0&&(h=1)),c>=0&&h>=0?this.centerCrop(s,c,h,this.height,this.width,l,u,o):this.upsize(t,this.height,this.width,o)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=se(t);const e=t.length-3,s=t.length-2;return t[e]=this.height,t[s]=this.width,t}}zN.className="CenterCrop";bt(zN);function DP(n,t,e,s){let o=Mt(n);if(o.dtype!=="int32"&&(o=Ro(o,"int32")),t==="int")return o;const i=o.shape;if(o.rank===0&&(o=qn(o,-1)),t==="oneHot"&&o.shape[o.shape.length-1]!==1&&(o=qn(o,-1)),o.rank>2)throw new H(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${o.rank}.`);const l=["multiHot","oneHot"].includes(t),u=o;let c;if(typeof s<"u"&&t==="count"?c=BC(u,s,e,l):c=BC(u,[],e,l),t!=="tfIdf")return c;if(s)return K(c,s);throw new H("When outputMode is 'tfIdf', weights must be provided.")}class LN extends jt{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=se(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return st(()=>{t=Mt(t),t.dtype!=="int32"&&(t=Ro(t,"int32"));let s;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new H(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);s=Mt(e.countWeights)}const o=lo(t),i=cf(t),l=ks(this.numTokens,o).bufferSync().get(0),u=sr(i,0).bufferSync().get(0);if(!(l&&u))throw new H(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return DP(t,this.outputMode,this.numTokens,s)})}}LN.className="CategoryEncoding";bt(LN);const OP=["bilinear","nearest"],E2=new Set(OP);class BN extends jt{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(E2.has(t.interpolation))this.interpolation=t.interpolation;else throw new H(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=se(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return st(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return ra.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return ra.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...E2]} are supported`)})}}BN.className="Resizing";bt(BN);class UN{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}UN.className="RandomSeed";class VN extends jt{constructor(t){super(t),this.randomGenerator=new UN(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}VN.className="BaseRandomLayer";const _P=["bilinear","nearest"],R2=new Set(_P);class PN extends VN{constructor(t){super(t);const{factor:e,interpolation:s="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new H(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new H(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new H(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(R2.has(s))this.interpolation=s;else throw new H(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=se(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return st(()=>{const s=Mt(t);this.imgHeight=s.shape[s.shape.length-3];const o=s.shape[s.shape.length-2];this.widthFactor=Qc([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*o;i=Math.round(i);const l=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return ra.resizeBilinear(t,l);case"nearest":return ra.resizeNearestNeighbor(t,l);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...R2]} are supported`)}})}}PN.className="RandomWidth";bt(PN);function Px(n){return new Yy(n)}const FP=lt();FP.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var A2;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(A2||(A2={}));var D2;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(D2||(D2={}));var O2;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(O2||(O2={}));function It(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&_(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const MP=VT;class nm extends _0{nextDataId(){return nm.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new p$(this,wo())}write(t,e,s){this.firstUse&&(this.firstUse=!1,lt().get("IS_NODE")&&Ss(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const o={id:this.nextDataId()};return this.data.set(o,{values:t,dtype:s,refCount:1}),o}makeTensorInfo(t,e,s){let o;if(e==="string"&&s!=null&&s.length>0&&tc(s[0])){const i=s.map(l=>qa(l));o=this.write(i,t,e)}else o=this.write(s,t,e);return{dataId:o,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,s,o,i){this.data.set(t,{values:e,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){const o=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return ca(o,i)}return BO(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(o=>Ka(o));return Ht(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ht(t.shape,t.dtype,e)}makeOutput(t,e,s){return wo().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=Hn();return t(),{kernelMs:Hn()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){It([t],"where");const e=this.readSync(t.dataId);return MP(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}nm.nextDataId=0;function GN(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const zP=n=>{const{x:t}=n.inputs,e=n.backend;It(t,"abs");let s=new Float32Array(dt(t.shape));const o=e.data.get(t.dataId).values;return s=GN(o),e.makeOutput(s,t.shape,t.dtype)},LP={kernelName:_f,backendName:"cpu",kernelFunc:zP};function Xe(n){return(t,e,s,o,i)=>{const l=Ut(t,e),u=l.length,c=Rt(l),h=dt(l),f=En(i,h),p=t.length,g=e.length,x=Rt(t),b=Rt(e),v=cl(t,l),S=cl(e,l);if(v.length+S.length===0)for(let C=0;C<f.length;++C)f[C]=n(s[C%s.length],o[C%o.length]);else for(let C=0;C<f.length;++C){const $=vl(C,u,c),k=$.slice(-p);v.forEach(D=>k[D]=0);const T=Io(k,p,x),N=$.slice(-g);S.forEach(D=>N[D]=0);const R=Io(N,g,b);f[C]=n(s[T],o[R])}return[f,l]}}function rs(n){const{inputs:t,backend:e}=n,{real:s,imag:o}=t,i=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,u=e.makeTensorInfo(s.shape,"complex64"),c=e.data.get(u.dataId);return c.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",i),imag:e.makeTensorInfo(o.shape,"float32",l)},u}const BP={kernelName:X0,backendName:"cpu",kernelFunc:rs};function Tf(n,t,e="float32"){if(e==="complex64"){const o=Tf(n,t,"float32"),i=Tf(n,t,"float32");return rs({inputs:{real:o,imag:i},backend:n})}const s=Rn(dt(t),e);return n.makeTensorInfo(t,e,s)}function zo(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const UP={kernelName:wc,backendName:"cpu",kernelFunc:zo};function Ji(n){const{inputs:t,backend:e}=n,{input:s}=t,o=e.data.get(s.dataId).complexTensorInfos.real,i=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,i)}const VP={kernelName:bb,backendName:"cpu",kernelFunc:Ji};function WN(n,t,e,s){if(s==="int32"){const o=Int32Array.from(n);return[t,"int32",o]}if(s==="bool"){const o=nr([0],e),[i,l]=Xe((u,c)=>u!==c?1:0)(t,[],n,o,"bool");return[l,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function ti(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{dtype:i}=s;if(i==="complex64"){if(o.dtype==="complex64")return zo({inputs:{x:o},backend:e});const f=Tf(e,o.shape,o.dtype),p=ti({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),g=rs({inputs:{real:p,imag:f},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),g}if(o.dtype==="complex64"){const f=Ji({inputs:{input:o},backend:e}),p=ti({inputs:{x:f},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(f),p}if(!x$(o.dtype,i)){const f=zo({inputs:{x:o},backend:e});return{dataId:f.dataId,shape:f.shape,dtype:i}}const l=e.data.get(o.dataId).values,[u,c,h]=WN(l,o.shape,o.dtype,i);return e.makeTensorInfo(u,c,h)}const PP={kernelName:lc,backendName:"cpu",kernelFunc:ti};function cn(n,t,e,s){return e==null?({inputs:o,backend:i})=>{const{a:l,b:u}=o,c=i;It([l,u],n);const h=c.data.get(l.dataId).values,f=c.data.get(u.dataId).values,p=l.dtype==="string"?ha(h):h,g=l.dtype==="string"?ha(f):f,x=s||l.dtype,[b,v]=t(l.shape,u.shape,p,g,x);return c.makeTensorInfo(v,x,b)}:({inputs:o,backend:i})=>{const{a:l,b:u}=o,c=i;if(l.dtype==="complex64"||u.dtype==="complex64"){const h=ti({inputs:{x:l},backend:c,attrs:{dtype:"complex64"}}),f=c.data.get(h.dataId),p=f.complexTensorInfos.real,g=f.complexTensorInfos.imag,x=c.data.get(p.dataId).values,b=c.data.get(g.dataId).values,v=ti({inputs:{x:u},backend:c,attrs:{dtype:"complex64"}}),S=c.data.get(v.dataId),C=S.complexTensorInfos.real,$=S.complexTensorInfos.imag,k=c.data.get(C.dataId).values,T=c.data.get($.dataId).values,[N,R,D]=e(l.shape,u.shape,x,b,k,T),z=c.makeTensorInfo(D,"float32",N),O=c.makeTensorInfo(D,"float32",R),F=rs({inputs:{real:z,imag:O},backend:c});return c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(z),c.disposeIntermediateTensorInfo(O),F}else{const h=c.data.get(l.dataId).values,f=c.data.get(u.dataId).values,p=s||l.dtype,[g,x]=t(l.shape,u.shape,h,f,p);return c.makeTensorInfo(x,p,g)}}}function Zy(n){return(t,e,s,o,i,l)=>{const u=Ut(t,e),c=dt(u),h=u.length,f=Rt(u),p=En("float32",c),g=En("float32",c),x=cl(t,u),b=cl(e,u),v=ca(s,o),S=ca(i,l),C=t.length,$=Rt(t),k=e.length,T=Rt(e);if(x.length+b.length===0)for(let N=0;N<p.length;N++){const R=N%v.length,D=N%S.length,z=n(v[R*2],v[R*2+1],S[D*2],S[D*2+1]);p[N]=z.real,g[N]=z.imag}else for(let N=0;N<p.length;N++){const R=vl(N,h,f),D=R.slice(-C);x.forEach(U=>D[U]=0);const z=Io(D,C,$),O=R.slice(-k);b.forEach(U=>O[U]=0);const F=Io(O,k,T),E=n(v[z*2],v[z*2+1],S[F*2],S[F*2+1]);p[N]=E.real,g[N]=E.imag}return[p,g,u]}}const HN=Xe(((n,t)=>n+t)),GP=Zy(((n,t,e,s)=>({real:n+e,imag:t+s}))),pl=cn(wl,HN,GP),WP={kernelName:wl,backendName:"cpu",kernelFunc:pl};function Qy(n,t,e,s,o){const i=dt(s),l=Rn(o,e);for(let u=0;u<n.length;u++){const c=n[u];if(c<0)throw new Error("Input x must be non-negative!");c>=o||(i>0?l[c]+=t[u]:l[c]+=1)}return l}function qN(n,t,e,s=!1){const o=n.shape[0],i=n.shape[1],l=Ht([o,e],t.dtype);for(let u=0;u<o;u++)for(let c=0;c<i;c++){const h=n.get(u,c);if(h<0)throw new Error("Input x must be non-negative!");h>=e||(s?l.set(1,u,h):t.size>0?l.set(l.get(u,h)+t.get(u,c),u,h):l.set(l.get(u,h)+1,u,h))}return l}const jN=Xe(((n,t)=>n&t)),HP=cn(j0,jN),qP={kernelName:j0,backendName:"cpu",kernelFunc:HP};function Lo(n){return(t,e,s)=>{const o=Ge(e,t.length);for(let i=0;i<t.length;++i)o[i]=n(t[i],s);return o}}function ge(n,t,e){const s=Lo(t);return ci(n,s,e)}function ci(n,t,e){return({inputs:s,attrs:o,backend:i})=>{const{x:l}=s;It(l,n);const u=i,c=u.data.get(l.dataId).values;let h;if(l.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");h=ha(c)}else h=c;const f=e||l.dtype,p=t(h,f,o);return u.makeTensorInfo(l.shape,f,p)}}const XN=Lo(n=>Math.ceil(n)),jP=ci(uc,XN),XP={kernelName:uc,backendName:"cpu",kernelFunc:jP};function KN(n,t,e,s){const o=Ge(e,dt(t));if(s&&e!=="string"){let i=0;n.forEach(l=>{const u=dt(l.shape);o.set(l.vals,i),i+=u})}else{let i=0;n.forEach(l=>{const u=e==="string"?ha(l.vals):l.vals;let c=0;for(let h=0;h<l.shape[0];++h){const f=h*t[1]+i;for(let p=0;p<l.shape[1];++p)o[f+p]=u[c++]}i+=l.shape[1]})}return o}const YN=Xe((n,t)=>n===t?1:0),ZN=cn(Kf,YN,null,"bool"),KP={kernelName:Kf,backendName:"cpu",kernelFunc:ZN};const QN=Lo(n=>Math.exp(n)),JN=ci(gc,QN,"float32"),YP={kernelName:gc,backendName:"cpu",kernelFunc:JN};const tE=Lo(n=>Math.expm1(n)),ZP=ci(xc,tE),QP={kernelName:xc,backendName:"cpu",kernelFunc:ZP};const eE=Lo(n=>Math.floor(n)),JP=ci(bc,eE),tG={kernelName:bc,backendName:"cpu",kernelFunc:JP};const nE=Xe((n,t)=>Math.floor(n/t)),eG=cn(yc,nE,null,"int32"),nG={kernelName:yc,backendName:"cpu",kernelFunc:eG};function sE(n,t,e,s,o,i,l,u,c){const h=Ht([s,i],e);for(let f=0;f<s;f++){const p=[];let g=0;for(let x=0;x<o;x++){const b=n[f*o+x];g+=b*l[x],p.push(b)}if(g<0||g>=c/i)throw new Error(`Invalid indices: ${p} does not index into ${u}`);for(let x=0;x<i;x++)h.values[f*i+x]=t.get(...t.indexToLoc(g*i+x))}return h}function oE(n,t,e){const s=Ht(e,n.dtype);for(let o=0;o<s.size;++o){const l=s.indexToLoc(o).slice(),u=l[0],c=l[2],h=t.locToIndex([u,c]);l[2]=t.values[h];const f=n.locToIndex(l);0<=f&&f<n.values.length&&(s.values[o]=n.values[f])}return s}const aE=Xe((n,t)=>n>t?1:0),sG=cn(Jf,aE,null,"bool"),oG={kernelName:Jf,backendName:"cpu",kernelFunc:sG};const iE=Xe((n,t)=>n>=t?1:0),aG=cn(vc,iE,null,"bool"),iG={kernelName:vc,backendName:"cpu",kernelFunc:aG};const rE=Xe((n,t)=>n<t?1:0),rG=cn(ep,rE,null,"bool"),lG={kernelName:ep,backendName:"cpu",kernelFunc:rG};const lE=Xe((n,t)=>n<=t?1:0),uG=cn(np,lE,null,"bool"),cG={kernelName:np,backendName:"cpu",kernelFunc:uG};function uE(n,t,e){const s=(t-n)/(e-1),o=Rn(e,"float32");o[0]=n;for(let i=1;i<o.length;i++)o[i]=o[i-1]+s;return o}const cE=Lo(n=>Math.log(n)),hG=ci(Tc,cE),dG={kernelName:Tc,backendName:"cpu",kernelFunc:hG};function hE(n,t,e,s){const o=En(s,dt(e));for(let i=0;i<o.length;++i){const l=i*t;let u=n[l];for(let c=0;c<t;++c){const h=n[l+c];(Number.isNaN(h)||h>u)&&(u=h)}o[i]=u}return o}const dE=Xe(((n,t)=>Math.max(n,t))),fG=cn(Ic,dE),pG={kernelName:Ic,backendName:"cpu",kernelFunc:fG};const fE=Xe(((n,t)=>Math.min(n,t))),mG=cn(Nc,fE),gG={kernelName:Nc,backendName:"cpu",kernelFunc:mG};const Jy=Xe(((n,t)=>n*t)),xG=Zy(((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e}))),sm=cn(Rc,Jy,xG),bG={kernelName:Rc,backendName:"cpu",kernelFunc:sm};function pE(n,t,e){const s=ni(-1,e);return Jy([],t,s,n,e)}function yG(n){const{inputs:t,backend:e}=n,{x:s}=t;It(s,"neg");const o=e.data.get(s.dataId).values,[i,l]=pE(o,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,i)}const vG={kernelName:fp,backendName:"cpu",kernelFunc:yG};const mE=Xe(((n,t)=>n!==t?1:0)),wG=cn(pp,mE,null,"bool"),SG={kernelName:pp,backendName:"cpu",kernelFunc:wG};function t1(n,t,e,s,o){const i=t.length,l=dt(t),u=Rt(t),c=Rt(o),h=En(e,dt(o));for(let f=0;f<l;++f){const p=vl(f,i,u),g=new Array(p.length);for(let b=0;b<g.length;b++)g[b]=p[s[b]];const x=Io(g,i,c);h[x]=n[f]}return h}function Yn(n){const{inputs:t,attrs:e,backend:s}=n,{x:o}=t,{perm:i}=e;It(o,"transpose");const l=o.shape.length,u=new Array(l);for(let p=0;p<u.length;p++)u[p]=o.shape[i[p]];const c=s.data.get(o.dataId).values,h=t1(c,o.shape,o.dtype,i,u);return{dataId:s.write(h,u,o.dtype),shape:u,dtype:o.dtype}}const CG={kernelName:sl,backendName:"cpu",kernelFunc:Yn};function gE(n,t,e,s){const[o,i]=gn(n,s),l=us(t,"int32"),u=Rn(dt(o),l),c=dt(i);for(let h=0;h<u.length;++h){const f=h*c;let p=1;for(let g=0;g<c;++g)p*=e[f+g];u[h]=p}return{outVals:u,outShape:o,outDtype:l}}function $G(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s;It(o,"prod");const u=o.shape.length,c=qt(i,o.shape),h=Be(c,u);let f=c,p=o;const g=[];h!=null&&(p=Yn({inputs:{x:o},backend:e,attrs:{perm:h}}),g.push(p),f=qe(f.length,u));const x=e.data.get(p.dataId).values,{outVals:b,outShape:v,outDtype:S}=gE(p.shape,p.dtype,x,f);let C=v;return l&&(C=Qe(v,c)),g.forEach($=>e.disposeIntermediateTensorInfo($)),e.makeTensorInfo(C,S,b)}const TG={kernelName:vp,backendName:"cpu",kernelFunc:$G};function kG(n,t,e){n.forEach((s,o)=>{if(s<0||s>=e){const i=vl(o,t.length,Rt(t)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${e})`)}})}function IG(n,t){for(let e=0;e<n.length;++e){const s=n[e],o=e===n.length-1?t:n[e+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>o)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function NG(n,t,e,s){const o=[];let i=0;const l=t.length-1+e.length,u=new Array(l).fill(null).map(()=>[0]);IG(e,s);let c=1;for(let h=0;h<t.length-1;++h){c*=t[h];const f=t[h+1];for(let p=1;p<c+1;++p)u[h].push(p*f)}for(let h=0;h<n.length;++h){let f=n[h],p=n[h]+1;for(let g=0;g<e.length;++g){const x=e[g],b=g+t.length-1;if(b>=0){const v=u[b],S=v[v.length-1]-x[f];for(let C=f;C<p;++C)u[b].push(x[C+1]+S)}f=x[f],p=x[p]}p!==f&&(o.push([f,p]),i+=p-f)}return{outSplits:u,valueSlices:o,numValues:i}}function EG(n){const t=[];for(let e=0;e<n.length;++e){const s=n[e].length,o=Ge("int32",s);t.push(o),n[e].forEach((i,l)=>o[l]=i)}return t}function _2(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function RG(n,t,e,s,o,i){const l=_2(t,2)[1],u=_2(i,2)[1];let c=0;for(const h of e)for(let f=h[0];f<h[1];++f){for(let p=0;p<s;++p)o[c*u+p]=n[f*l+p];++c}}function AG(n,t,e,s,o){const i=t.slice();i[0]=o;const l=Ge(e,dt(i)),u=n.length,c=u===0?0:u/t[0];return RG(n,t,s,c,l,i),[l,i]}function xE(n,t,e,s,o,i,l,u){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const c=t[0][0]-1;if(kG(i,l,c),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:f,valueSlices:p,numValues:g}=NG(i,l,n,h),x=EG(f),b=AG(e,s,o,p,g);return[x,b[0],b[1]]}const F2=2147483647;function bE(n,t,e,s,o,i,l){if(t.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(l.length>1)throw new Error("deltas must be a scalar or vector");const u=t.length===0,c=o.length===0,h=l.length===0,f=[];u||f.push(t[0]),c||f.push(o[0]),h||f.push(l[0]);for(let S=1;S<f.length;++S)if(f[S]!==f[S-1])throw new Error("starts, limits, and deltas must have the same shape");const p=f.length===0?1:f[0],g=Ge("int32",p+1);g[0]=0;for(let S=0;S<p;++S){const C=u?n[0]:n[S],$=c?s[0]:s[S],k=h?i[0]:i[S];if(k===0)throw new Error("Requires delta != 0");let T;if(k>0&&$<C||k<0&&$>C)T=0;else if(T=Math.ceil(Math.abs(($-C)/k)),T>F2)throw new Error(`Requires ((limit - start) / delta) <= ${F2}`);g[S+1]=g[S]+T}const x=g[p],b=Ge(e,x);let v=0;for(let S=0;S<p;++S){const C=g[S+1]-g[S];let $=u?n[0]:n[S];const k=h?i[0]:i[S];for(let T=0;T<C;++T)b[v++]=$,$+=k}return[g,b]}var Us=ao;class kf{constructor(t,e,s,o,i,l,u,c,h,f){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=o,this.valuesDType=i,this.defaultValue=l,this.defaultValueShape=u,this.rowPartitionValues=c,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=ak(f),this.raggedRank=ik(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Us.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Us.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Us.VALUE_ROWIDS:return kf.getMaxWidthValueRowID(e);case Us.ROW_SPLITS:return kf.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Us[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let s=0;for(let o=0;o<e-1;++o){const i=t[o+1]-t[o];i>s&&(s=i)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let s=0,o=t[0],i=0;for(let l=1;l<e;++l){const u=t[l];u!==o&&(o=u,i=Math.max(l-s,i),s=l)}return Math.max(e-s,i)}tensorShapeFromTensor(t,e,s=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return z2(t,s)}calculateOutputSize(t){const e=this.valuesShape,s=this.defaultValueShape;rk(s,e);const o=this.tensorShapeFromTensor(this.shape,this.shapeShape),l=ok(this.raggedRank,o,e);l[0]<0&&(l[0]=t);for(let u=1;u<=this.raggedRank;++u)l[u]<0&&(l[u]=this.getMaxWidth(u));return l}calculateFirstParentOutputIndex(t,e,s){const o=Math.min(t,s),i=[];let l=0;for(let u=0;u<o;++u,l+=e)i.push(l);for(let u=o;u<t;++u)i.push(-1);return _(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,s,o){const i=t.length,l=[];for(let u=0;u<i-1;++u){const c=t[u+1]-t[u];let h=Math.min(o,c),f=e[u];f===-1&&(h=0);for(let p=0;p<h;++p)l.push(f),f+=s;for(let p=0;p<c-h;++p)l.push(-1)}if(i>0&&l.length!==t[i-1])throw new Error("Invalid row split size.");return l}calculateOutputIndexValueRowID(t,e,s,o){const i=t.length,l=[];if(i===0)return[];let u=0,c=t[0];if(c>=e.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${e.length}`);let h=e[c];l.push(h);for(let f=1;f<i;++f){const p=t[f];if(p===c)h>=0&&(++u,u<o?h+=s:h=-1);else{if(u=0,c=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);h=e[p]}l.push(h)}if(l.length!==t.length)throw new Error("Invalid row ids.");return l}calculateOutputIndex(t,e,s,o){const i=this.getRowPartitionTensor(t),l=this.getRowPartitionTypeByDimension(t);switch(l){case Us.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,s,o);case Us.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,s,o);default:throw new Error(`Unsupported partition type: ${Us[l]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Us.FIRST_DIM_SIZE:return t[0];case Us.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Us.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Us[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let c=o.length-2;c>=0;--c)o[c]=o[c+1]*s[c+1];const i=z2(s,!1),l=Ge(this.valuesDType,dt(i));if(o[0]*s[0]>0){let c=this.calculateFirstParentOutputIndex(e,o[0],s[0]);for(let h=1;h<=this.raggedRank;++h)c=this.calculateOutputIndex(h-1,c,o[h],s[h]);this.setOutput(this.raggedRank,c,l,i)}return[i,l]}setOutput(t,e,s,o){if(s.length===0)return;const i=this.values,l=s;let u=o.slice();u=u.slice(t+1);const c=dt(u),h=e.length;let f=this.defaultValue;if(f.length!==c&&f.length!==1){const b=this.defaultValueShape;st(()=>{const v=J(f,b);f=Uu(v,u).dataSync()})}let p=0,g=0,x=0;for(let b=0;b<=h;++b){let v=b<h?e[b]:-1;if(v===x){++x;continue}if(g<x){const S=i.subarray(p*c),C=l.subarray(g*c),$=(x-g)*c;M2(C,S,$)}if(b>=h){const S=s.length;v=Math.floor(S/c)}if(v>x)if(this.defaultValue.length===1)l.subarray(x*c,v*c).fill(this.defaultValue[0]),x=v;else for(;v>x;){const S=l.slice(x*c);M2(S,f,c),++x}v<0?(p=b+1,g=x):(p=b,g=x,x=g+1)}}}function M2(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function z2(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function yE(n,t,e,s,o,i,l,u,c,h){return new kf(n,t,e,s,o,i,l,u,c,h).compute()}function vE(n,t,e,s){const o=n===t,i=n<t&&e<0,l=t<n&&e>1;if(o||i||l)return Rn(0,s);const u=Math.abs(Math.ceil((t-n)/e)),c=Rn(u,s);t<n&&e===1&&(e=-1),c[0]=n;for(let h=1;h<c.length;h++)c[h]=c[h-1]+e;return c}const wE=Lo(n=>1/Math.sqrt(n)),DG=ci(Mc,wE),OG={kernelName:Mc,backendName:"cpu",kernelFunc:DG};function Li(n,t,e,s,o,i,l,u,c,h){const f=[s/o,o],p=n.values,g=t.values;if(s===0)return Ht(e,t.dtype);const x=c instanceof vn?c:Ht(f,t.dtype);typeof c=="string"||typeof c=="number"?x.values.fill(c):typeof c=="boolean"&&x.values.fill(+c);for(let b=0;b<i;b++){const v=[];let S=0;for(let C=0;C<l;C++){const $=p[b*l+C];v.push($),S+=$*u[C]}if(S<0||S>=s/o)throw new Error(`Invalid indices: ${v} does not index into ${e}`);for(let C=0;C<o;C++)h?x.values[S*o+C]+=g[b*o+C]:x.values[S*o+C]=t.rank===0?g[0]:g[b*o+C]}return x}const _G=Lo(n=>1/(1+Math.exp(-n))),SE=ge(Vc,n=>1/(1+Math.exp(-n))),FG={kernelName:Vc,backendName:"cpu",kernelFunc:SE};function CE(n,t,e,s,o){const i=tk(s,t,e),l=dt(e),u=Rt(s);if(i){const p=ek(t,u);return o==="string"?n.slice(p,p+l):n.subarray(p,p+l)}const c=o==="string"?ha(n):n,h=Ht(s,o,c),f=Ht(e,o);for(let p=0;p<f.size;++p){const g=f.indexToLoc(p),x=g.map((b,v)=>b+t[v]);f.set(h.get(...x),...g)}return o==="string"?kk(f.values):f.values}function tr(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{begin:i,size:l}=s;It(o,"slice");const[u,c]=uy(o,i,l);QT(o,u,c);const h=e.data.get(o.dataId).values,f=CE(h,u,c,o.shape,o.dtype);return e.makeTensorInfo(c,o.dtype,f)}const MG={kernelName:kp,backendName:"cpu",kernelFunc:tr};function $E(n,t,e,s,o,i,l){const u=t[0],c=i[0],h=new Array(c),f=new Array(u),p=t[1];if(c===0){if(u!==0)throw new Error(pk(u));const S=Ge(e,0),C=Ge(o,0);return[S,[0,p],C,h,f]}let g=!0,x=0;const b=new Array(c).fill(0);for(let S=0;S<u;++S){const C=n[S*p];if(C<0)throw new Error(mk(S,C));if(C>=c)throw new Error(gk(S,C,c));++b[C],g=g&&C>=x,x=C}let v=!0;for(let S=0;S<c;++S){const C=b[S]===0;h[S]=C,v=v&&!C,b[S]=Math.max(b[S],1),S>0&&(b[S]+=b[S-1])}if(v&&g){const S=n,C=s;for(let $=0;$<u;++$)f[$]=$;return[S,[u,p],C,h,f]}else{const S=b[c-1],C=Ge(e,S*p),$=Ge(o,S),k=new Array(c).fill(0);for(let T=0;T<u;++T){const N=n[T*p],R=k[N],D=(N===0?0:b[N-1])+R;k[N]++;for(let z=0;z<p;++z)C[D*p+z]=n[T*p+z];$[D]=s[T],f[T]=D}for(let T=0;T<c;++T)if(k[T]===0){const R=T===0?0:b[T-1];C[R*p+0]=T;for(let D=1;D<p;++D)C[R*p+D]=0;$[R]=l}return[C,[S,p],$,h,f]}}function TE(n,t,e,s,o){const i=dt(s),l=t[0],u=o.length,c=[];let h=1,f=-1;for(let S=0;S<u;++S){const C=o[S];if(C===-1){if(f!==-1)throw new Error(xk(f,S));f=S,c.push(1)}else{if(C<0)throw new Error(bk(S,C));h*=C,c.push(C)}}if(f!==-1){if(h<=0)throw new Error(yk());const S=Math.trunc(i/h);if(h*S!==i)throw new Error(vk(s,c));c[f]=S}if(dt(c)!==i)throw new Error(wk(s,c));const g=s.length,x=[];if(g>0){x[g-1]=1;for(let S=g-2;S>=0;--S)x[S]=x[S+1]*s[S+1]}const b=[];if(u>0){b[u-1]=1;for(let S=u-2;S>=0;--S)b[S]=b[S+1]*c[S+1]}const v=Ge(e,l*u);for(let S=0;S<l;++S){let C=0;for(let $=0;$<g;++$)C+=n[S*g+$]*x[$];for(let $=0;$<u;++$)v[S*u+$]=Math.trunc(C/b[$]),C%=b[$]}return[v,[l,u],c]}function e1(n,t,e,s,o,i=!1,l=0){const u=s.length,c=[t[0],n.length/t[0]],h=c[1],p=u>0?o[u-1]+1:0;if(p<0)throw new Error(x0());const g=t.slice();g[0]=p;const x=g.reduce((k,T)=>k*T,1),b=Ge(e,x);if(u===0)return p>0&&b.fill(l),[b,g];if(p<=0)throw new Error(x0());let v=0,S=1,C=0,$=o[v];for(;;){let k=0;if(S<u){if(k=o[S],$===k){++S;continue}if($>=k)throw new Error(Sk())}if($<0||$>=p)throw new Error(Ck($,p));$>C&&b.fill(l,C*h,$*h);for(let T=v;T<S;++T){const N=s[T];if(N<0||N>=c[0])throw new Error($k(T,s[T],c[0]));for(let R=0;R<h;R++)b[$*h+R]+=n[N*h+R]}if(i)for(let T=0;T<h;T++)b[$*h+T]/=S-v;if(v=S,++S,C=$+1,$=k,S>u)break}return C<p&&b.fill(l,C*h,p*h),[b,g]}const zG=Lo(n=>Math.sqrt(n)),LG=ge(Gc,n=>Math.sqrt(n)),BG={kernelName:Gc,backendName:"cpu",kernelFunc:LG};const kE=Xe(((n,t)=>{const e=n-t;return e*e})),UG=cn(Wc,kE),VG={kernelName:Wc,backendName:"cpu",kernelFunc:UG};const IE=Lo((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:o}=t;return n.replace(new RegExp(e,s?"g":""),o)}),PG=ci(Sb,IE),GG={kernelName:Sb,backendName:"cpu",kernelFunc:PG};function NE(n,t,e,s){const o=Ht(n,t.dtype);for(let i=0;i<o.size;i++){const l=o.indexToLoc(i),u=new Array(l.length);for(let c=0;c<u.length;c++)u[c]=l[c]*e[c]+s[c];o.set(t.get(...u),...l)}return o}class WG{constructor(t,e,s,o,i,l){this.separator=qa(t),this.nGramWidths=e,this.leftPad=qa(s),this.rightPad=qa(o),this.padWidth=i,this.preserveShort=l}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,o,i,l){for(let u=0;u<i;++u){const c=this.getPadWidth(l),h=Math.max(0,c-u),f=Math.max(0,c-(i-(u+1))),p=l-(h+f),g=e+(h>0?0:u-c);let x=0;x+=h*this.leftPad.length;for(let $=0;$<p;++$)x+=t[g+$].length;x+=f*this.rightPad.length;const b=h+f+p-1;x+=b*this.separator.length,s[o+u]=new Uint8Array(x);const v=s[o+u];let S=0;const C=$=>$.forEach(k=>v[S++]=k);for(let $=0;$<h;++$)C(this.leftPad),C(this.separator);for(let $=0;$<p-1;++$)C(t[g+$]),C(this.separator);if(p>0){C(t[g+p-1]);for(let $=0;$<f;++$)C(this.separator),C(this.rightPad)}else{for(let $=0;$<f-1;++$)C(this.rightPad),C(this.separator);C(this.rightPad)}}}compute(t,e){const s=t.length,o=e.length;if(o>0){let c=e[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let h=1;h<o;++h){let f=e[h]>=c;if(f=f&&e[h]<=s,!f)throw new Error(`Invalid split value ${e[h]}, must be in [${c}, ${s}]`);c=e[h]}if(c!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`)}const i=o-1,l=Ge("int32",o);if(s===0||o===0){const c=new Array(s);for(let h=0;h<=i;++h)l[h]=0;return[c,l]}l[0]=0;for(let c=1;c<=i;++c){const h=e[c]-e[c-1];let f=0;this.nGramWidths.forEach(p=>{f+=this.getNumNGrams(h,p)}),this.preserveShort&&h>0&&f===0&&(f=1),l[c]=l[c-1]+f}const u=new Array(l[i]);for(let c=0;c<i;++c){const h=e[c];let f=l[c];if(this.nGramWidths.forEach(p=>{const g=e[c+1]-e[c],x=this.getNumNGrams(g,p);this.createNGrams(t,h,u,f,x,p),f+=x}),this.preserveShort&&f===l[c]){const p=e[c+1]-e[c];if(p===0)continue;const g=p+2*this.padWidth;this.createNGrams(t,h,u,f,1,g)}}return[u,l]}}function EE(n,t,e,s,o,i,l,u){return new WG(e,s,o,i,l,u).compute(n,t)}function HG(n,t,e,s){if(!n.length)return;if(t.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(t.length===1){const i=t[0];let l=n.indexOf(i);for(;l!==-1;){const u=n.subarray(0,l);(!e||u.length!==0)&&s.push(u),n=n.subarray(l+1),l=n.indexOf(i)}(!e||n.length!==0)&&s.push(n);return}let o=0;for(let i=0;i<n.length+1;i++)if(i===n.length||t.indexOf(n[i])!==-1){const l=n.subarray(o,i);(!e||l.length!==0)&&s.push(l),o=i+1}}function RE(n,t,e){const s=n.length,o=[];let i=0,l=0;const u=new Array(s);for(let g=0;g<s;++g){const x=o.length;HG(n[g],t,e,o);const b=o.length-x;u[g]=b,i+=b,l=Math.max(l,b)}const c=Ge("int32",i*2),h=new Array(i),f=[s,l];let p=0;for(let g=0;g<s;++g)for(let x=0;x<u[g];++x)c[p*2]=g,c[p*2+1]=x,h[p]=o[p],++p;return[c,h,f]}function AE(n,t){const e=Ge("int32",n.length);for(let s=0;s<n.length;++s)e[s]=s_(n[s]).modulo(t).getLowBitsUnsigned();return e}const DE=Xe(((n,t)=>n-t)),qG=Zy(((n,t,e,s)=>({real:n-e,imag:t-s}))),n1=cn(Hc,DE,qG),jG={kernelName:Hc,backendName:"cpu",kernelFunc:n1};function OE(n,t){const e=new Array(n.rank);for(let o=0;o<e.length;o++)e[o]=n.shape[o]*t[o];const s=Ht(e,n.dtype);for(let o=0;o<s.values.length;++o){const i=s.indexToLoc(o),l=new Array(n.rank);for(let c=0;c<l.length;c++)l[c]=i[c]%n.shape[c];const u=n.locToIndex(l);s.values[o]=n.values[u]}return s}const Mu=(n,t)=>{const e=t.value-n.value;return e===0?n.index-t.index:e};function _E(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const u=s-e+1,c=t-e+1,h=Math.log(u),f=.5*Math.exp(2*h/3),p=.5*Math.sqrt(h*f*(u-f)/u)*Math.sign(c-u/2),g=Math.max(e,Math.floor(t-c*f/u+p)),x=Math.min(s,Math.floor(t+(u-c)*f/u+p));_E(n,t,g,x)}const o=n[t];let i=e,l=s;for(Jr(n,e,t),Mu(n[s],o)>0&&Jr(n,e,s);i<l;){for(Jr(n,i,l),i++,l--;Mu(n[i],o)<0;)i=i+1;for(;Mu(n[l],o)>0;)l=l-1}Mu(n[e],o)===0?Jr(n,e,l):(l=l+1,Jr(n,l,s)),l<=t&&(e=l+1),t<=l&&(s=l-1)}}function FE(n,t,e,s,o){const i=t[t.length-1],[l,u]=[n.length/i,i],c=En(e,l*s),h=En("int32",l*s);for(let p=0;p<l;p++){const g=p*u,x=n.subarray(g,g+u);let b=new Array(x.length);x.forEach(($,k)=>b[k]={value:$,index:k}),s<b.length&&(_E(b,s),b=b.slice(0,s)),o&&b.sort(Mu);const v=p*s,S=c.subarray(v,v+s),C=h.subarray(v,v+s);for(let $=0;$<s;$++)S[$]=b[$].value,C[$]=b[$].index}const f=t.slice();return f[f.length-1]=s,[Ht(f,e,c),Ht(f,"int32",h)]}function ME(n,t,e,s){const o=qt(t,e)[0],i=[1,e[0],1];for(let b=0;b<o;b++)i[0]*=e[b];i[1]=e[o];for(let b=o+1;b<e.length;b++)i[2]*=e[b];const l=new Map,u=new Int32Array(e[o]),c=new vn(i,s,n),h=[],f=i[0]===1&&i[2]===1;for(let b=0;b<e[o];b++){let v;if(f)v=n[b].toString();else{const C=[];for(let $=0;$<i[0];$++)for(let k=0;k<i[2];k++)C.push(c.get($,b,k));v=C.join(",")}const S=l.get(v);if(S!=null)u[b]=S;else{const C=l.size;l.set(v,C),u[b]=C,h.push(b)}}const p=i.slice();p[1]=l.size;const g=new vn(p,s);h.forEach((b,v)=>{for(let S=0;S<i[0];S++)for(let C=0;C<i[2];C++)g.set(c.get(S,b,C),S,v,C)});const x=e.slice();return x[o]=p[1],{outputValues:g.values,outputShape:x,indices:u}}const XG=Object.freeze(Object.defineProperty({__proto__:null,addImpl:HN,bincountImpl:Qy,bincountReduceImpl:qN,bitwiseAndImpl:jN,castImpl:WN,ceilImpl:XN,concatImpl:KN,equalImpl:YN,expImpl:QN,expm1Impl:tE,floorDivImpl:nE,floorImpl:eE,gatherNdImpl:sE,gatherV2Impl:oE,greaterEqualImpl:iE,greaterImpl:aE,lessEqualImpl:lE,lessImpl:rE,linSpaceImpl:uE,logImpl:cE,maxImpl:hE,maximumImpl:dE,minimumImpl:fE,multiplyImpl:Jy,negImpl:pE,notEqualImpl:mE,prodImpl:gE,raggedGatherImpl:xE,raggedRangeImpl:bE,raggedTensorToTensorImpl:yE,rangeImpl:vE,rsqrtImpl:wE,scatterImpl:Li,sigmoidImpl:_G,simpleAbsImpl:GN,sliceImpl:CE,sparseFillEmptyRowsImpl:$E,sparseReshapeImpl:TE,sparseSegmentReductionImpl:e1,sqrtImpl:zG,squaredDifferenceImpl:kE,staticRegexReplaceImpl:IE,stridedSliceImpl:NE,stringNGramsImpl:EE,stringSplitImpl:RE,stringToHashBucketFastImpl:AE,subImpl:DE,tileImpl:OE,topKImpl:FE,transposeImpl:t1,uniqueImpl:ME},Symbol.toStringTag,{value:"Module"}));iT("cpu",()=>new nm,1);const zE=ge(pc,n=>n>=0?n:Math.exp(n)-1),KG={kernelName:pc,backendName:"cpu",kernelFunc:zE};function LE(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{alpha:i}=s;It([o],"leakyRelu");const l=dt(o.shape),u=e.data.get(o.dataId).values,c=En("float32",l);for(let h=0;h<u.length;h++)c[h]=u[h]<0?i*u[h]:u[h];return e.makeTensorInfo(o.shape,"float32",c)}const YG={kernelName:tp,backendName:"cpu",kernelFunc:LE};const ZG=Xe((n,t)=>n<0?t*n:n);function BE(n){const{inputs:t,backend:e}=n,{x:s,alpha:o}=t;It([s,o],"prelu");const i=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,[u,c]=ZG(s.shape,o.shape,i,l,"float32");return e.makeTensorInfo(c,"float32",u)}const QG={kernelName:yp,backendName:"cpu",kernelFunc:BE};const UE=ge(Oc,n=>Math.max(0,n)),JG={kernelName:Oc,backendName:"cpu",kernelFunc:UE};const VE=ge(_c,n=>Math.min(Math.max(0,n),6)),tW={kernelName:_c,backendName:"cpu",kernelFunc:VE};function If(n,t,e,s,o){if(e==="linear")return zo({inputs:{x:t},backend:n});if(e==="relu")return UE({inputs:{x:t},backend:n});if(e==="elu")return zE({inputs:{x:t},backend:n});if(e==="relu6")return VE({inputs:{x:t},backend:n});if(e==="prelu")return BE({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return LE({inputs:{x:t},backend:n,attrs:{alpha:o}});if(e==="sigmoid")return SE({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Ee(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{shape:i}=s,l=dt(o.shape),u=g$(i,l),c=dt(u);_(l===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${o.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);const h=e.data.get(o.dataId);if(h.complexTensorInfos!=null){const f=h.complexTensorInfos.real,p=h.complexTensorInfos.imag;f.shape=u,p.shape=u}return{dataId:o.dataId,shape:u,dtype:o.dtype}}const eW={kernelName:wp,backendName:"cpu",kernelFunc:Ee};function PE(n){const{inputs:t,backend:e,attrs:s}=n,{a:o,b:i}=t,{transposeA:l,transposeB:u}=s;It([o,i],"matMul");const c=o.shape.length,h=i.shape.length,f=l?o.shape[c-2]:o.shape[c-1],p=u?i.shape[h-1]:i.shape[h-2],g=l?o.shape[c-1]:o.shape[c-2],x=u?i.shape[h-2]:i.shape[h-1],b=o.shape.slice(0,-2),v=i.shape.slice(0,-2),S=dt(b),C=dt(v),k=Ut(o.shape.slice(0,-2),i.shape.slice(0,-2)).concat([g,x]);_(f===p,()=>`Error in matMul: inner shapes (${f}) and (${p}) of Tensors with shapes ${o.shape} and ${i.shape} and transposeA=${l} and transposeB=${u} must match.`);const T=l?[S,f,g]:[S,g,f],N=u?[C,x,p]:[C,p,x],R=Ee({inputs:{x:o},backend:e,attrs:{shape:T}}),D=Ee({inputs:{x:i},backend:e,attrs:{shape:N}}),z=l?R.shape[1]:R.shape[2],O=l?R.shape[2]:R.shape[1],F=u?D.shape[1]:D.shape[2],E=Math.max(S,C),U=e.data.get(R.dataId).values,Y=e.data.get(D.dataId).values,X=Rt(R.shape),q=Rt(D.shape),[L,P,W]=l?[X[0],1,X[1]]:[X[0],X[1],1],[nt,it,M]=u?[1,q[1],q[0]]:[q[1],1,q[0]],G=O*F,Q=Ht([E,O,F],R.dtype),ut=Q.values,ft=e.blockSize;for(let gt=0;gt<E;gt++){const yt=gt%S,Tt=gt%C;for(let St=0;St<O;St+=ft){const zt=Math.min(St+ft,O);for(let Lt=0;Lt<F;Lt+=ft){const ne=Math.min(Lt+ft,F);for(let pe=0;pe<z;pe+=ft){const he=Math.min(pe+ft,z);for(let de=St;de<zt;de++)for(let oe=Lt;oe<ne;oe++){let Re=0;for(let ve=pe;ve<he;ve++){const ds=U[yt*L+de*P+ve*W],Ue=Y[ve*nt+oe*it+Tt*M];Re+=ds*Ue}ut[gt*G+(de*F+oe)]+=Re}}}}}return e.disposeIntermediateTensorInfo(R),e.disposeIntermediateTensorInfo(D),e.makeTensorInfo(k,Q.dtype,Q.values)}const nW={kernelName:Bf,backendName:"cpu",kernelFunc:PE};function sW(n){const{inputs:t,backend:e,attrs:s}=n,{a:o,b:i,bias:l,preluActivationWeights:u}=t,{transposeA:c,transposeB:h,activation:f,leakyreluAlpha:p}=s;let g,x,b;const v=[];g=PE({inputs:{a:o,b:i},attrs:{transposeA:c,transposeB:h},backend:e}),l&&(x=pl({inputs:{a:g,b:l},backend:e}),v.push(g),g=x),f&&(b=If(e,g,f,u,p),v.push(g),g=b);for(const C of v)e.disposeIntermediateTensorInfo(C);return g}const oW={kernelName:of,backendName:"cpu",kernelFunc:sW};const aW=ge(ec,n=>Math.acos(n)),iW={kernelName:ec,backendName:"cpu",kernelFunc:aW};const rW=ge(nc,n=>Math.acosh(n)),lW={kernelName:nc,backendName:"cpu",kernelFunc:rW};function uW(n){const{inputs:t,backend:e}=n,s=t;It(t,"addN");const o=s.map(u=>e.data.get(u.dataId).values),i=Ht(s[0].shape,s[0].dtype),l=i.values;for(let u=0;u<s.length;u++){const c=o[u];for(let h=0;h<l.length;h++)l[h]+=c[h]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}const cW={kernelName:V0,backendName:"cpu",kernelFunc:uW};function hW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s;It(o,"all");const u=qt(i,o.shape);let c=u;const h=Be(c,o.shape.length);let f=o;h!=null&&(f=Yn({inputs:{x:o},backend:e,attrs:{perm:h}}),c=qe(c.length,o.shape.length)),Sn("all",c,f.shape.length);const[p,g]=gn(f.shape,c),x=dt(g),b=Rn(dt(p),f.dtype),v=e.data.get(f.dataId).values;for(let C=0;C<b.length;++C){const $=C*x;let k=v[$];for(let T=0;T<x;++T){const N=v[$+T];k=k&&N}b[C]=k}h!=null&&e.disposeIntermediateTensorInfo(f);const S=e.makeTensorInfo(p,f.dtype,b);if(l){const C=Qe(p,u),$=Ee({inputs:{x:S},backend:e,attrs:{shape:C}});return e.disposeIntermediateTensorInfo(S),$}return S}const dW={kernelName:P0,backendName:"cpu",kernelFunc:hW};function fW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s;It(o,"any");const u=qt(i,o.shape);let c=u;const h=Be(c,o.shape.length);let f=o;h!=null&&(f=Yn({inputs:{x:o},backend:e,attrs:{perm:h}}),c=qe(c.length,o.shape.length)),Sn("any",c,f.shape.length);const[p,g]=gn(f.shape,c),x=dt(g),b=Rn(dt(p),f.dtype),v=e.data.get(f.dataId).values;for(let C=0;C<b.length;++C){const $=C*x;let k=v[$];for(let T=0;T<x;++T){const N=v[$+T];k=k||N}b[C]=k}h!=null&&e.disposeIntermediateTensorInfo(f);const S=e.makeTensorInfo(p,f.dtype,b);if(l){const C=Qe(p,u),$=Ee({inputs:{x:S},backend:e,attrs:{shape:C}});return e.disposeIntermediateTensorInfo(S),$}return S}const pW={kernelName:G0,backendName:"cpu",kernelFunc:fW};function mW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i}=s;It(o,"argMax");let l=qt(i,o.shape);const u=Be(l,o.shape.length);let c=o;const h=[];u!=null&&(c=Yn({inputs:{x:o},backend:e,attrs:{perm:u}}),h.push(c),l=qe(l.length,c.shape.length)),l=[l[0]],Sn("argMax",l,c.shape.length);const[f,p]=gn(c.shape,l),g=dt(f),x=Rn(g,"int32"),b=dt(p),v=e.data.get(c.dataId).values;for(let S=0;S<x.length;++S){const C=S*b;let $=v[C],k=0;for(let T=0;T<b;++T){const N=v[C+T];N>$&&($=N,k=T)}x[S]=k}return h.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(f,"int32",x)}const gW={kernelName:Ff,backendName:"cpu",kernelFunc:mW};function xW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i}=s;It(o,"argMin");let l=qt(i,o.shape);const u=Be(l,o.shape.length);let c=o;const h=[];u!=null&&(c=Yn({inputs:{x:o},backend:e,attrs:{perm:u}}),h.push(c),l=qe(l.length,c.shape.length)),l=[l[0]],Sn("argMin",l,c.shape.length);const[f,p]=gn(c.shape,l),g=dt(f),x=Rn(g,"int32"),b=dt(p),v=e.data.get(c.dataId).values;for(let S=0;S<x.length;++S){const C=S*b;let $=v[C],k=0;for(let T=0;T<b;++T){const N=v[C+T];N<$&&($=N,k=T)}x[S]=k}return h.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(f,"int32",x)}const bW={kernelName:Mf,backendName:"cpu",kernelFunc:xW};const yW=ge(sc,n=>Math.asin(n)),vW={kernelName:sc,backendName:"cpu",kernelFunc:yW};const wW=ge(oc,n=>Math.asinh(n)),SW={kernelName:oc,backendName:"cpu",kernelFunc:wW};const CW=ge(ac,n=>Math.atan(n)),$W={kernelName:ac,backendName:"cpu",kernelFunc:CW};const TW=Xe((n,t)=>Math.atan2(n,t)),kW=cn(rc,TW),IW={kernelName:rc,backendName:"cpu",kernelFunc:kW};const NW=ge(ic,n=>Math.atanh(n)),EW={kernelName:ic,backendName:"cpu",kernelFunc:NW};function s1(n,t,e,s,o,i){const l=o.strideHeight,u=o.strideWidth,c=o.dilationHeight,h=o.dilationWidth,f=o.effectiveFilterHeight,p=o.effectiveFilterWidth,g=o.padInfo.top,x=o.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Ht(o.outShape,e),S=v.values,C=o.outShape[1]*o.outShape[2]*o.outShape[3],$=o.outShape[2]*o.outShape[3],k=o.outShape[3];for(let T=0;T<o.batchSize;++T){const N=T*C,R=T*s[0];for(let D=0;D<o.inChannels;++D)for(let z=0;z<o.outHeight;++z){const O=z*l-g,F=Math.max(0,O),E=Math.min(o.inHeight,f+O),U=N+z*$;for(let Y=0;Y<o.outWidth;++Y){const X=Y*u-x,q=Math.max(0,X),L=Math.min(o.inWidth,p+X);let P=b,W=0,nt=0;for(let M=F;M<E;M+=c){const G=R+M*s[1];for(let Q=q;Q<L;Q+=h){const ut=G+Q*s[2],ft=n[ut+D];i==="max"&&ft>P?P=ft:i==="avg"&&(W+=ft,nt++)}if(isNaN(P))break}const it=U+Y*k+D;S[it]=i==="avg"?W/nt:P}}}return v}function GE(n,t,e,s,o=!1,i=!1){const l=Ht(s.outShape,"int32"),u=s.strideHeight,c=s.strideWidth,h=s.dilationHeight,f=s.dilationWidth,p=s.effectiveFilterHeight,g=s.effectiveFilterWidth,x=s.padInfo.top,b=s.padInfo.left,v=Ht(t,e,n);for(let S=0;S<s.batchSize;++S)for(let C=0;C<s.inChannels;++C)for(let $=0;$<s.outHeight;++$){const k=$*u-x;let T=k;for(;T<0;)T+=h;const N=Math.min(s.inHeight,p+k);for(let R=0;R<s.outWidth;++R){const D=R*c-b;let z=D;for(;z<0;)z+=f;const O=Math.min(s.inWidth,g+D);let F=Number.NEGATIVE_INFINITY,E=-1;for(let U=T;U<N;U+=h){const Y=U-k;for(let X=z;X<O;X+=f){const q=X-D,L=v.get(S,U,X,C);L>F&&(F=L,o?E=i?((S*s.inHeight+U)*s.inWidth+X)*s.inChannels+C:(U*s.inWidth+X)*s.inChannels+C:E=Y*g+q)}}l.set(E,S,$,R,C)}}return l}function WE(n,t,e,s,o,i){const l=o.strideDepth,u=o.strideHeight,c=o.strideWidth,h=o.dilationDepth,f=o.dilationHeight,p=o.dilationWidth,g=o.effectiveFilterDepth,x=o.effectiveFilterHeight,b=o.effectiveFilterWidth,v=o.padInfo.front,S=o.padInfo.top,C=o.padInfo.left,$=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=Ht(o.outShape,e),T=k.values,N=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],R=o.outShape[2]*o.outShape[3]*o.outShape[4],D=o.outShape[3]*o.outShape[4],z=o.outShape[4];for(let O=0;O<o.batchSize;++O){const F=O*N,E=O*s[0];for(let U=0;U<o.inChannels;++U)for(let Y=0;Y<o.outDepth;++Y){const X=Y*l-v;let q=X;for(;q<0;)q+=h;const L=Math.min(o.inDepth,g+X),P=F+Y*R;for(let W=0;W<o.outHeight;++W){const nt=W*u-S;let it=nt;for(;it<0;)it+=f;const M=Math.min(o.inHeight,x+nt),G=P+W*D;for(let Q=0;Q<o.outWidth;++Q){const ut=Q*c-C;let ft=ut;for(;ft<0;)ft+=p;const gt=Math.min(o.inWidth,b+ut),yt=G+Q*z;let Tt=$,St=0,zt=0;for(let ne=q;ne<L;ne+=h){const pe=E+ne*s[1];for(let he=it;he<M;he+=f){const de=pe+he*s[2];for(let oe=ft;oe<gt;oe+=p){const Re=de+oe*s[3],ve=n[Re+U];if(i==="max"&&ve>Tt?Tt=ve:i==="avg"&&(St+=ve,zt++),isNaN(Tt))break}if(isNaN(Tt))break}if(isNaN(Tt))break}const Lt=yt+U;T[Lt]=i==="avg"?St/Math.max(zt,1):Tt}}}}return k}function RW(n,t){const e=Ht(t.outShape,"int32"),s=t.strideDepth,o=t.strideHeight,i=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,h=t.effectiveFilterDepth,f=t.effectiveFilterHeight,p=t.effectiveFilterWidth,g=t.padInfo.front,x=t.padInfo.top,b=t.padInfo.left;for(let v=0;v<t.batchSize;++v)for(let S=0;S<t.inChannels;++S)for(let C=0;C<t.outDepth;++C){const $=C*s-g;let k=$;for(;k<0;)k+=l;const T=Math.min(t.inDepth,h+$);for(let N=0;N<t.outHeight;++N){const R=N*o-x;let D=R;for(;D<0;)D+=u;const z=Math.min(t.inHeight,f+R);for(let O=0;O<t.outWidth;++O){const F=O*i-b;let E=F;for(;E<0;)E+=c;const U=Math.min(t.inWidth,p+F);let Y=Number.NEGATIVE_INFINITY,X=-1;for(let q=k;q<T;q+=l){const L=q-$;for(let P=D;P<z;P+=u){const W=P-R;for(let nt=E;nt<U;nt+=c){const it=nt-F,M=n.get(v,q,P,nt,S);M>=Y&&(Y=M,X=L*f*p+W*f+it)}}}e.set(X,v,C,N,O,S)}}}return e}function AW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t;It(o,"avgPool");const{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,h=1;_(Dn(l,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${h}'`);const f=js(o.shape,i,l,h,u,c);let p;if(f.filterWidth===1&&f.filterHeight===1&&ce(f.inShape,f.outShape))p=zo({inputs:{x:o},backend:e});else{const g=e.data.get(o.dataId).values,x=Rt(o.shape),b=s1(g,o.shape,o.dtype,x,f,"avg");p=e.makeTensorInfo(f.outShape,o.dtype,b.values)}return p}const DW={kernelName:zf,backendName:"cpu",kernelFunc:AW};function OW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{filterSize:i,strides:l,pad:u,dimRoundingMode:c,dataFormat:h}=s;It(o,"avgPool3d");const f=fa(o.shape,i,l,1,u,c,h),p=e.data.get(o.dataId).values,g=WE(p,o.shape,o.dtype,Rt(o.shape),f,"avg");return e.makeTensorInfo(g.shape,"float32",g.values)}const _W={kernelName:Lf,backendName:"cpu",kernelFunc:OW};function FW(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,input:i}=t,{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s;It([o,i],"avgPool3DGrad");const f=fa(i.shape,l,u,1,c,h),p=f.strideDepth,g=f.strideHeight,x=f.strideWidth,b=f.filterDepth,v=f.filterHeight,S=f.filterWidth,C=f.dilationDepth,$=f.dilationHeight,k=f.dilationWidth,T=f.effectiveFilterDepth,N=f.effectiveFilterHeight,R=f.effectiveFilterWidth,D=T-1-f.padInfo.front,z=R-1-f.padInfo.left,O=N-1-f.padInfo.top,F=Ht(i.shape,"float32"),E=1/(b*v*S),U=e.bufferSync(o);for(let Y=0;Y<f.batchSize;++Y)for(let X=0;X<f.inChannels;++X)for(let q=0;q<f.inDepth;++q)for(let L=0;L<f.inHeight;++L)for(let P=0;P<f.inWidth;++P){const W=q-D,nt=L-O,it=P-z;let M=0;for(let G=0;G<T;G+=C){const Q=(W+G)/p;if(!(Q<0||Q>=f.outDepth||Math.floor(Q)!==Q))for(let ut=0;ut<N;ut+=$){const ft=(nt+ut)/g;if(!(ft<0||ft>=f.outHeight||Math.floor(ft)!==ft))for(let gt=0;gt<R;gt+=k){const yt=(it+gt)/x;if(yt<0||yt>=f.outWidth||Math.floor(yt)!==yt)continue;const Tt=U.get(Y,Q,ft,yt,X);M+=Tt}}}F.set(M*E,Y,q,L,P,X)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}const MW={kernelName:H0,backendName:"cpu",kernelFunc:FW};function zW(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,input:i}=t,l=i;It([o,i],"avgPoolGrad");const{filterSize:u,strides:c,pad:h}=s,f=js(l.shape,u,c,1,h),p=f.strideHeight,g=f.strideWidth,x=f.filterHeight,b=f.filterWidth,v=f.dilationHeight,S=f.dilationWidth,C=f.effectiveFilterHeight,$=f.effectiveFilterWidth,k=$-1-f.padInfo.left,T=C-1-f.padInfo.top,N=Ht(l.shape,"float32"),R=1/(x*b),D=e.data.get(o.dataId).values,z=Ht(o.shape,"float32",D);for(let O=0;O<f.batchSize;++O)for(let F=0;F<f.inChannels;++F)for(let E=0;E<f.inHeight;++E)for(let U=0;U<f.inWidth;++U){const Y=E-T,X=U-k;let q=0;for(let L=0;L<C;L+=v){const P=(Y+L)/p;if(!(P<0||P>=f.outHeight||Math.floor(P)!==P))for(let W=0;W<$;W+=S){const nt=(X+W)/g;if(nt<0||nt>=f.outWidth||Math.floor(nt)!==nt)continue;const it=z.get(O,P,nt,F);q+=it}}N.set(q*R,O,E,U,F)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const LW={kernelName:W0,backendName:"cpu",kernelFunc:zW};function BW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,scale:i,offset:l,mean:u,variance:c}=t;_(u.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(l==null||u.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(i==null||u.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),It([o,u,c,i,l],"batchNorm");let{varianceEpsilon:h}=s;h==null&&(h=.001);const f=e.data.get(o.dataId).values,p=e.data.get(u.dataId).values,g=e.data.get(c.dataId).values,x=i?e.data.get(i.dataId).values:new Float32Array([1]),b=l?e.data.get(l.dataId).values:new Float32Array([0]),v=new Float32Array(f.length),S=b.length,C=x.length,$=g.length,k=p.length;let T=0,N=0,R=0,D=0;for(let z=0;z<f.length;++z)v[z]=b[T++]+(f[z]-p[N++])*x[R++]/Math.sqrt(g[D++]+h),T>=S&&(T=0),N>=k&&(N=0),R>=C&&(R=0),D>=$&&(D=0);return e.makeTensorInfo(o.shape,o.dtype,v)}const UW={kernelName:Zf,backendName:"cpu",kernelFunc:BW};function VW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{blockShape:i,crops:l}=s;It([o],"batchToSpaceND");const u=i.reduce((C,$)=>C*$),c=eh(o.shape,i,u),h=nh(c.length,i.length),f=sh(o.shape,i,u),p=fy(l,i.length),g=py(f,l,i.length),x=Ee({inputs:{x:o},backend:e,attrs:{shape:c}}),b=Yn({inputs:{x},backend:e,attrs:{perm:h}}),v=Ee({inputs:{x:b},backend:e,attrs:{shape:f}}),S=tr({inputs:{x:v},backend:e,attrs:{begin:p,size:g}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(v),S}const PW={kernelName:Uf,backendName:"cpu",kernelFunc:VW};function GW(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,weights:i}=t,{size:l}=s,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values,h=Qy(u,c,i.dtype,i.shape,l);return e.makeTensorInfo([l],i.dtype,h)}const WW={kernelName:q0,backendName:"cpu",kernelFunc:GW};function HW(n){const{inputs:t,backend:e}=n,{s0:s,s1:o}=t,i=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,u=Ut(Array.from(i),Array.from(l));return e.makeTensorInfo([u.length],"int32",Int32Array.from(u))}const qW={kernelName:S$,backendName:"cpu",kernelFunc:HW};const jW=ge(cc,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),XW={kernelName:cc,backendName:"cpu",kernelFunc:jW};const KW=n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(dt(t.shape)),o=e.data.get(t.dataId),i=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=e.data.get(i.dataId).values,c=e.data.get(l.dataId).values;for(let h=0;h<u.length;h++){const f=u[h],p=c[h];s[h]=Math.hypot(f,p)}return e.makeOutput(s,t.shape,"float32")},YW={kernelName:Vf,backendName:"cpu",kernelFunc:KW};function ml(n){const{inputs:t,backend:e}=n,{input:s}=t,o=e.data.get(s.dataId).complexTensorInfos.imag,i=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,i)}const ZW={kernelName:cb,backendName:"cpu",kernelFunc:ml};function gl(n){const{inputs:t,backend:e,attrs:s}=n,{axis:o}=s,i=qt(o,t[0].shape)[0],l=t.map(v=>v.shape);cy(l,i);let u=Eo(t.map(v=>v.shape),i);if(dt(u)===0)return e.makeTensorInfo(u,t[0].dtype,[]);const c=t.filter(v=>dt(v.shape)>0);if(c.length===1)return zo({inputs:{x:c[0]},backend:e});if(c[0].dtype==="complex64"){const v=c.map(T=>Ji({inputs:{input:T},backend:e})),S=c.map(T=>ml({inputs:{input:T},backend:e})),C=gl({inputs:v,backend:e,attrs:{axis:i}}),$=gl({inputs:S,backend:e,attrs:{axis:i}}),k=rs({inputs:{real:C,imag:$},backend:e});return v.forEach(T=>e.disposeIntermediateTensorInfo(T)),S.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo($),k}const h=c.map(v=>{const C=[-1,dt(v.shape.slice(i))];return Ee({inputs:{x:v},backend:e,attrs:{shape:C}})}),f=h.map(v=>({vals:e.data.get(v.dataId).values,shape:v.shape}));u=Eo(h.map(v=>v.shape),1);const p=h[0].shape[0]===1,g=KN(f,u,t[0].dtype,p),x=Eo(c.map(v=>v.shape),i),b=e.makeTensorInfo(x,t[0].dtype,g);return h.forEach(v=>e.disposeIntermediateTensorInfo(v)),b}const QW={kernelName:Pf,backendName:"cpu",kernelFunc:gl};function HE(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:f}=s;It([o,i],"conv2d");const p=pa(c),g=wn(o.shape,i.shape,l,h,u,f,!1,p),x=g.filterHeight,b=g.filterWidth,v=g.dilationHeight,S=g.dilationWidth,C=g.padInfo.left,$=g.padInfo.top,k=g.dataFormat==="channelsLast",T=new vn(g.outShape,o.dtype),N=Rt(o.shape),R=Rt(i.shape),D=N[0],z=k?N[1]:N[2],O=k?N[2]:1,F=k?1:N[1],E=T.strides[0],U=k?T.strides[1]:T.strides[2],Y=k?T.strides[2]:1,X=k?1:T.strides[1],q=e.data.get(o.dataId).values,L=e.data.get(i.dataId).values,P=T.values;for(let W=0;W<g.batchSize;++W){const nt=W*D,it=W*E;for(let M=0;M<g.outHeight;++M){const G=it+M*U,Q=M*g.strideHeight-$;for(let ut=0;ut<x;++ut){const ft=Q+ut*v;if(ft<0||ft>=g.inHeight)continue;const gt=ut*R[0],yt=nt+ft*z;for(let Tt=0;Tt<g.outWidth;++Tt){const St=G+Tt*Y,zt=Tt*g.strideWidth-C;for(let Lt=0;Lt<b;++Lt){const ne=zt+Lt*S;if(ne<0||ne>=g.inWidth)continue;const pe=gt+Lt*R[1],he=yt+ne*O;let de=pe;for(let oe=0;oe<g.inChannels;++oe){const Re=q[he+oe*F];for(let ve=0;ve<g.outChannels;++ve)P[St+ve*X]+=Re*L[de+ve];de+=g.outChannels}}}}}}return e.makeTensorInfo(T.shape,T.dtype,P)}const JW={kernelName:Gf,backendName:"cpu",kernelFunc:HE};function tH(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,dy:i}=t,{strides:l,pad:u,dataFormat:c,dimRoundingMode:h,filterShape:f}=s;It([o,i],"conv2dBackpropFilter");const p=pa(c),g=wn(o.shape,f,l,1,u,h,!1,p),{strideHeight:x,strideWidth:b,filterHeight:v,filterWidth:S}=g,C=g.dataFormat==="channelsLast",$=new vn(g.filterShape,"float32"),k=g.padInfo.left,T=g.padInfo.top,N=e.data.get(o.dataId).values,R=e.data.get(i.dataId).values,D=new vn(o.shape,o.dtype,N),z=new vn(i.shape,i.dtype,R);for(let O=0;O<v;++O){const F=Math.max(0,Math.ceil((T-O)/x)),E=Math.min(g.outHeight,(g.inHeight+T-O)/x);for(let U=0;U<S;++U){const Y=Math.max(0,Math.ceil((k-U)/b)),X=Math.min(g.outWidth,(g.inWidth+k-U)/b);for(let q=0;q<g.inChannels;++q)for(let L=0;L<g.outChannels;++L){let P=0;for(let W=0;W<g.batchSize;++W)for(let nt=F;nt<E;++nt){const it=O+nt*x-T;for(let M=Y;M<X;++M){const G=U+M*b-k;C?P+=D.get(W,it,G,q)*z.get(W,nt,M,L):P+=D.get(W,q,it,G)*z.get(W,L,nt,M)}}$.set(P,O,U,q,L)}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}const eH={kernelName:K0,backendName:"cpu",kernelFunc:tH};function nH(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,filter:i}=t,{inputShape:l,strides:u,pad:c,dataFormat:h,dimRoundingMode:f}=s;It([o,i],"conv2dBackpropInput");const p=Rt(i.shape),g=Rt(o.shape);let x=pa(h);const b=wn(l,i.shape,u,1,c,f,!1,x),v=new vn(b.inShape,"float32"),S=v.values,C=e.data.get(o.dataId).values,$=e.data.get(i.dataId).values,[k,T,N]=p,{batchSize:R,filterHeight:D,filterWidth:z,inChannels:O,inHeight:F,inWidth:E,outChannels:U,outHeight:Y,outWidth:X,strideHeight:q,strideWidth:L}=b;x=b.dataFormat;const P=D-1-b.padInfo.top,W=z-1-b.padInfo.left,nt=x==="channelsLast",it=v.strides[0],M=nt?v.strides[1]:v.strides[2],G=nt?v.strides[2]:1,Q=nt?1:v.strides[1],ut=g[0],ft=nt?g[1]:g[2],gt=nt?g[2]:1,yt=nt?1:g[1];for(let Tt=0;Tt<R;++Tt)for(let St=0;St<O;++St)for(let zt=0;zt<F;++zt){const Lt=zt-P,ne=Math.max(0,Math.ceil(Lt/q)),pe=Math.min(Y,(D+Lt)/q);for(let he=0;he<E;++he){const de=he-W,oe=Math.max(0,Math.ceil(de/L)),Re=Math.min(X,(z+de)/L);let ve=0;for(let Ue=ne;Ue<pe;++Ue){const Ns=Ue*q-Lt;for(let Pn=oe;Pn<Re;++Pn){const Bo=Pn*L-de,De=ut*Tt+ft*Ue+gt*Pn,Ys=k*(D-1-Ns)+T*(z-1-Bo)+N*St;for(let Zs=0;Zs<U;++Zs){const Qs=C[De+yt*Zs],fs=$[Ys+Zs];ve+=Qs*fs}}}const ds=it*Tt+M*zt+G*he+Q*St;S[ds]=ve}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const sH={kernelName:Wf,backendName:"cpu",kernelFunc:nH};function oH(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i}=t,{strides:l,pad:u,dilations:c}=s;It([o,i],"conv3d");const h=oi(o.shape,i.shape,l,c,u),{filterDepth:f,filterHeight:p,filterWidth:g,dilationDepth:x,dilationHeight:b,dilationWidth:v,padInfo:S}=h,C=S.front,$=S.left,k=S.top,T=new vn(h.outShape,o.dtype),N=e.data.get(o.dataId).values,R=e.data.get(i.dataId).values,D=T.values,z=Rt(o.shape),O=Rt(i.shape);for(let F=0;F<h.batchSize;++F){const E=F*z[0],U=F*T.strides[0];for(let Y=0;Y<h.outDepth;++Y){const X=U+Y*T.strides[1],q=Y*h.strideDepth-C;for(let L=0;L<f;++L){const P=q+L*x;if(P<0||P>=h.inDepth)continue;const W=L*O[0],nt=E+P*z[1];for(let it=0;it<h.outHeight;++it){const M=X+it*T.strides[2],G=it*h.strideHeight-k;for(let Q=0;Q<p;++Q){const ut=G+Q*b;if(ut<0||ut>=h.inHeight)continue;const ft=W+Q*O[1],gt=nt+ut*z[2];for(let yt=0;yt<h.outWidth;++yt){const Tt=M+yt*h.outChannels,St=yt*h.strideWidth-$;for(let zt=0;zt<g;++zt){const Lt=St+zt*v;if(Lt<0||Lt>=h.inWidth)continue;const ne=ft+zt*O[2],pe=gt+Lt*h.inChannels;let he=ne;for(let de=0;de<h.inChannels;++de){const oe=N[pe+de];for(let Re=0;Re<h.outChannels;++Re)D[Tt+Re]+=oe*R[he+Re];he+=h.outChannels}}}}}}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const aH={kernelName:Hf,backendName:"cpu",kernelFunc:oH};function iH(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,dy:i}=t,{strides:l,pad:u,filterShape:c}=s;It([o,i],"conv3dBackpropFilterV2");const h=Rt(o.shape),f=Rt(i.shape),p=oi(o.shape,c,l,1,u),g=p.strideDepth,x=p.strideHeight,b=p.strideWidth,v=p.filterDepth,S=p.filterHeight,C=p.filterWidth,$=new vn(p.filterShape,"float32"),k=$.values,[T,N,R,D]=$.strides,z=e.data.get(i.dataId).values,[O,F,E,U]=f,Y=e.data.get(o.dataId).values,[X,q,L,P]=h,W=p.padInfo.front,nt=p.padInfo.left,it=p.padInfo.top;for(let M=0;M<v;++M){const G=Math.max(0,Math.ceil((W-M)/g)),Q=Math.min(p.outDepth,(p.inDepth+W-M)/g),ut=M*T;for(let ft=0;ft<S;++ft){const gt=Math.max(0,Math.ceil((it-ft)/x)),yt=Math.min(p.outHeight,(p.inHeight+it-ft)/x),Tt=ft*N+ut;for(let St=0;St<C;++St){const zt=Math.max(0,Math.ceil((nt-St)/b)),Lt=Math.min(p.outWidth,(p.inWidth+nt-St)/b),ne=St*R+Tt;for(let pe=0;pe<p.inChannels;++pe){const he=pe*D+ne;for(let de=0;de<p.outChannels;++de){let oe=0;for(let Re=0;Re<p.batchSize;++Re){const ve=Re*X,ds=Re*O;for(let Ue=G;Ue<Q;++Ue){const Pn=(M+Ue*g-W)*q+ve,Bo=Ue*F+ds;for(let De=gt;De<yt;++De){const Zs=(ft+De*x-it)*L+Pn,Qs=De*E+Bo;for(let fs=zt;fs<Lt;++fs){const dr=(St+fs*b-nt)*P+Zs,Fl=fs*U+Qs;oe+=Y[dr+pe]*z[Fl+de]}}}}k[he+de]=oe}}}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}const rH={kernelName:Y0,backendName:"cpu",kernelFunc:iH};function lH(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,filter:i}=t,{pad:l,strides:u,inputShape:c}=s;It([o],"conv3dBackpropInputV2");const h=Rt(o.shape),f=Rt(i.shape),p=oi(c,i.shape,u,1,l),g=new vn(p.inShape,"float32"),x=g.values,[b,v,S,C]=g.strides,$=e.data.get(o.dataId).values,[k,T,N,R]=h,D=e.data.get(i.dataId).values,[z,O,F,E]=f,{batchSize:U,filterDepth:Y,filterHeight:X,filterWidth:q,inChannels:L,inDepth:P,inHeight:W,inWidth:nt,outChannels:it,outDepth:M,outHeight:G,outWidth:Q,strideDepth:ut,strideHeight:ft,strideWidth:gt}=p,yt=Y-1-p.padInfo.front,Tt=X-1-p.padInfo.top,St=q-1-p.padInfo.left;for(let zt=0;zt<U;++zt)for(let Lt=0;Lt<L;++Lt)for(let ne=0;ne<P;++ne){const pe=ne-yt,he=Math.max(0,Math.ceil(pe/ut)),de=Math.min(M,(Y+pe)/ut);for(let oe=0;oe<W;++oe){const Re=oe-Tt,ve=Math.max(0,Math.ceil(Re/ft)),ds=Math.min(G,(X+Re)/ft);for(let Ue=0;Ue<nt;++Ue){const Ns=Ue-St,Pn=Math.max(0,Math.ceil(Ns/gt)),Bo=Math.min(Q,(q+Ns)/gt);let De=0;for(let Ys=he;Ys<de;++Ys){const Zs=Ys*ut-pe;for(let Qs=ve;Qs<ds;++Qs){const fs=Qs*ft-Re;for(let di=Pn;di<Bo;++di){const dr=di*gt-Ns,Fl=k*zt+T*Ys+N*Qs+R*di,um=z*(Y-1-Zs)+O*(X-1-fs)+F*(q-1-dr)+E*Lt;for(let mo=0;mo<it;++mo){const Gn=$[Fl+mo],go=D[um+mo];De+=Gn*go}}}}x[b*zt+v*ne+S*oe+C*Ue+Lt]=De}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}const uH={kernelName:Z0,backendName:"cpu",kernelFunc:lH};const cH=ge(hc,n=>Math.cos(n)),hH={kernelName:hc,backendName:"cpu",kernelFunc:cH};const dH=ge(dc,n=>Math.cosh(n)),fH={kernelName:dc,backendName:"cpu",kernelFunc:dH};function pH(n){const{inputs:t,backend:e,attrs:s}=n,{image:o,boxes:i,boxInd:l}=t,{cropSize:u,method:c,extrapolationValue:h}=s,[f,p,g,x]=o.shape,b=i.shape[0],[v,S]=u,C=Ht([b,v,S,x],"float32"),$=e.data.get(i.dataId).values,k=e.data.get(l.dataId).values,T=e.data.get(o.dataId).values,N=Rt(o.shape),R=Rt(C.shape);for(let D=0;D<b;D++){const z=D*4,O=$[z],F=$[z+1],E=$[z+2],U=$[z+3],Y=k[D];if(Y>=f)continue;const X=v>1?(E-O)*(p-1)/(v-1):0,q=S>1?(U-F)*(g-1)/(S-1):0;for(let L=0;L<v;L++){const P=v>1?O*(p-1)+L*X:.5*(O+E)*(p-1);if(P<0||P>p-1){for(let W=0;W<S;W++)for(let nt=0;nt<x;nt++){const it=nt+W*R[2]+L*R[1]+D*R[0];C.values[it]=h}continue}if(c==="bilinear"){const W=Math.floor(P),nt=Math.ceil(P),it=P-W;for(let M=0;M<S;M++){const G=S>1?F*(g-1)+M*q:.5*(F+U)*(g-1);if(G<0||G>g-1){for(let gt=0;gt<x;gt++){const yt=gt+M*R[2]+L*R[1]+D*R[0];C.values[yt]=h}continue}const Q=Math.floor(G),ut=Math.ceil(G),ft=G-Q;for(let gt=0;gt<x;gt++){let yt=gt+Q*N[2]+W*N[1]+Y*N[0];const Tt=T[yt];yt=gt+ut*N[2]+W*N[1]+Y*N[0];const St=T[yt];yt=gt+Q*N[2]+nt*N[1]+Y*N[0];const zt=T[yt];yt=gt+ut*N[2]+nt*N[1]+Y*N[0];const Lt=T[yt],ne=Tt+(St-Tt)*ft,pe=zt+(Lt-zt)*ft;yt=gt+M*R[2]+L*R[1]+D*R[0],C.values[yt]=ne+(pe-ne)*it}}}else for(let W=0;W<S;++W){const nt=S>1?F*(g-1)+W*q:.5*(F+U)*(g-1);if(nt<0||nt>g-1){for(let G=0;G<x;G++){const Q=G+W*R[2]+L*R[1]+D*R[0];C.values[Q]=h}continue}const it=Math.round(nt),M=Math.round(P);for(let G=0;G<x;G++){const Q=G+it*N[2]+M*N[1]+Y*N[0],ut=G+W*R[2]+L*R[1]+D*R[0];C.values[ut]=T[Q]}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const mH={kernelName:J0,backendName:"cpu",kernelFunc:pH};function gH(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,exclusive:l,reverse:u}=s;It(o,"cumprod");const c=Be([i],o.shape.length);let h=o;c!=null&&(h=Yn({inputs:{x:o},backend:e,attrs:{perm:c}}));const f=qe(1,o.shape.length)[0];if(f!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${f}`);const p=us(h.dtype,"int32"),g=L0(dt(h.shape),p),x=e.data.get(h.dataId).values,b=h.shape[h.shape.length-1],v=u?(C,$)=>C+b-$-1:(C,$)=>C+$;for(let C=0;C<x.length;C+=b)for(let $=0;$<b;$++){const k=v(C,$);if($===0)g[k]=l?1:x[k];else{const T=v(C,$-1);g[k]=l?x[T]*g[T]:x[k]*g[T]}}const S=e.makeTensorInfo(h.shape,p,g);if(c!=null){const C=ai(c),$=Yn({inputs:{x:S},backend:e,attrs:{perm:C}});return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(h),$}return S}const xH={kernelName:Q0,backendName:"cpu",kernelFunc:gH};function bH(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,exclusive:l,reverse:u}=s;It(o,"cumsum");const c=Be([i],o.shape.length);let h=o;c!=null&&(h=Yn({inputs:{x:o},backend:e,attrs:{perm:c}}));const f=qe(1,o.shape.length)[0];if(f!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${f}`);const p=us(h.dtype,"int32"),g=Rn(dt(h.shape),p),x=e.data.get(h.dataId).values,b=h.shape[h.shape.length-1],v=u?(C,$)=>C+b-$-1:(C,$)=>C+$;for(let C=0;C<x.length;C+=b)for(let $=0;$<b;$++){const k=v(C,$);if($===0)g[k]=l?0:x[k];else{const T=v(C,$-1);g[k]=l?x[T]+g[T]:x[k]+g[T]}}const S=e.makeTensorInfo(h.shape,p,g);if(c!=null){const C=ai(c),$=Yn({inputs:{x:S},backend:e,attrs:{perm:C}});return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(h),$}return S}const yH={kernelName:qf,backendName:"cpu",kernelFunc:bH};function vH(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,weights:i}=t,{size:l,binaryOutput:u}=s;if(o.shape.length===1){const c=e.data.get(o.dataId).values,h=e.data.get(i.dataId).values,f=Qy(c,h,i.dtype,i.shape,l);return e.makeTensorInfo([l],i.dtype,f)}else if(o.shape.length===2){const c=e.bufferSync(o),h=e.bufferSync(i),f=qN(c,h,l,u);return e.makeTensorInfo(f.shape,i.dtype,f.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}const wH={kernelName:tb,backendName:"cpu",kernelFunc:vH};function SH(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{blockSize:i,dataFormat:l}=s;_(l==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${l}`);const u=o.shape[0],c=o.shape[1],h=o.shape[2],f=o.shape[3],p=c*i,g=h*i,x=f/(i*i),b=e.data.get(o.dataId).values,v=new Float32Array(u*p*g*x);let S=0;for(let C=0;C<u;++C)for(let $=0;$<p;++$){const k=Math.floor($/i),T=$%i;for(let N=0;N<g;++N){const R=Math.floor(N/i),D=N%i,z=(T*i+D)*x;for(let O=0;O<x;++O){const E=O+z+f*(R+h*(k+c*C));v[S++]=b[E]}}}return e.makeTensorInfo([u,p,g,x],o.dtype,v)}const CH={kernelName:eb,backendName:"cpu",kernelFunc:SH};function qE(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h}=s;It([o,i],"depthwiseConv2DNative");const f=Rt(o.shape),p=Rt(i.shape);let g=c;g==null&&(g=[1,1]),_(Dn(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const x=wn(o.shape,i.shape,l,g,u,h,!0),{filterHeight:b,filterWidth:v,dilationHeight:S,dilationWidth:C,padInfo:$}=x,k=$.left,T=$.top,N=x.outChannels/x.inChannels,R=new vn(x.outShape,o.dtype),D=e.data.get(o.dataId).values,z=e.data.get(i.dataId).values,O=R.values;for(let F=0;F<x.batchSize;++F){const E=F*f[0],U=F*R.strides[0];for(let Y=0;Y<x.outHeight;++Y){const X=U+Y*R.strides[1],q=Y*x.strideHeight-T;for(let L=0;L<b;++L){const P=q+L*S;if(P<0||P>=x.inHeight)continue;const W=L*p[0],nt=E+P*f[1];for(let it=0;it<x.outWidth;++it){const M=X+it*R.strides[2],G=it*x.strideWidth-k;for(let Q=0;Q<v;++Q){const ut=G+Q*C;if(ut<0||ut>=x.inWidth)continue;const ft=W+Q*p[1],gt=nt+ut*x.inChannels;let yt=M,Tt=ft;for(let St=0;St<x.inChannels;++St){const zt=D[gt+St];for(let Lt=0;Lt<N;++Lt)O[yt+Lt]+=zt*z[Tt+Lt];yt+=N,Tt+=N}}}}}}return e.makeTensorInfo(R.shape,R.dtype,R.values)}const $H={kernelName:jf,backendName:"cpu",kernelFunc:qE};function TH(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,dy:i}=t,{strides:l,dilations:u,pad:c,dimRoundingMode:h,filterShape:f}=s;It([o,i],"depthwiseConv2dNativeBackpropFilter");const p=wn(o.shape,f,l,u,c,h,!0),{strideHeight:g,strideWidth:x,filterHeight:b,filterWidth:v}=p,S=new vn(p.filterShape,"float32"),C=p.padInfo.left,$=p.padInfo.top,k=p.outChannels/p.inChannels,T=e.data.get(o.dataId).values,N=new vn(o.shape,o.dtype,T),R=e.data.get(i.dataId).values,D=new vn(i.shape,i.dtype,R);for(let z=0;z<b;++z){const O=Math.max(0,Math.ceil(($-z)/g)),F=Math.min(p.outHeight,(p.inHeight+$-z)/g);for(let E=0;E<v;++E){const U=Math.max(0,Math.ceil((C-E)/x)),Y=Math.min(p.outWidth,(p.inWidth+C-E)/x);for(let X=0;X<p.outChannels;++X){const q=Math.trunc(X/k),L=X%k;let P=0;for(let W=0;W<p.batchSize;++W)for(let nt=O;nt<F;++nt){const it=z+nt*g-$;for(let M=U;M<Y;++M){const G=E+M*x-C;P+=N.get(W,it,G,q)*D.get(W,nt,M,X)}}S.set(P,z,E,q,L)}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const kH={kernelName:nb,backendName:"cpu",kernelFunc:TH};function IH(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,filter:i}=t,{strides:l,dilations:u,pad:c,dimRoundingMode:h,inputShape:f}=s;It([o,i],"depthwiseConv2DNativeBackpropInput");const p=Rt(o.shape),g=Rt(i.shape),x=wn(f,i.shape,l,u,c,h,!0),b=new vn(x.inShape,"float32"),v=b.values,[S,C,$]=b.strides,k=e.data.get(o.dataId).values,[T,N,R]=p,D=e.data.get(i.dataId).values,[z,O,F]=g,{batchSize:E,filterHeight:U,filterWidth:Y,inChannels:X,inHeight:q,inWidth:L,outChannels:P,outHeight:W,outWidth:nt,strideHeight:it,strideWidth:M}=x,G=U-1-x.padInfo.top,Q=Y-1-x.padInfo.left,ut=P/X;for(let ft=0;ft<E;++ft)for(let gt=0;gt<X;++gt)for(let yt=0;yt<q;++yt){const Tt=yt-G,St=Math.max(0,Math.ceil(Tt/it)),zt=Math.min(W,(U+Tt)/it);for(let Lt=0;Lt<L;++Lt){const ne=Lt-Q,pe=Math.max(0,Math.ceil(ne/M)),he=Math.min(nt,(Y+ne)/M);let de=0;for(let oe=St;oe<zt;++oe){const Re=oe*it-Tt;for(let ve=pe;ve<he;++ve){const ds=ve*M-ne,Ue=T*ft+N*oe+R*ve,Ns=z*(U-1-Re)+O*(Y-1-ds)+F*gt;for(let Pn=0;Pn<ut;++Pn){const Bo=gt*ut+Pn,De=k[Ue+Bo],Ys=D[Ns+Pn];de+=De*Ys}}}v[S*ft+C*yt+$*Lt+gt]=de}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const NH={kernelName:sb,backendName:"cpu",kernelFunc:IH};function EH(n){const{inputs:t,backend:e}=n,{x:s}=t,o=dt(s.shape),i=e.data.get(s.dataId).values,l=Ht([o,o],s.dtype),u=l.values;for(let h=0;h<i.length;h++)u[h*o+h]=i[h];const c=[...s.shape,...s.shape];return e.makeTensorInfo(c,l.dtype,l.values)}const RH={kernelName:C$,backendName:"cpu",kernelFunc:EH};const AH={kernelName:Xf,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:o}=n,{strides:i,pad:l,dilations:u}=e,c=t,h=c.data.get(s.dataId).values,f=s.shape.length,p=c.data.get(o.dataId).values,g=o.shape.length,{batchSize:x,inHeight:b,inWidth:v,inChannels:S,outHeight:C,outWidth:$,padInfo:k,strideHeight:T,strideWidth:N,filterHeight:R,filterWidth:D,dilationHeight:z,dilationWidth:O,outShape:F}=Yc(s.shape,o.shape,i,l,"NHWC",u),E=dt(F),U=F.length,Y=Ge(s.dtype,E);for(let q=0;q<x;++q)for(let L=0;L<C;++L){const P=L*T-k.top;for(let W=0;W<$;++W){const nt=W*N-k.left;for(let it=0;it<S;++it){let M=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<R;++Q){const ut=P+Q*z;if(ut>=0&&ut<b)for(let ft=0;ft<D;++ft){const gt=nt+ft*O;if(gt>=0&&gt<v){const yt=Io([q,ut,gt,it],f,Rt(s.shape)),Tt=Io([Q,ft,it],g,Rt(o.shape)),St=h[yt]+p[Tt];St>M&&(M=St)}}}const G=Io([q,L,W,it],U,Rt(F));Y[G]=M}}}return{dataId:c.write(nr(Y,s.dtype),F,s.dtype),shape:F,dtype:s.dtype}}};const DH={kernelName:n0,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:o,dy:i}=n,{strides:l,pad:u,dilations:c}=e,h=t,f=ro(s.shape,h.data.get(s.dataId).values),p=ro(o.shape,h.data.get(o.dataId).values),{batchSize:g,inHeight:x,inWidth:b,inChannels:v,outHeight:S,outWidth:C,padInfo:$,strideHeight:k,strideWidth:T,filterHeight:N,filterWidth:R,dilationHeight:D,dilationWidth:z,outShape:O}=Yc(s.shape,o.shape,l,u,"NHWC",c);_(i.rank===O.length,()=>`Error in ${n0}, dy must have the same rank as output ${O.length}, but got ${i.rank}`);const F=ro(O,h.data.get(i.dataId).values),E=y$(o.shape,o.dtype);for(let Y=0;Y<g;++Y)for(let X=0;X<S;++X){const q=X*k-$.top;for(let L=0;L<C;++L){const P=L*T-$.left;for(let W=0;W<v;++W){let nt=Number.MIN_SAFE_INTEGER,it=0,M=0;for(let G=0;G<N;++G){const Q=q+G*D;if(Q>=0&&Q<x)for(let ut=0;ut<R;++ut){const ft=P+ut*z;if(ft>=0&&ft<b){const gt=f[Y][Q][ft][W]+p[G][ut][W];gt>nt&&(nt=gt,it=G,M=ut)}}}E[it][M][W]+=F[Y][X][L][W]}}}return{dataId:h.write(nr(E,s.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};const OH={kernelName:e0,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:o,dy:i}=n,{strides:l,pad:u,dilations:c}=e,h=t,f=ro(s.shape,h.data.get(s.dataId).values),p=ro(o.shape,h.data.get(o.dataId).values),{batchSize:g,inHeight:x,inWidth:b,inChannels:v,outHeight:S,outWidth:C,padInfo:$,strideHeight:k,strideWidth:T,filterHeight:N,filterWidth:R,dilationHeight:D,dilationWidth:z,outShape:O}=Yc(s.shape,o.shape,l,u,"NHWC",c);_(i.rank===O.length,()=>`Error in ${e0}, dy must have the same rank as output ${O.length}, but got ${i.rank}`);const F=ro(O,h.data.get(i.dataId).values),E=y$(s.shape,s.dtype);for(let Y=0;Y<g;++Y)for(let X=0;X<S;++X){const q=X*k-$.top;for(let L=0;L<C;++L){const P=L*T-$.left;for(let W=0;W<v;++W){let nt=Number.MIN_SAFE_INTEGER,it=q<0?0:q,M=P<0?0:P;for(let G=0;G<N;++G){const Q=q+G*D;if(Q>=0&&Q<x)for(let ut=0;ut<R;++ut){const ft=P+ut*z;if(ft>=0&&ft<b){const gt=f[Y][Q][ft][W]+p[G][ut][W];gt>nt&&(nt=gt,it=Q,M=ft)}}}E[Y][it][M][W]+=F[Y][X][L][W]}}}return{dataId:h.write(nr(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function _H(n){const{inputs:t,backend:e,attrs:s}=n,{image:o}=t,{canvas:i,options:l}=s,{contextOptions:u,imageOptions:c}=l||{},h=c?.alpha||1,f=u?.contextType||"2d";if(f!=="2d")throw new Error(`Context type ${u.contextType} is not supported by the CPU backend.`);const p=i.getContext(f,u?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${f} type.`);const[g,x]=o.shape.slice(0,2),b=o.shape.length===2?1:o.shape[2],v=e.data.get(o.dataId).values,S=o.dtype==="float32"?255:1,C=new Uint8ClampedArray(x*g*4);for(let k=0;k<g*x;++k){const T=[0,0,0,255*h];for(let R=0;R<b;R++){const D=v[k*b+R];if(o.dtype==="float32"){if(D<0||D>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${D}.`)}else if(o.dtype==="int32"&&(D<0||D>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${D}.`);b===1?(T[0]=D*S,T[1]=D*S,T[2]=D*S):T[R]=D*S}const N=k*4;C[N+0]=Math.round(T[0]),C[N+1]=Math.round(T[1]),C[N+2]=Math.round(T[2]),C[N+3]=Math.round(T[3])}i.width=x,i.height=g;const $=new ImageData(C,x,g);return p.putImageData($,0,0),o}const FH={kernelName:jO,backendName:"cpu",kernelFunc:_H};function dh(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s;It(o,"sum");let u;o.dtype==="bool"?u=ti({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):u=zo({inputs:{x:o},backend:e});const c=u.shape.length,h=qt(i,u.shape),f=Be(h,c);let p=h,g=u;f!=null&&(g=Yn({inputs:{x:u},backend:e,attrs:{perm:f}}),p=qe(p.length,c)),Sn("sum",p,g.shape.length);const[x,b]=gn(g.shape,p),v=us(g.dtype,"int32");let S=Tf(e,x,v);const C=dt(b),$=e.data.get(S.dataId).values,k=e.data.get(g.dataId).values;for(let T=0;T<$.length;++T){const N=T*C;let R=0;for(let D=0;D<C;++D)R+=k[N+D];$[T]=R}if(l){const T=Qe(S.shape,h),N=S;S=Ee({inputs:{x:S},backend:e,attrs:{shape:T}}),e.disposeIntermediateTensorInfo(N)}return e.disposeIntermediateTensorInfo(u),f!=null&&e.disposeIntermediateTensorInfo(g),S}const MH={kernelName:Ip,backendName:"cpu",kernelFunc:dh};function zH(n){const{inputs:t,backend:e,attrs:s}=n,{equation:o}=s,i=t,{allDims:l,summedDims:u,idDims:c}=Sy(o,i.length);$y(l.length,c,i);const{path:h,steps:f}=Ty(u,c),p=f.length;let g=null,x=l.length;const b=[];for(let v=0;v<p;++v){for(const S of f[v]){const{permutationIndices:C,expandDims:$}=Cy(x,c[S]);let k;ky(C)?k=i[S]:(k=Yn({inputs:{x:i[S]},backend:e,attrs:{perm:C}}),b.push(k));const T=k.shape.slice();for(let N=0;N<$.length;++N)T.splice($[N],0,1);ce(k.shape,T)||(k=Ee({inputs:{x:k},backend:e,attrs:{shape:T}}),b.push(k)),g===null?g=k:(g=sm({inputs:{a:k,b:g},backend:e}),b.push(g))}v<p-1&&(h[v]>=0&&(g=dh({inputs:{x:g},backend:e,attrs:{axis:h[v]-(l.length-x),keepDims:!1}}),b.push(g)),x--)}for(const v of b)v!==g&&e.disposeIntermediateTensorInfo(v);return g}const LH={kernelName:ob,backendName:"cpu",kernelFunc:zH};function BH(n){const{inputs:t,backend:e}=n,{dy:s,y:o}=t;It([s,o],"eluGrad");const i=new Float32Array(dt(o.shape)),l=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values;for(let c=0;c<l.length;++c){const h=l[c];h>=0?i[c]=u[c]:i[c]=u[c]*(h+1)}return e.makeTensorInfo(o.shape,"float32",i)}const UH={kernelName:ab,backendName:"cpu",kernelFunc:BH};const VH=my,PH=gy,GH=xy,WH=by,HH=yy,qH=vy,jH=ge(mc,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+VH*e);return t*(1-((((qH*s+HH)*s+WH)*s+GH)*s+PH)*s*Math.exp(-e*e))}),XH={kernelName:mc,backendName:"cpu",kernelFunc:jH};function Nf(n){const{inputs:t,backend:e,attrs:s}=n,{input:o}=t,{dim:i}=s,l=o.shape.length,u=o.shape.slice();let c=i;return i<0&&(_(-(l+1)<=i,()=>`Axis must be in the interval [${-(l+1)}, ${l}]`),c=l+i+1),u.splice(c,0,1),Ee({inputs:{x:o},backend:e,attrs:{shape:u}})}const KH={kernelName:Yf,backendName:"cpu",kernelFunc:Nf};const YH=Xe((n,t)=>n/t),o1=cn(fc,YH),I0={kernelName:fc,backendName:"cpu",kernelFunc:o1};function jE(n,t,e){const s=n.shape,o=s[0],i=s[1],l=e.data.get(n.dataId),u=l.complexTensorInfos.real,c=l.complexTensorInfos.imag,h=[o,i],f=dt(h),p=En("float32",f),g=En("float32",f);for(let S=0;S<o;S++){const C=tr({inputs:{x:u},backend:e,attrs:{begin:[S,0],size:[1,i]}}),$=tr({inputs:{x:c},backend:e,attrs:{begin:[S,0],size:[1,i]}}),k=rs({inputs:{real:C,imag:$},backend:e}),{real:T,imag:N}=ZH(k,t,e),R=ca(T,N);for(let D=0;D<i;D++){const z=wy(R,D);p[S*i+D]=z.real,g[S*i+D]=z.imag}e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo($),e.disposeIntermediateTensorInfo(k)}const x=e.makeTensorInfo(h,"float32",p),b=e.makeTensorInfo(h,"float32",g),v=rs({inputs:{real:x,imag:b},backend:e});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),v}function ZH(n,t,e){const s=dt(n.shape),o=e.data.get(n.dataId),i=e.data.get(o.complexTensorInfos.real.dataId).values,l=e.data.get(o.complexTensorInfos.imag.dataId).values;if(QH(s)){const u=N0(i,l,s,t,e),c=[n.shape[0],n.shape[1]];if(t){const h=e.makeTensorInfo(c,"float32",u.real),f=e.makeTensorInfo(c,"float32",u.imag),p=e.makeTensorInfo([],"float32",ni(s,"float32")),g=zo({inputs:{x:p},backend:e}),x=I0.kernelFunc({inputs:{a:h,b:p},backend:e}),b=I0.kernelFunc({inputs:{a:f,b:g},backend:e}),v=e.data.get(x.dataId).values,S=e.data.get(b.dataId).values;return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),{real:v,imag:S}}return u}else{const u=ca(i,l),c=JH(u,s,t);return lk(c)}}function QH(n){return(n&n-1)===0}function N0(n,t,e,s,o){if(e===1)return{real:n,imag:t};const i=ca(n,t),l=e/2,u=uk(i),c=u.real,h=u.imag,f=[c.length],p=o.makeTensorInfo(f,"float32",c),g=o.makeTensorInfo(f,"float32",h),x=rs({inputs:{real:p,imag:g},backend:o}),b=ck(i),v=b.real,S=b.imag,C=[v.length],$=o.makeTensorInfo(C,"float32",v),k=o.makeTensorInfo(C,"float32",S),T=rs({inputs:{real:$,imag:k},backend:o}),N=N0(c,h,l,s,o),R=N.real,D=N.imag,z=[R.length],O=o.makeTensorInfo(z,"float32",R),F=o.makeTensorInfo(z,"float32",D),E=rs({inputs:{real:O,imag:F},backend:o}),U=N0(v,S,l,s,o),Y=U.real,X=U.imag,q=[Y.length],L=o.makeTensorInfo(q,"float32",Y),P=o.makeTensorInfo(q,"float32",X),W=rs({inputs:{real:L,imag:P},backend:o}),nt=dk(e,s),it=[nt.real.length],M=o.makeTensorInfo(it,"float32",nt.real),G=o.makeTensorInfo(it,"float32",nt.imag),Q=rs({inputs:{real:M,imag:G},backend:o}),ut=sm({inputs:{a:Q,b:W},backend:o}),ft=pl({inputs:{a:E,b:ut},backend:o}),gt=n1({inputs:{a:E,b:ut},backend:o}),yt=Ji({inputs:{input:ft},backend:o}),Tt=Ji({inputs:{input:gt},backend:o}),St=ml({inputs:{input:ft},backend:o}),zt=ml({inputs:{input:gt},backend:o}),Lt=gl({inputs:[yt,Tt],backend:o,attrs:{axis:0}}),ne=gl({inputs:[St,zt],backend:o,attrs:{axis:0}}),pe=o.data.get(Lt.dataId).values,he=o.data.get(ne.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(g),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo($),o.disposeIntermediateTensorInfo(k),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(O),o.disposeIntermediateTensorInfo(F),o.disposeIntermediateTensorInfo(E),o.disposeIntermediateTensorInfo(L),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(W),o.disposeIntermediateTensorInfo(M),o.disposeIntermediateTensorInfo(G),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(ut),o.disposeIntermediateTensorInfo(ft),o.disposeIntermediateTensorInfo(gt),o.disposeIntermediateTensorInfo(yt),o.disposeIntermediateTensorInfo(St),o.disposeIntermediateTensorInfo(Tt),o.disposeIntermediateTensorInfo(zt),o.disposeIntermediateTensorInfo(Lt),o.disposeIntermediateTensorInfo(ne),{real:pe,imag:he}}function JH(n,t,e){const s=new Float32Array(t*2);for(let o=0;o<t;o++){let i=0,l=0;for(let u=0;u<t;u++){const c=fk(o*u,t,e),h=wy(n,u);i+=h.real*c.real-h.imag*c.imag,l+=h.real*c.imag+h.imag*c.real}e&&(i/=t,l/=t),hk(s,i,l,o)}return s}function t6(n){const{inputs:t,backend:e}=n,{input:s}=t,o=dt(s.shape),i=s.shape[s.shape.length-1],l=o/i,u=Ee({inputs:{x:s},backend:e,attrs:{shape:[l,i]}}),c=jE(u,!1,e),h=Ee({inputs:{x:c},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),h}const e6={kernelName:ib,backendName:"cpu",kernelFunc:t6};function a1(n){const{backend:t,attrs:e}=n,{shape:s,value:o,dtype:i}=e,l=i||yl(o),u=Ge(l,dt(s));return s6(u,o,l),t.makeTensorInfo(s,l,u)}const n6={kernelName:rb,backendName:"cpu",kernelFunc:a1};function s6(n,t,e){n.fill(t)}const o6={kernelName:lb,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,o=e,i=En(s.dtype,dt(s.shape)),[l,u,c,h]=s.shape,f=o.data.get(s.dataId).values;for(let g=0;g<l;g++){const x=g*c*u*h;for(let b=0;b<u;b++){const v=b*(c*h);for(let S=0;S<c;S++){const C=S*h;for(let $=0;$<h;$++){const k=Math.round(c-S-1),T=x+v+C+$;let N=f[T];if(k>=0&&k<c){const R=k*h,D=x+v+R+$;N=f[D]}i[T]=N}}}}return{dataId:o.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function a6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i,bias:l,preluActivationWeights:u}=t,{strides:c,pad:h,dataFormat:f,dilations:p,dimRoundingMode:g,activation:x,leakyreluAlpha:b}=s;let v=HE({inputs:{x:o,filter:i},backend:e,attrs:{strides:c,pad:h,dataFormat:f,dilations:p,dimRoundingMode:g}});if(l){const S=v;if(f==="NCHW"&&l.shape.length===1&&l.shape[0]!==1){const C=Ee({inputs:{x:l},backend:e,attrs:{shape:[l.shape[0],1,1]}});v=pl({inputs:{a:v,b:C},backend:e}),e.disposeIntermediateTensorInfo(C)}else v=pl({inputs:{a:v,b:l},backend:e});e.disposeIntermediateTensorInfo(S)}if(x){const S=v;if(f==="NCHW"&&x==="prelu"&&u.shape.length===1&&u.shape[0]!==1){const C=Ee({inputs:{x:u},backend:e,attrs:{shape:[u.shape[0],1,1]}});v=If(e,v,x,C,b),e.disposeIntermediateTensorInfo(C)}else v=If(e,v,x,u,b);e.disposeIntermediateTensorInfo(S)}return v}const i6={kernelName:af,backendName:"cpu",kernelFunc:a6};function r6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i,bias:l,preluActivationWeights:u}=t,{strides:c,pad:h,dataFormat:f,dilations:p,dimRoundingMode:g,activation:x,leakyreluAlpha:b}=s;let v=qE({inputs:{x:o,filter:i},backend:e,attrs:{strides:c,pad:h,dataFormat:f,dilations:p,dimRoundingMode:g}});if(l){const S=v;v=pl({inputs:{a:v,b:l},backend:e}),e.disposeIntermediateTensorInfo(S)}if(x){const S=v;v=If(e,v,x,u,b),e.disposeIntermediateTensorInfo(S)}return v}const l6={kernelName:P$,backendName:"cpu",kernelFunc:r6};function u6(n){const{inputs:t,backend:e}=n,{params:s,indices:o}=t,i=dt(s.shape),l=o.shape,u=l[l.length-1],[c,h,f,p]=ly(s,o);if(h===0)return e.makeTensorInfo(c,s.dtype,[]);const g=e.data.get(o.dataId).values,x=e.bufferSync(s),b=sE(g,x,s.dtype,h,u,f,p,s.shape,i);return e.makeTensorInfo(c,s.dtype,b.values)}const c6={kernelName:$$,backendName:"cpu",kernelFunc:u6};function h6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,indices:i}=t,{axis:l,batchDims:u}=s;It([o,i],"gatherV2");const c=qt(l,o.shape)[0],h=e.data.get(i.dataId).values,f=o.shape[c];for(let T=0;T<h.length;++T){const N=h[T];_(N<=f-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${f-1}]`)}let p=u;u==null&&(p=0);const g=dt(i.shape),x=Tk(o,i,c,p),b=Ee({inputs:{x:o},backend:e,attrs:{shape:[x.batchSize,x.outerSize,x.dimSize,x.sliceSize]}}),v=Ee({inputs:{x:i},backend:e,attrs:{shape:[x.batchSize,g/x.batchSize]}}),S=[x.batchSize,x.outerSize,g/x.batchSize,x.sliceSize],C=e.bufferSync(v),$=e.bufferSync(b),k=oE($,C,S);return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(v),e.makeTensorInfo(x.outputShape,k.dtype,k.values)}const d6={kernelName:Qf,backendName:"cpu",kernelFunc:h6};function f6(n){const{inputs:t,backend:e}=n,{input:s}=t,o=dt(s.shape),i=s.shape[s.shape.length-1],l=o/i,u=Ee({inputs:{x:s},backend:e,attrs:{shape:[l,i]}}),c=jE(u,!0,e),h=Ee({inputs:{x:c},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),h}const p6={kernelName:ub,backendName:"cpu",kernelFunc:f6};const m6=ge(Sc,n=>Number.isFinite(n)?1:0,"bool"),g6={kernelName:Sc,backendName:"cpu",kernelFunc:m6};const x6=ge(Cc,n=>Math.abs(n)===1/0?1:0,"bool"),b6={kernelName:Cc,backendName:"cpu",kernelFunc:x6};const y6=ge($c,n=>Number.isNaN(n)?1:0,"bool"),v6={kernelName:$c,backendName:"cpu",kernelFunc:y6};function w6(n){const{backend:t,attrs:e}=n,{start:s,stop:o,num:i}=e,l=uE(s,o,i);return t.makeTensorInfo([l.length],"float32",l)}const S6={kernelName:T$,backendName:"cpu",kernelFunc:w6};const C6=ge(kc,n=>Math.log1p(n)),$6={kernelName:kc,backendName:"cpu",kernelFunc:C6};const T6=Xe((n,t)=>n&&t),k6=cn(sp,T6,null,"bool"),I6={kernelName:sp,backendName:"cpu",kernelFunc:k6};const N6=ge(op,n=>n?0:1,"bool"),E6={kernelName:op,backendName:"cpu",kernelFunc:N6};const R6=Xe((n,t)=>n||t),A6=cn(ap,R6,null,"bool"),D6={kernelName:ap,backendName:"cpu",kernelFunc:A6};function O6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=s;It(o,"LRN");const h=o.shape[3],f=h-1,p=e.data.get(o.dataId).values,g=dt(o.shape),x=new Float32Array(g);function b(v){const S=v%h;let C=v-S+Math.max(0,S-i);const $=v-S+Math.min(S+i,f);let k=0;for(;C<=$;C++){const T=p[C];k+=T*T}return k}for(let v=0;v<g;v++){const S=b(v),C=p[v]*Math.pow(l+u*S,-c);x[v]=C}return e.makeTensorInfo(o.shape,o.dtype,x)}const _6={kernelName:ip,backendName:"cpu",kernelFunc:O6};function F6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,y:i,dy:l}=t,{depthRadius:u,bias:c,alpha:h,beta:f}=s;It(l,"LRNGrad");const p=dt(l.shape),g=l.shape[3],x=e.data.get(l.dataId).values,b=e.data.get(o.dataId).values,v=e.data.get(i.dataId).values,S=new Float32Array(p),C=p;for(let $=0;$<C;$++){const k=$%g,T=$-k+Math.max(0,k-u),N=$-k+Math.min(g,k+u+1);let R=0;for(let D=T;D<N;D++)R+=Math.pow(b[D],2);R=h*R+c;for(let D=T;D<N;D++){let z=-2*h*f*b[D]*v[$]/R;$===D&&(z+=Math.pow(R,-f)),z*=x[$],S[D]+=z}}return e.makeTensorInfo(l.shape,o.dtype,S)}const M6={kernelName:hb,backendName:"cpu",kernelFunc:F6};function XE(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{reductionIndices:i,keepDims:l}=s,u=e;let c=o.shape;const h=c.length,f=qt(i,c);let p=f;const g=Be(p,h);let x=u.data.get(o.dataId).values;if(g!=null){const T=new Array(h);for(let N=0;N<T.length;N++)T[N]=c[g[N]];x=t1(x,c,o.dtype,g,T),p=qe(p.length,h),c=T}It(o,"max"),Sn("max",p,h);const[b,v]=gn(c,p),S=dt(v),C=hE(x,S,b,o.dtype),$=u.write(C,b,o.dtype);let k=b;return l&&(k=Qe(b,f)),{dataId:$,shape:k,dtype:o.dtype}}const z6={kernelName:rp,backendName:"cpu",kernelFunc:XE};function L6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t;It(o,"maxPool");const{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,h=1;_(Dn(l,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${h}'`);const f=js(o.shape,i,l,h,u,c);let p;if(f.filterWidth===1&&f.filterHeight===1&&ce(f.inShape,f.outShape))p=zo({inputs:{x:o},backend:e});else{const g=e.data.get(o.dataId).values,x=Rt(o.shape),b=s1(g,o.shape,o.dtype,x,f,"max");p=e.makeTensorInfo(f.outShape,o.dtype,b.values)}return p}const B6={kernelName:lp,backendName:"cpu",kernelFunc:L6};function U6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{filterSize:i,strides:l,pad:u,dimRoundingMode:c,dataFormat:h}=s;It(o,"maxPool3d");const f=fa(o.shape,i,l,1,u,c,h),p=e.data.get(o.dataId).values,g=WE(p,o.shape,o.dtype,Rt(o.shape),f,"max");return e.makeTensorInfo(g.shape,"float32",g.values)}const V6={kernelName:up,backendName:"cpu",kernelFunc:U6};function P6(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,input:i}=t,{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s;It([o,i],"maxPool3DGrad");const f=fa(i.shape,l,u,1,c,h),p=e.bufferSync(i),g=RW(p,f),x=f.strideDepth,b=f.strideHeight,v=f.strideWidth,S=f.dilationDepth,C=f.dilationHeight,$=f.dilationWidth,k=f.effectiveFilterDepth,T=f.effectiveFilterHeight,N=f.effectiveFilterWidth,R=k-1-f.padInfo.front,D=N-1-f.padInfo.left,z=T-1-f.padInfo.top,O=Ht(i.shape,"float32"),F=e.bufferSync(o);for(let E=0;E<f.batchSize;++E)for(let U=0;U<f.inChannels;++U)for(let Y=0;Y<f.inDepth;++Y)for(let X=0;X<f.inHeight;++X)for(let q=0;q<f.inWidth;++q){const L=Y-R,P=X-z,W=q-D;let nt=0;for(let it=0;it<k;it+=S){const M=(L+it)/x;if(!(M<0||M>=f.outDepth||Math.floor(M)!==M))for(let G=0;G<T;G+=C){const Q=(P+G)/b;if(!(Q<0||Q>=f.outHeight||Math.floor(Q)!==Q))for(let ut=0;ut<N;ut+=$){const ft=(W+ut)/v;if(ft<0||ft>=f.outWidth||Math.floor(ft)!==ft)continue;const gt=k*T*N-1-g.get(E,M,Q,ft,U),yt=it*T*N+G*N+ut,Tt=gt===yt?1:0;if(Tt===0)continue;const St=F.get(E,M,Q,ft,U);nt+=St*Tt}}}O.set(nt,E,Y,X,q,U)}return e.makeTensorInfo(O.shape,O.dtype,O.values)}const G6={kernelName:fb,backendName:"cpu",kernelFunc:P6};function W6(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,input:i,output:l}=t,u=i;It([i,l],"maxPoolGrad");const{filterSize:c,strides:h,pad:f,dimRoundingMode:p}=s,g=js(u.shape,c,h,1,f,p),x=e.data.get(u.dataId).values,b=Ht(g.outShape,u.dtype,GE(x,u.shape,u.dtype,g).values),v=g.strideHeight,S=g.strideWidth,C=g.dilationHeight,$=g.dilationWidth,k=g.effectiveFilterHeight,T=g.effectiveFilterWidth,N=T-1-g.padInfo.left,R=k-1-g.padInfo.top,D=Ht(u.shape,"float32"),z=e.data.get(o.dataId).values,O=Ht(o.shape,"float32",z);for(let F=0;F<g.batchSize;++F)for(let E=0;E<g.inChannels;++E)for(let U=0;U<g.inHeight;++U)for(let Y=0;Y<g.inWidth;++Y){const X=U-R,q=Y-N;let L=0;for(let P=0;P<k;P+=C){const W=(X+P)/v;if(!(W<0||W>=g.outHeight||Math.floor(W)!==W))for(let nt=0;nt<T;nt+=$){const it=(q+nt)/S;if(it<0||it>=g.outWidth||Math.floor(it)!==it)continue;const M=k*T-1-b.get(F,W,it,E),G=P*T+nt,Q=M===G?1:0;if(Q===0)continue;const ut=O.get(F,W,it,E);L+=ut*Q}}D.set(L,F,U,Y,E)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}const H6={kernelName:db,backendName:"cpu",kernelFunc:W6};function q6(n,t,e,s,o){const i=Rt(t),l=s1(n,t,e,i,o,"max"),u=GE(n,t,e,o,!0,s);return[l.values,u.values]}const j6={kernelName:k$,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:o,strides:i,pad:l,includeBatchInIndex:u}=t,c=e;It(s,"MaxPoolWithArgmax");const h=c.data.get(s.dataId).values,f=js(s.shape,o,i,[1,1],l),[p,g]=q6(h,s.shape,s.dtype,u,f),x=c.write(p,f.outShape,s.dtype),b=c.write(g,f.outShape,s.dtype);return[{dataId:x,shape:f.outShape,dtype:s.dtype},{dataId:b,shape:f.outShape,dtype:"int32"}]}};function X6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s,u=qt(i,o.shape),h=gn(o.shape,u)[1],f=dt(h),p=[],g=e.makeTensorInfo([],"float32",new Float32Array([f]));p.push(g);const x=ti({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(x);const b=o1({inputs:{a:x,b:g},backend:e});p.push(b);const v=dh({inputs:{x:b},backend:e,attrs:{axis:i,keepDims:l}});return p.forEach(S=>e.disposeIntermediateTensorInfo(S)),v}const K6={kernelName:cp,backendName:"cpu",kernelFunc:X6};function Y6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s;It(o,"min");const u=qt(i,o.shape);let c=u;const h=Be(c,o.shape.length);let f=o;h!=null&&(f=Yn({inputs:{x:o},backend:e,attrs:{perm:h}}),c=qe(c.length,o.shape.length)),Sn("min",c,f.shape.length);const[p,g]=gn(f.shape,c),x=dt(g),b=Rn(dt(p),f.dtype),v=e.data.get(f.dataId).values;for(let C=0;C<b.length;++C){const $=C*x;let k=v[$];for(let T=0;T<x;++T){const N=v[$+T];(Number.isNaN(N)||N<k)&&(k=N)}b[C]=k}h!=null&&e.disposeIntermediateTensorInfo(f);const S=e.makeTensorInfo(p,f.dtype,b);if(l){const C=Qe(p,u),$=Ee({inputs:{x:S},backend:e,attrs:{shape:C}});return e.disposeIntermediateTensorInfo(S),$}return S}const Z6={kernelName:hp,backendName:"cpu",kernelFunc:Y6};function Q6(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{paddings:i,mode:l}=s;It(o,"mirrorPad");const u=i.map((k,T)=>k[0]+o.shape[T]+k[1]),c=i.map(k=>k[0]),h=i.map((k,T)=>k[0]+o.shape[T]),f=l==="reflect"?0:1,p=e.data.get(o.dataId).values,g=o.shape.length,x=Rt(o.shape),b=dt(u),v=u.length,S=Rt(u),C=En(o.dtype,b);for(let k=0;k<b;k++){let T=vl(k,v,S);for(let R=0;R<v;R++)T[R]<c[R]?T[R]=c[R]*2-T[R]-f:T[R]>=h[R]&&(T[R]=(h[R]-1)*2-T[R]+f);T=T.map((R,D)=>R-c[D]);const N=Io(T,g,x);C[k]=p[N]}return{dataId:e.write(C,u,o.dtype),shape:u,dtype:o.dtype}}const J6={kernelName:dp,backendName:"cpu",kernelFunc:Q6};const t5=Xe(((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t})),e5=cn(Ec,t5),n5={kernelName:Ec,backendName:"cpu",kernelFunc:e5};function KE(n){const{inputs:t,backend:e,attrs:s}=n,{logits:o}=t,{dim:i}=s,l=o.shape.length;let u=i;if(u===-1&&(u=l-1),u!==l-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${l} and dim was ${u}`);const c=qt([u],o.shape),h=XE({inputs:{x:o},backend:e,attrs:{reductionIndices:c,keepDims:!1}}),f=Qe(h.shape,c),p=Ee({inputs:{x:h},backend:e,attrs:{shape:f}}),g=n1({inputs:{a:o,b:p},backend:e}),x=JN({inputs:{x:g},backend:e}),b=dh({inputs:{x},backend:e,attrs:{axis:c,keepDims:!1}}),v=Ee({inputs:{x:b},backend:e,attrs:{shape:f}}),S=o1({inputs:{a:x,b:v},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(v),S}const s5={kernelName:Rp,backendName:"cpu",kernelFunc:KE};function o5(n){const{inputs:t,backend:e,attrs:s}=n,{logits:o}=t,{numSamples:i,seed:l,normalized:u}=s;It(o,"multinomial");const c=u?o:KE({inputs:{logits:o},backend:e,attrs:{dim:-1}}),h=c.shape[0],f=c.shape[1],p=e.data.get(c.dataId).values,g=[h,i],x=Rn(dt(g),"int32");for(let b=0;b<h;++b){const v=b*f,S=new Float32Array(f-1);S[0]=p[v];for(let k=1;k<S.length;++k)S[k]=S[k-1]+p[v+k];const C=jb.alea(l.toString()),$=b*i;for(let k=0;k<i;++k){const T=C();x[$+k]=S.length;for(let N=0;N<S.length;N++)if(T<S[N]){x[$+k]=N;break}}}return u||e.disposeIntermediateTensorInfo(c),e.makeTensorInfo(g,"int32",x)}const a5={kernelName:I$,backendName:"cpu",kernelFunc:o5};const i5=ny;function r5(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:o,scores:i}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=s;It(o,"NonMaxSuppression");const h=e.data.get(o.dataId).values,f=e.data.get(i.dataId).values,{selectedIndices:p}=i5(h,f,l,u,c);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}const l5={kernelName:pb,backendName:"cpu",kernelFunc:r5};const u5=sy;function c5(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:o,scores:i}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:c,padToMaxOutputSize:h}=s;It(o,"NonMaxSuppressionPadded");const f=e.data.get(o.dataId).values,p=e.data.get(i.dataId).values,{selectedIndices:g,validOutputs:x}=u5(f,p,l,u,c,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([],"int32",new Int32Array([x]))]}const h5={kernelName:mb,backendName:"cpu",kernelFunc:c5};const d5=oy;function f5(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:o,scores:i}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:c,softNmsSigma:h}=s;It(o,"NonMaxSuppressionWithScore");const f=e.data.get(o.dataId).values,p=e.data.get(i.dataId).values,g=l,x=u,b=c,v=h,{selectedIndices:S,selectedScores:C}=d5(f,p,g,x,b,v);return[e.makeTensorInfo([S.length],"int32",new Int32Array(S)),e.makeTensorInfo([C.length],"float32",new Float32Array(C))]}const p5={kernelName:gb,backendName:"cpu",kernelFunc:f5};function m5(n){const{inputs:t,backend:e,attrs:s}=n,{indices:o}=t,{dtype:i,depth:l,onValue:u,offValue:c}=s;It(o,"oneHot");const h=dt(o.shape),f=new Float32Array(h*l);f.fill(c);const p=e.data.get(o.dataId).values;for(let g=0;g<h;++g)p[g]>=0&&p[g]<l&&(f[g*l+p[g]]=u);return e.makeTensorInfo([...o.shape,l],i,f)}const g5={kernelName:gp,backendName:"cpu",kernelFunc:m5};function Ef(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const o=Ji({inputs:{input:s},backend:e}),i=Ef({inputs:{x:o},backend:e}),l=ml({inputs:{input:s},backend:e}),u=Ef({inputs:{x:l},backend:e}),c=rs({inputs:{real:i,imag:u},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),c}else return a1({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const x5={kernelName:Op,backendName:"cpu",kernelFunc:Ef};function YE(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const o=Ji({inputs:{input:s},backend:e}),i=YE({inputs:{x:o},backend:e}),l=ml({inputs:{input:s},backend:e}),u=Ef({inputs:{x:l},backend:e}),c=rs({inputs:{real:i,imag:u},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),c}else return a1({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const b5={kernelName:mp,backendName:"cpu",kernelFunc:YE};function ZE(n){const{inputs:t,backend:e,attrs:s}=n,{axis:o}=s;if(t.length===1)return Nf({inputs:{input:t[0]},backend:e,attrs:{dim:o}});const i=t[0].shape,l=t[0].dtype;t.forEach(f=>{z0(i,f.shape,"All tensors passed to stack must have matching shapes"),_(l===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],c=t.map(f=>{const p=Nf({inputs:{input:f},backend:e,attrs:{dim:o}});return u.push(p),p}),h=gl({inputs:c,backend:e,attrs:{axis:o}});return u.forEach(f=>e.disposeIntermediateTensorInfo(f)),h}const y5={kernelName:xp,backendName:"cpu",kernelFunc:ZE};function v5(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{paddings:i,constantValue:l}=s;It(o,"pad");const u=i.map(($,k)=>$[0]+o.shape[k]+$[1]),c=i.map($=>$[0]),h=e.data.get(o.dataId).values,f=dt(o.shape),p=o.shape.length,g=Rt(o.shape),x=dt(u),b=u.length,v=Rt(u),S=En(o.dtype,x);l!==0&&S.fill(l);for(let $=0;$<f;$++){const T=vl($,p,g).map((R,D)=>R+c[D]),N=Io(T,b,v);S[N]=h[$]}return{dataId:e.write(S,u,o.dtype),shape:u,dtype:o.dtype}}const QE={kernelName:bp,backendName:"cpu",kernelFunc:v5};const w5=Xe((n,t)=>Math.pow(n,t)),S5=cn(Ac,w5),C5={kernelName:Ac,backendName:"cpu",kernelFunc:S5};function $5(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:o,paramsDenseValues:i,indices:l}=t,{outputRaggedRank:u}=s,c=o.map(C=>e.data.get(C.dataId).values),h=o.map(C=>C.shape),f=e.data.get(i.dataId).values,p=e.data.get(l.dataId).values,[g,x,b]=xE(c,h,f,i.shape,i.dtype,p,l.shape),v=g.map(C=>e.makeTensorInfo([C.length],"int32",C)),S=e.makeTensorInfo(b,i.dtype,x);return v.concat([S])}const T5={kernelName:N$,backendName:"cpu",kernelFunc:$5};function k5(n){const{inputs:t,backend:e}=n,{starts:s,limits:o,deltas:i}=t,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values,[h,f]=bE(l,s.shape,s.dtype,u,o.shape,c,i.shape),p=e.makeTensorInfo([h.length],"int32",h),g=e.makeTensorInfo([f.length],s.dtype,f);return[p,g]}const I5={kernelName:E$,backendName:"cpu",kernelFunc:k5};function N5(n){const{inputs:t,backend:e,attrs:s}=n,{shape:o,values:i,defaultValue:l,rowPartitionTensors:u}=t,{rowPartitionTypes:c}=s,h=e.data.get(o.dataId).values,f=e.data.get(i.dataId).values,p=e.data.get(l.dataId).values,g=u.map(S=>e.data.get(S.dataId).values),x=u.map(S=>S.shape),[b,v]=yE(h,o.shape,f,i.shape,i.dtype,p,l.shape,g,x,c);return e.makeTensorInfo(b,i.dtype,v)}const E5={kernelName:R$,backendName:"cpu",kernelFunc:N5};function R5(n){const{backend:t,attrs:e}=n,{start:s,stop:o,dtype:i,step:l}=e,u=vE(s,o,l,i);return t.makeTensorInfo([u.length],i,u)}const A5={kernelName:xb,backendName:"cpu",kernelFunc:R5};const D5=ge(Dc,n=>1/n),O5={kernelName:Dc,backendName:"cpu",kernelFunc:D5};function _5(n){const{inputs:t,backend:e,attrs:s}=n,{images:o}=t,{alignCorners:i,halfPixelCenters:l,size:u}=s;It(o,"resizeBilinear");const c=Rt(o.shape),[h,f]=u,[p,g,x,b]=o.shape,v=e.data.get(o.dataId).values,S=new Float32Array(dt([p,h,f,b])),C=[i&&h>1?g-1:g,i&&f>1?x-1:x],$=[i&&h>1?h-1:h,i&&f>1?f-1:f];let k=0;const T=C[0]/$[0],N=C[1]/$[1];for(let R=0;R<p;R++)for(let D=0;D<h;D++){let z;l?z=T*(D+.5)-.5:z=T*D;const O=Math.max(0,Math.floor(z)),F=z-O,E=Math.min(g-1,Math.ceil(z)),U=R*c[0]+O*c[1],Y=R*c[0]+E*c[1];for(let X=0;X<f;X++){let q;l?q=N*(X+.5)-.5:q=N*X;const L=Math.max(0,Math.floor(q)),P=q-L,W=Math.min(x-1,Math.ceil(q)),nt=U+L*c[2],it=Y+L*c[2],M=U+W*c[2],G=Y+W*c[2];for(let Q=0;Q<b;Q++){const ut=v[nt+Q],ft=v[it+Q],gt=v[M+Q],yt=v[G+Q],Tt=ut+(gt-ut)*P,St=ft+(yt-ft)*P,zt=Tt+(St-Tt)*F;S[k++]=zt}}}return e.makeTensorInfo([p,h,f,b],"float32",S)}const F5={kernelName:Cp,backendName:"cpu",kernelFunc:_5};function M5(n){const{inputs:t,backend:e,attrs:s}=n,{images:o,dy:i}=t,{alignCorners:l}=s;It([i,o],"resizeBilinearGrad");const u=Rt(o.shape),[c,h,f,p]=o.shape,[,g,x]=i.shape,b=new Float32Array(c*h*f*p),v=[l&&g>1?h-1:h,l&&x>1?f-1:f],S=[l&&g>1?g-1:g,l&&x>1?x-1:x],C=v[0]/S[0],$=v[1]/S[1],k=e.data.get(i.dataId).values;let T=0;for(let N=0;N<c;N++){const R=N*u[0];for(let D=0;D<g;D++){const z=D*C,O=Math.floor(z),F=Math.min(Math.ceil(z),h-1),E=R+O*u[1],U=R+F*u[1],Y=z-O,X=1-Y;for(let q=0;q<x;q++){const L=q*$,P=Math.floor(L),W=Math.min(Math.ceil(L),f-1),nt=L-P,it=1-nt,M=E+P*u[2],G=E+W*u[2],Q=U+P*u[2],ut=U+W*u[2],ft=X*it,gt=X*nt,yt=Y*it,Tt=Y*nt;for(let St=0;St<p;St++){const zt=k[T++];b[M+St]+=zt*ft,b[G+St]+=zt*gt,b[Q+St]+=zt*yt,b[ut+St]+=zt*Tt}}}}return e.makeTensorInfo([c,f,h,p],"float32",b)}const z5={kernelName:vb,backendName:"cpu",kernelFunc:M5};function L5(n){const{inputs:t,backend:e,attrs:s}=n,{images:o}=t,{alignCorners:i,halfPixelCenters:l,size:u}=s;It(o,"resizeNearestNeighbor");const c=Rt(o.shape),[h,f]=u,[p,g,x,b]=o.shape,v=e.data.get(o.dataId).values,S=new Float32Array(p*h*f*b),C=[i&&h>1?g-1:g,i&&f>1?x-1:x],$=[i&&h>1?h-1:h,i&&f>1?f-1:f],k=C[0]/$[0],T=C[1]/$[1];let N=0;for(let R=0;R<p;R++){const D=R*c[0];for(let z=0;z<h;z++){const O=l?k*(z+.5):k*z;let F=Math.min(g-1,i?Math.round(O):Math.floor(O));l&&(F=Math.max(0,F));const E=D+F*c[1];for(let U=0;U<f;U++){const Y=l?T*(U+.5):T*U;let X=Math.min(x-1,i?Math.round(Y):Math.floor(Y));l&&(X=Math.max(0,X));const q=E+X*c[2];for(let L=0;L<b;L++){const P=v[q+L];S[N++]=P}}}}return e.makeTensorInfo([p,h,f,b],o.dtype,S)}const B5={kernelName:Sp,backendName:"cpu",kernelFunc:L5};function U5(n){const{inputs:t,backend:e,attrs:s}=n,{images:o,dy:i}=t,{alignCorners:l}=s;It([i,o],"resizeNearestNeighborGrad");const u=Rt(o.shape),c=Rt(i.shape),[h,f,p,g]=o.shape,[,x,b]=i.shape,v=new Float32Array(h*f*p*g),S=e.data.get(i.dataId).values,C=[l&&x>1?f-1:f,l&&b>1?p-1:p],$=[l&&x>1?x-1:x,l&&b>1?b-1:b],k=C[0]/$[0],T=C[1]/$[1],N=1/k,R=1/T,D=Math.ceil(N)*2+2,z=Math.ceil(R)*2+2;for(let O=0;O<h;O++){const F=O*u[0];for(let E=0;E<f;E++){const U=F+E*u[1],Y=Math.floor(E*N),X=Math.floor(Y-D/2);for(let q=0;q<p;q++){const L=U+q*u[2],P=Math.floor(q*R),W=Math.floor(P-z/2);for(let nt=0;nt<g;nt++){let it=0;for(let M=0;M<D;M++){const G=M+X;if(G<0||G>=x)continue;const Q=F+G*c[1],ut=G*k,ft=Math.min(f-1,l?Math.round(ut):Math.floor(ut));if(E===ft)for(let gt=0;gt<z;gt++){const yt=gt+W;if(yt<0||yt>=b)continue;const Tt=Q+yt*c[2],St=yt*T,zt=Math.min(p-1,l?Math.round(St):Math.floor(St));q===zt&&(it+=S[Tt+nt])}}v[L+nt]=it}}}}return e.makeTensorInfo(o.shape,o.dtype,v)}const V5={kernelName:yb,backendName:"cpu",kernelFunc:U5};function P5(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{dims:i}=s;It(o,"reverse");const l=o.shape.length,u=qt(i,o.shape);if(l===0)return zo({inputs:{x:o},backend:e});const c=new vn(o.shape,o.dtype),h=e.bufferSync(o);for(let f=0;f<c.size;f++){const p=c.indexToLoc(f),g=p.slice();u.forEach(x=>g[x]=o.shape[x]-1-g[x]),c.set(h.get(...g),...p)}return e.makeTensorInfo(c.shape,c.dtype,c.values)}const G5={kernelName:$p,backendName:"cpu",kernelFunc:P5};const W5={kernelName:Ib,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:o,fillValue:i,center:l}=t,u=e,c=En(s.dtype,dt(s.shape)),[h,f,p,g]=s.shape,[x,b]=dy(l,f,p),v=255,S=Math.sin(o),C=Math.cos(o),$=u.data.get(s.dataId).values;for(let T=0;T<h;T++){const N=T*p*f*g;for(let R=0;R<f;R++){const D=R*(p*g);for(let z=0;z<p;z++){const O=z*g;for(let F=0;F<g;F++){const E=[h,R,z,F],U=E[2],Y=E[1];let X=(U-x)*C-(Y-b)*S,q=(U-x)*S+(Y-b)*C;X=Math.round(X+x),q=Math.round(q+b);let L=i;if(typeof i!="number"&&(F===3?L=v:L=i[F]),X>=0&&X<p&&q>=0&&q<f){const W=q*(p*g),nt=X*g,it=N+W+nt+F;L=$[it]}const P=N+D+O+F;c[P]=L}}}}return{dataId:u.write(c,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const H5=ge(Fc,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),q5={kernelName:Fc,backendName:"cpu",kernelFunc:H5};function j5(n){const{inputs:t,backend:e,attrs:s}=n,{indices:o,updates:i}=t,{shape:l}=s,{sliceRank:u,numUpdates:c,sliceSize:h,strides:f,outputSize:p}=ar(i,o,l),g=!0,x=e.bufferSync(o),b=e.bufferSync(i),v=Li(x,b,l,p,h,c,u,f,0,g);return e.makeTensorInfo(l,v.dtype,v.values)}const X5={kernelName:A$,backendName:"cpu",kernelFunc:j5};function K5(n,t){let e=0,s=n.length,o=0;for(;e<s;)o=Math.floor((e+s)/2),n[o]<t?e=o+1:s=o;return s}function Y5(n,t){let e=0,s=n.length,o=0;for(;e<s;)o=Math.floor((e+s)/2),n[o]<=t?e=o+1:s=o;return s}function Z5(n,t,e,s,o,i){const l=Ge("int32",e*o);for(let u=0;u<e;++u){const c=n.slice(u*s,(u+1)*s),h=u*o;for(let f=0;f<o;++f)l[h+f]=i==="left"?K5(c,t[f+h]):Y5(c,t[f+h])}return l}function Q5(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:o,values:i}=t,{side:l}=s,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values,h=Z5(u,c,o.shape[0],o.shape[1],i.shape[1],l);return e.makeTensorInfo(i.shape,"int32",h)}const J5={kernelName:O$,backendName:"cpu",kernelFunc:Q5};function tq(n){const{inputs:t,backend:e}=n,{condition:s,t:o,e:i}=t;It([s,o,i],"select");const l=s.shape.length,u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,h=e.data.get(i.dataId).values,f=us(o.dtype,i.dtype),p=Rn(dt(o.shape),f);let g=0;const x=l===0||l>1||o.shape.length===1?1:dt(o.shape.slice(1));for(let b=0;b<u.length;b++)for(let v=0;v<x;v++)u[b]===1?p[g++]=c[b]:p[g++]=h[b];return e.makeTensorInfo(o.shape,f,p)}const eq={kernelName:Tp,backendName:"cpu",kernelFunc:tq};const nq=Wp,sq=Hp,oq=ge(zc,n=>n>=0?sq*n:nq*(Math.exp(n)-1)),aq={kernelName:zc,backendName:"cpu",kernelFunc:oq};const iq=ge(Uc,n=>n<0?-1:n>0?1:0),rq={kernelName:Uc,backendName:"cpu",kernelFunc:iq};const lq=ge(Lc,n=>Math.sin(n)),uq={kernelName:Lc,backendName:"cpu",kernelFunc:lq};const cq=ge(Bc,n=>Math.sinh(n)),hq={kernelName:Bc,backendName:"cpu",kernelFunc:cq};const dq=11920928955078125e-23,L2=Math.log(dq)+2,fq=ge(Pc,n=>{const t=n>-L2,e=n<L2,s=Math.exp(n);let o;return e?o=s:t?o=n:o=Math.log(1+s),o}),pq={kernelName:Pc,backendName:"cpu",kernelFunc:fq};function mq(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{blockShape:i,paddings:l}=s;It([o],"spaceToBatchND");const u=dt(i),c=[[0,0]];c.push(...l);for(let R=1+i.length;R<o.shape.length;++R)c.push([0,0]);const h=QE.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:c,constantValue:0}}),f=eh(h.shape,i,u,!1),p=nh(f.length,i.length,!1),g=sh(h.shape,i,u,!1),v=Ee({inputs:{x:h},backend:e,attrs:{shape:f}}),$=Yn({inputs:{x:v},backend:e,attrs:{perm:p}}),N=Ee({inputs:{x:$},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo($),N}const gq={kernelName:Np,backendName:"cpu",kernelFunc:mq};function xq(n){const{inputs:t,backend:e}=n,{indices:s,values:o,denseShape:i,defaultValue:l}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(l.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${l.shape}`);const u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,h=e.data.get(i.dataId).values,f=e.data.get(l.dataId).values[0],[p,g,x,b,v]=$E(u,s.shape,s.dtype,c,o.dtype,h,f);return[e.makeTensorInfo(g,s.dtype,p),e.makeTensorInfo([g[0]],o.dtype,x),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(S=>Number(S)))),e.makeTensorInfo([v.length],s.dtype,new Int32Array(v))]}const bq={kernelName:_$,backendName:"cpu",kernelFunc:xq};function yq(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:o,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const l=Array.from(e.data.get(o.dataId).values),u=e.data.get(s.dataId).values,c=Array.from(e.data.get(i.dataId).values),[h,f,p]=TE(u,s.shape,s.dtype,l,c);return[e.makeTensorInfo(f,s.dtype,h),e.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const vq={kernelName:F$,backendName:"cpu",kernelFunc:yq};function wq(n){const{inputs:t,backend:e}=n,{data:s,indices:o,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(o.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values,[h,f]=e1(l,s.shape,s.dtype,u,c,!0);return e.makeTensorInfo(f,s.dtype,h)}const Sq={kernelName:M$,backendName:"cpu",kernelFunc:wq};function Cq(n){const{inputs:t,backend:e}=n,{data:s,indices:o,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(o.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,c=e.data.get(i.dataId).values,[h,f]=e1(l,s.shape,s.dtype,u,c);return e.makeTensorInfo(f,s.dtype,h)}const $q={kernelName:z$,backendName:"cpu",kernelFunc:Cq};function Tq(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:o,sparseValues:i,defaultValue:l}=t,{outputShape:u}=s,{sliceRank:c,numUpdates:h,sliceSize:f,strides:p,outputSize:g}=ar(i,o,u),x=!1,b=e.bufferSync(o);let v;switch(i.dtype){case"bool":{const S=e.bufferSync(i),C=!!e.data.get(l.dataId).values[0];v=Li(b,S,u,g,f,h,c,p,C,x);break}case"float32":{const S=e.bufferSync(i),C=e.data.get(l.dataId).values[0];v=Li(b,S,u,g,f,h,c,p,C,x);break}case"int32":{const S=e.bufferSync(i),C=e.data.get(l.dataId).values[0];v=Li(b,S,u,g,f,h,c,p,C,x);break}case"string":{const S=e.bufferSync(i),C=Ka(e.data.get(l.dataId).values[0]);v=Li(b,S,u,g,f,h,c,p,C,x);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(u,v.dtype,v.values)}const kq={kernelName:L$,backendName:"cpu",kernelFunc:Tq};function Iq(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{numOrSizeSplits:i,axis:l}=s,u=qt(l,o.shape)[0],c=Iy(o,i,u),h=new Array(o.shape.length).fill(0),f=o.shape.slice();return c.map(p=>{const g=[...f];g[u]=p;const x=tr({inputs:{x:o},backend:e,attrs:{begin:h,size:g}});return h[u]+=p,x})}const Nq={kernelName:Ep,backendName:"cpu",kernelFunc:Iq};const Eq={kernelName:wb,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;It(e,"square");const o=s.data.get(e.dataId).values,i=new Float32Array(o.length);for(let u=0;u<o.length;++u){const c=o[u];i[u]=c*c}return{dataId:s.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};const Rq=ge(Kc,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Aq={kernelName:Kc,backendName:"cpu",kernelFunc:Rq};function Dq(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{begin:i,end:l,strides:u,beginMask:c,endMask:h,ellipsisMask:f,newAxisMask:p,shrinkAxisMask:g}=s;It(o,"stridedSlice");const{finalShapeSparse:x,finalShape:b,isIdentity:v,sliceDim0:S,isSimpleSlice:C,begin:$,end:k,strides:T}=nk(o.shape,i,l,u,c,h,f,p,g);let N;if(v)N=Ee({inputs:{x:o},backend:e,attrs:{shape:b}});else if(S||C){_(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);const R=JT($,k,T),D=tr({inputs:{x:o},backend:e,attrs:{begin:$,size:R}});N=Ee({inputs:{x:D},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(D)}else{const R=e.bufferSync(o),D=NE(x,R,T,$);N=e.makeTensorInfo(b,D.dtype,D.values)}return N}const Oq={kernelName:Cb,backendName:"cpu",kernelFunc:Dq};function _q(n){const{inputs:t,backend:e,attrs:s}=n,{separator:o,nGramWidths:i,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:h}=s,{data:f,dataSplits:p}=t,g=e.data.get(f.dataId).values,x=e.data.get(p.dataId).values,[b,v]=EE(g,x,o,i,l,u,c,h);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",v)]}const Fq={kernelName:B$,backendName:"cpu",kernelFunc:_q};function Mq(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:o}=s,{input:i,delimiter:l}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(l.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${l.shape}`);const u=e.data.get(i.dataId).values,c=e.data.get(l.dataId).values[0],[h,f,p]=RE(u,c,o),g=f.length;return[e.makeTensorInfo([g,2],"int32",h),e.makeTensorInfo([g],"string",f),e.makeTensorInfo([2],"int32",new Int32Array(p))]}const zq={kernelName:U$,backendName:"cpu",kernelFunc:Mq};function Lq(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:o}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");const l=e.data.get(i.dataId).values,u=AE(l,o);return e.makeTensorInfo(i.shape,"int32",u)}const Bq={kernelName:V$,backendName:"cpu",kernelFunc:Lq};const Uq=ge(qc,n=>Math.tan(n)),Vq={kernelName:qc,backendName:"cpu",kernelFunc:Uq};const Pq=ge(jc,n=>Math.tanh(n)),Gq={kernelName:jc,backendName:"cpu",kernelFunc:Pq};function Wq(n){const{inputs:t,backend:e}=n,{tensor:s,indices:o,updates:i}=t,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:f}=ar(i,o,s.shape),p=!1,g=e.bufferSync(o),x=e.bufferSync(i),b=e.bufferSync(s),v=Li(g,x,s.shape,f,c,u,l,h,b,p);return e.makeTensorInfo(s.shape,v.dtype,v.values)}const Hq={kernelName:D$,backendName:"cpu",kernelFunc:Wq};function qq(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{reps:i}=s;It(o,"tile");const l=OE(e.bufferSync(o),i);return e.makeTensorInfo(l.shape,l.dtype,l.values)}const jq={kernelName:Xc,backendName:"cpu",kernelFunc:qq};function Xq(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{k:i,sorted:l}=s;It(o,"topk");const u=e.data.get(o.dataId).values,[c,h]=FE(u,o.shape,o.dtype,i,l);return[e.makeTensorInfo(c.shape,c.dtype,c.values),e.makeTensorInfo(h.shape,h.dtype,h.values)]}const Kq={kernelName:$b,backendName:"cpu",kernelFunc:Xq};function Yq(n){const{inputs:t,attrs:e,backend:s}=n,{image:o,transforms:i}=t,{interpolation:l,fillMode:u,fillValue:c,outputShape:h}=e,[f,p,g,x]=o.shape,[b,v]=h??[p,g],S=[f,b,v,x],C=Rt(o.shape),$=C[0],k=C[1],T=C[2],N=Rt(S),R=N[0],D=N[1],z=N[2],O=En(o.dtype,dt(S));O.fill(c);const F=s.data.get(o.dataId).values,E=s.data.get(i.dataId).values;for(let Y=0;Y<f;++Y){const X=i.shape[0]===1?E:E.subarray(Y*8,Y*8+8);for(let q=0;q<b;++q)for(let L=0;L<v;++L)for(let P=0;P<x;++P){let W;const nt=X[6]*L+X[7]*q+1;if(nt===0)continue;const it=(X[0]*L+X[1]*q+X[2])/nt,M=(X[3]*L+X[4]*q+X[5])/nt,G=B2(it,g,u),Q=B2(M,p,u);switch(l){case"nearest":W=n8(F,p,g,$,k,T,Y,Q,G,P,c);break;case"bilinear":W=s8(F,p,g,$,k,T,Y,Q,G,P,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${l}`)}const ut=Y*R+q*D+L*z+P;O[ut]=W}return s.makeTensorInfo(S,o.dtype,O)}return{dataId:s.write(O,S,o.dtype),shape:o.shape,dtype:o.dtype}}const Zq={kernelName:Tb,backendName:"cpu",kernelFunc:Yq};function B2(n,t,e){switch(e){case"reflect":return Qq(n,t);case"wrap":return Jq(n,t);case"nearest":return e8(n,t);default:return t8(n)}}function Qq(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return F0(0,e,t-1)}function Jq(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=t-1;e+=t*(Math.trunc(-e/s)+1)}else if(e>t-1)if(t<=1)e=0;else{const s=t-1;e-=t*Math.trunc(e/s)}return F0(0,e,t-1)}function t8(n,t){return n}function e8(n,t){return F0(0,n,t-1)}function zu(n,t,e,s,o,i,l,u,c,h,f){const p=l*s+u*o+c*i+h;return 0<=u&&u<t&&0<=c&&c<e?n[p]:f}function n8(n,t,e,s,o,i,l,u,c,h,f){const p=Math.round(u),g=Math.round(c);return zu(n,t,e,s,o,i,l,p,g,h,f)}function s8(n,t,e,s,o,i,l,u,c,h,f){const p=Math.floor(u),g=Math.floor(c),x=p+1,b=g+1,v=(b-c)*zu(n,t,e,s,o,i,l,p,g,h,f)+(c-g)*zu(n,t,e,s,o,i,l,p,b,h,f),S=(b-c)*zu(n,t,e,s,o,i,l,x,g,h,f)+(c-g)*zu(n,t,e,s,o,i,l,x,b,h,f);return(x-u)*v+(u-p)*S}function o8(n){const{inputs:t,attrs:e,backend:s}=n,{axis:o}=e,{x:i}=t;It(i,"unique");const l=s.data.get(i.dataId).values,{outputValues:u,outputShape:c,indices:h}=ME(l,o,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,u),s.makeTensorInfo([h.length],"int32",h)]}const a8={kernelName:kb,backendName:"cpu",kernelFunc:o8};function i8(n){const{inputs:t,backend:e,attrs:s}=n,{value:o}=t;let{axis:i}=s;i<0&&(i+=o.shape.length);const l=o.shape.length,u=o.shape[i],c=new Array(l-1);let h=0;for(let x=0;x<l;x++)x!==i&&(c[h++]=o.shape[x]);const f=new Array(l).fill(0),p=o.shape.slice();p[i]=1;const g=new Array(u);for(let x=0;x<g.length;x++){f[i]=x;const b=tr({inputs:{x:o},backend:e,attrs:{begin:f,size:p}});g[x]=Ee({inputs:{x:b},backend:e,attrs:{shape:c}}),e.disposeIntermediateTensorInfo(b)}return g}const r8={kernelName:Ap,backendName:"cpu",kernelFunc:i8};function l8(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,segmentIds:i}=t,{numSegments:l}=s;It(o,"unsortedSegmentSum");const u=o.shape.length,c=i.shape.length,h=[],f=[],p=u-c;let g=i;for(let b=0;b<p;++b){const v=Nf({inputs:{input:g},backend:e,attrs:{dim:b+1}});g=v,f.push(v)}for(let b=0;b<l;++b){const v=ni(b,"int32"),S=e.makeTensorInfo([],"int32",v),C=ZN({inputs:{a:S,b:g},backend:e}),$=ti({inputs:{x:C},backend:e,attrs:{dtype:"float32"}}),k=sm({inputs:{a:$,b:o},backend:e}),T=dh({inputs:{x:k},backend:e,attrs:{axis:0,keepDims:!1}});h.push(T),f.push(S),f.push(C),f.push($),f.push(k),f.push(T)}const x=ZE({inputs:h,backend:e,attrs:{axis:0}});return f.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}const u8={kernelName:Dp,backendName:"cpu",kernelFunc:l8};const c8=[oW,LP,iW,lW,WP,cW,dW,pW,gW,bW,vW,SW,$W,IW,EW,DW,_W,MW,LW,nW,UW,PW,WW,qP,qW,PP,XP,XW,BP,YW,QW,JW,eH,sH,aH,rH,uH,hH,fH,mH,xH,yH,wH,CH,$H,kH,NH,RH,AH,DH,OH,FH,LH,KG,UH,KP,XH,YP,KH,QP,e6,n6,o6,tG,nG,i6,l6,c6,d6,oG,iG,UP,p6,ZW,g6,b6,v6,YG,lG,cG,S6,dG,$6,I6,E6,D6,_6,M6,z6,pG,B6,V6,G6,H6,j6,K6,Z6,gG,J6,n5,a5,bG,vG,l5,h5,p5,SG,g5,b5,y5,QE,C5,QG,TG,T5,I5,E5,A5,VP,I0,O5,JG,tW,eW,F5,z5,B5,V5,G5,W5,q5,OG,X5,J5,eq,aq,FG,rq,uq,hq,MG,s5,pq,gq,bq,vq,Sq,$q,kq,Nq,BG,Eq,VG,GG,Aq,Oq,Fq,zq,Bq,jG,MH,Vq,Gq,Hq,jq,Kq,Zq,CG,a8,r8,u8,x5];for(const n of c8)G$(n);const Mi={},Bd={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function h8(n,t){Mi[n]=t}function fo(n,t){if(!(n in Mi)||t!=null){const s=f8(n,t);if(s!==null)Mi[n]=s;else return console.log("Could not get context for WebGL version",n),null}const e=Mi[n];return e==null||e.isContextLost()?(delete Mi[n],fo(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Mi[n])}function d8(n){if(!lt().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function f8(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??d8(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Mi[n]},!1),lt().getBool("SOFTWARE_WEBGL_ENABLED")&&(Bd.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",Bd)||e.getContext("experimental-webgl",Bd):e.getContext("webgl2",Bd)}var Yu;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Yu||(Yu={}));var Cs;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Cs||(Cs={}));var yn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(yn||(yn={}));function fh(n,t){return[t,n]}function p8(n,t){return n*t}function Ud(n){const t=dt(n),e=Math.ceil(t/4);return Zx(e)}function Il(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function m8(n,t){const[e,s]=Il(n,t);return e*s*4}function i1(n,t){const e=n;let s,o,i,l,u,c,h,f,p,g;return lt().getNumber("WEBGL_VERSION")===2?(s=e.R32F,o=e.R16F,i=e.RGBA16F,l=e.RGBA32F,u=e.RED,h=4,f=1,p=e.HALF_FLOAT,g=e.FLOAT,c=e.RGBA8):(s=n.RGBA,o=n.RGBA,i=n.RGBA,l=e.RGBA,u=n.RGBA,h=4,f=4,p=t!=null?t.HALF_FLOAT_OES:null,g=n.FLOAT,c=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:l,textureFormatFloat:u,downloadTextureFormat:c,downloadUnpackNumChannels:h,defaultNumChannels:f,textureTypeHalfFloat:p,textureTypeFloat:g}}function Ct(n,t){const e=t();return lt().getBool("DEBUG")&&g8(n),e}function g8(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+v8(n,t))}const x8=596e-10,b8=65504;function y8(n){return!!(lt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||x8<Math.abs(n)&&Math.abs(n)<b8)}function v8(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Vd(n,t){return ma(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function w8(n,t){const e=ma(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ct(n,()=>n.shaderSource(e,t)),Ct(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function S8(n,t){const e=ma(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ct(n,()=>n.shaderSource(e,t)),Ct(n,()=>n.compileShader(e)),lt().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw JE(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const C8=/ERROR: [0-9]+:([0-9]+):/g;function JE(n,t){const e=C8.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}const s=+e[1],o=n.split(`
`),i=o.length.toString().length+2,l=o.map((p,g)=>nl((g+1).toString(),i)+p);let u=0;for(let p=0;p<l.length;p++)u=Math.max(l[p].length,u);const c=l.slice(0,s-1),h=l.slice(s-1,s),f=l.slice(s);console.log(c.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${nl(h[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(f.join(`
`))}function $8(n){return ma(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function T8(n,t){if(Ct(n,()=>n.linkProgram(t)),!lt().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Gx(n,t){if(Ct(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function k8(n,t){const e=ma(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ct(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),Ct(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function I8(n,t){const e=ma(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ct(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),Ct(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function N8(n){return ma(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function E8(n,t){const e=lt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){const s=`[${n}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>e||t>e){const s=`[${n}x${t}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+o+".")}}function R8(n){return ma(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function U2(n,t,e,s,o,i,l){const u=n.getAttribLocation(t,e);return u===-1?!1:(Ct(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Ct(n,()=>n.vertexAttribPointer(u,o,n.FLOAT,!1,i,l)),Ct(n,()=>n.enableVertexAttribArray(u)),!0)}function A8(n,t,e){M8(n,e),Ct(n,()=>n.activeTexture(n.TEXTURE0+e)),Ct(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function D8(n,t,e){return ma(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function O8(n,t,e){return n.getUniformLocation(t,e)}function _8(n,t,e,s){Ct(n,()=>A8(n,t,s)),Ct(n,()=>n.uniform1i(e,s))}function Wx(n,t,e){Ct(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Ct(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function V2(n,t){Ct(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Ct(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Pd(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+F8(n,t))}function F8(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function ma(n,t,e){const s=Ct(n,()=>t());if(s==null)throw new Error(e);return s}function M8(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e){const o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function xl(n,t=2){return dt(n.slice(0,n.length-t))}function bl(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Gd(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[xl(n),...bl(n)]),t}function z8(n,t=!1){let e=lt().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=lt().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&lt().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e=e*2,s=s*2,n=n.map((u,c)=>c>=n.length-2?M0(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=ei(n).newShape);let o=dt(n),i=null;n.length<=1&&o<=e?i=[1,o]:n.length===2&&n[0]<=e&&n[1]<=e?i=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const l=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(i==null||l)if(t){const u=xl(n);let c=2,h=2;n.length&&([c,h]=bl(n)),o=u*(c/2)*(h/2),i=Zx(o).map(f=>f*2)}else i=Zx(o);return i}function Wd(n){return n%2===0}function Rf(n,t){if(n=n.slice(-2),t=t.slice(-2),ce(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||Wd(e)&&Wd(s)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&Wd(n[0])&&Wd(t[0])}let Hx,qx;function L8(n){if(Hx==null){const t=fo(n);Hx=t.getParameter(t.MAX_TEXTURE_SIZE)}return Hx}function B8(n){if(qx==null){const t=fo(n);qx=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qx)}function U8(n){if(n===0)return 0;let t;const e=fo(n);return Ws(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:Ws(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Ws(n,t){return n.getExtension(t)!=null}function P2(n){try{if(fo(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function V8(n){if(n===0)return!1;const t=fo(n);if(n===1){if(!Ws(t,"OES_texture_float"))return!1}else if(!Ws(t,"EXT_color_buffer_float"))return!1;return E0(t)}function P8(n){if(n===0)return!1;const t=fo(n);if(n===1){if(!Ws(t,"OES_texture_float")||!Ws(t,"WEBGL_color_buffer_float"))return!1}else{if(Ws(t,"EXT_color_buffer_float"))return E0(t);const s="EXT_color_buffer_half_float";if(Ws(t,s)){const o=t.getExtension(s);return G8(t,o)}return!1}return E0(t)}function E0(n){const t=i1(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),l}function G8(n,t){const e=i1(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const l=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,l),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const u=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(l),u}function W8(n){return n!==2?!1:fo(n).fenceSync!=null}function ph(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&_(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Nt=lt();Nt.registerFlag("HAS_WEBGL",()=>Nt.getNumber("WEBGL_VERSION")>0);Nt.registerFlag("WEBGL_VERSION",()=>P2(2)?2:P2(1)?1:0);Nt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Nt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Nt.get("WEBGL_VERSION")===2);Nt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Nt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Nt.registerFlag("WEBGL_PACK",()=>Nt.getBool("HAS_WEBGL"));Nt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_PACK_CLIP",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_PACK_REDUCE",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_CONV_IM2COL",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Nt.getBool("WEBGL_PACK"));Nt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>L8(Nt.getNumber("WEBGL_VERSION")));Nt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>B8(Nt.getNumber("WEBGL_VERSION")));Nt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Nt.getNumber("WEBGL_VERSION");return n===0?0:U8(n)});Nt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Nt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!nT());Nt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>V8(Nt.getNumber("WEBGL_VERSION")));Nt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Nt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Nt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Nt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>P8(Nt.getNumber("WEBGL_VERSION")));Nt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>W8(Nt.getNumber("WEBGL_VERSION")));Nt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Nt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Nt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Nt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>nT()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Nt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Nt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Nt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Nt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Nt.registerFlag("WEBGL_EXP_CONV",()=>!1);Nt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Nt.getBool("IS_TEST"));Nt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Nt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Nt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Nt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Vn(){let n,t,e,s,o,i,l,u,c,h;return lt().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",s="in",o="texture",i="outputColor",l="out vec4 outputColor;",u=lt().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",s="varying",o="texture2D",i="gl_FragColor",l="",u=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:o,output:i,defineOutput:l,defineSpecialNaN:u,defineSpecialInf:c,defineRound:h}}function lr(n,t,e="index"){const s=Rt(t);return s.map((o,i)=>{const l=`int ${n[i]} = ${e} / ${o}`,u=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${o}`:`index -= ${n[i]} * ${o}`;return`${l}; ${u};`}).join("")}function om(n,t,e="index"){const s=Rt(t);return s.map((o,i)=>{const l=`int ${n[i]} = ${e} / outShapeStrides[${i}]`,u=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${l}; ${u};`}).join("")}function H8(n,t){const e=n.length,s=n.map(i=>`${t}[${i}]`),o=new Array(e-1);o[e-2]=s[e-1];for(let i=e-3;i>=0;--i)o[i]=`(${o[i+1]} * ${s[i+1]})`;return o}function q8(n,t,e="index"){const s=n.map((i,l)=>l),o=H8(s,t);return o.map((i,l)=>{const u=`int ${n[l]} = ${e} / ${o[l]}`,c=l===o.length-1?`int ${n[l+1]} = ${e} - ${n[l]} * ${o[l]}`:`index -= ${n[l]} * ${o[l]}`;return`${u}; ${c};`}).join("")}function r1(n){const t=Rt(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function l1(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const tR=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:eR}=O4;function j8(n,t,e){const s=[];if(n.forEach(x=>{const b=dt(x.shapeInfo.logicalShape);if(x.shapeInfo.isUniform?s.push(`uniform float ${x.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${x.name};`),s.push(`uniform int offset${x.name};`)),e.enableShapeUniforms){const{uniformShape:v}=u1(e.packedInputs,x.shapeInfo.logicalShape,x.shapeInfo.texShape);switch(v.length){case 1:s.push(`uniform int ${x.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${x.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${x.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${x.name}Shape;`);break}s.push(`uniform ivec2 ${x.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(x=>{s.push(`uniform ${x.type} ${x.name}${x.arrayIndex?`[${x.arrayIndex}]`:""};`)});const o=s.join(`
`),i=n.map(x=>X8(x,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),l=t.texShape,u=Vn(),c=Z8(u);let h,f,p=tj(u);return t.isPacked?(h=K8(t.logicalShape,l,e.enableShapeUniforms),f=J8(u)):(h=Y8(t.logicalShape,l,e.enableShapeUniforms),f=Q8(u)),e.packedInputs&&(p+=oj),[p,c,f,o,h,i,e.userCode].join(`
`)}function Nl(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return gj(n,t);case 1:return bj(n,t);case 2:return vj(n,t);case 3:return Sj(n,t);case 4:return $j(n,t);case 5:return Tj(n);case 6:return kj(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function nR(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return mj(n);case 1:return xj(n,t);case 2:return yj(n,t);case 3:return wj(n,t);default:return Cj(n,t)}}function X8(n,t,e=!1,s){let o="";e?o+=nR(n,s):o+=Nl(n,s);const i=n.shapeInfo.logicalShape,l=t.logicalShape;return i.length<=l.length&&(e?o+=Ij(n,t):o+=Nj(n,t)),o}function K8(n,t,e){switch(n.length){case 0:return sR();case 1:return aj(n,t,e);case 2:return fj(n,t,e);case 3:return rj(n,t,e);default:return uj(n,t,e)}}function Y8(n,t,e){switch(n.length){case 0:return sR();case 1:return ij(n,t,e);case 2:return pj(n,t,e);case 3:return lj(n,t,e);case 4:return cj(n,t,e);case 5:return hj(n,t);case 6:return dj(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Z8(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Q8(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function J8(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function tj(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${ej}
    ${nj}
    ${sj}
  `}const ej=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,nj=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,sj=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,oj=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function sR(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function aj(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function ij(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function rj(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(n[2]/2),i=o*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function lj(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${om(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=lr(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function uj(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(n[n.length-1]/2),i=o*Math.ceil(n[n.length-2]/2);let l=i,u="",c="b, r, c";for(let h=2;h<n.length-1;h++)l*=n[n.length-h-1],u=`
      int b${h} = index / ${l};
      index -= b${h} * ${l};
    `+u,c=`b${h}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${u}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${n.length}(${c});
    }
  `}function cj(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${om(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=lr(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function hj(n,t){const e=lr(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function dj(n,t){const e=lr(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function fj(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(ce(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const o=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function pj(n,t,e){return ce(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function ur(n){return`offset${n}`}function mj(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=Vn();return`
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function gj(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[o,i]=n.shapeInfo.texShape;if(o===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const l=ur(e);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${l});
      return sampleTexture(${e}, uv);
    }
  `;const[u,c]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${u}, ${c}, ${l});
      return sampleTexture(${e}, uv);
    }
  `}function xj(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),o=n.shapeInfo.texShape,i=Vn();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${e}, uv);
    }
  `;const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${l[0]}, ${l[1]}, index);
      return ${i.texture2D}(${e}, uv);
    }
  `}function bj(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${El(n)}
      }
    `;const o=n.shapeInfo.texShape,i=o[0],l=o[1];if(l===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const u=ur(e);return l===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / ${i}.0);
        return sampleTexture(${e}, uv);
      }
    `:i===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / ${l}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${u});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${l}, index + ${u});
      return sampleTexture(${e}, uv);
    }
  `}function yj(n,t){const e=n.shapeInfo.logicalShape,s=n.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,l=i[0],u=i[1],c=Vn();if(i!=null&&ce(e,i))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${c.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${l}.0);

        return ${c.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],f=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${f}, ${h[0]}, ${h[1]}, row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `}function vj(n,t){const e=n.shapeInfo.logicalShape,s=n.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&ce(e,i)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const g=i[0],x=i[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${x}.0, ${g}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:l,keptDims:u}=ei(e),c=l;if(c.length<e.length){const g=Rl(n,c),x=["row","col"];return`
      ${Nl(g,t)}
      float ${o}(int row, int col) {
        return ${o}(${Al(x,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${El(n)}
      }
    `;const h=i[0],f=i[1],p=ur(s);return f===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${h}, ${f}, index);
    return sampleTexture(${s}, uv);
  }
`}function wj(n,t){const e=n.shapeInfo.logicalShape,s=n.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(e[0]===1){const g=e.slice(1),x=[1,2],b=Rl(n,g),v=["b","row","col"];return`
        ${nR(b,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Al(v,x)});
        }
      `}const u=Vn();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const c=l[0],h=l[1],f=Math.ceil(e[2]/2),p=f*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${h}, ${p}, ${f}, b, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function Sj(n,t){const e=n.shapeInfo.logicalShape,s=n.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[1]*e[2],l=e[2],{newShape:u,keptDims:c}=ei(e),h=u;if(h.length<e.length){const v=Rl(n,h),S=["row","col","depth"];return`
        ${Nl(v,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Al(S,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${l}, 1)));
        ${El(n)}
      }
    `;const f=n.shapeInfo.texShape,p=f[0],g=f[1],x=n.shapeInfo.flatOffset;if(g===i&&x==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${l}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${g}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(g===l&&x==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${g}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=ur(s);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${l} + depth + ${b};
        vec2 uv = uvFromFlat(${p}, ${g}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Cj(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),o=Vn();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,l=i.length,u=n.shapeInfo.texShape,c=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],h=c[0],f=c[1],p=Math.ceil(i[l-1]/2);let g=p*Math.ceil(i[l-2]/2),x="int b, int row, int col",b=`b * ${g} + (row / 2) * ${p} + (col / 2)`;for(let v=2;v<l-1;v++)x=`int b${v}, `+x,g*=i[l-v-1],b=`b${v} * ${g} + `+b;return`
    vec4 ${s}(${x}) {
      int index = ${b};
      int texR = index / ${f};
      int texC = index - texR * ${f};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}, ${h});
      return ${o.texture2D}(${e}, uv);
    }
  `}function $j(n,t){const e=n.shapeInfo.logicalShape,s=n.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[3],l=e[2]*i,u=e[1]*l,{newShape:c,keptDims:h}=ei(e);if(c.length<e.length){const $=Rl(n,c),k=["row","col","depth","depth2"];return`
      ${Nl($,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Al(k,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${u}, ${l}, ${i}, 1)));
        ${El(n)}
      }
    `;const f=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,g=p[0],x=p[1],b=`int stride2 = ${s}Shape[3];`,v=`int stride1 = ${s}Shape[2] * stride2;`,S=`int stride0 = ${s}Shape[1] * stride1;`;if(x===u&&f==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${b}
        ${v}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${l}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${g}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(x===i&&f==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${g}.0);
        return sampleTexture(${s}, uv);
      }
    `;const C=ur(s);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${v}
      ${S}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${C});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${g}, ${x}, index + ${C});
      return sampleTexture(${s}, uv);
    }
  `}function Tj(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t[4],i=t[3]*o,l=t[2]*i,u=t[1]*l,{newShape:c,keptDims:h}=ei(t);if(c.length<t.length){const v=Rl(n,c),S=["row","col","depth","depth2","depth3"];return`
      ${Nl(v)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Al(S,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${l}, ${i}, ${o})) +
          depth3;
        ${El(n)}
      }
    `;const f=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,g=p[0],x=p[1];if(x===u&&f==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${l}, ${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${g}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(x===o&&f==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${g}.0);
        return sampleTexture(${e}, uv);
      }
    `;const b=ur(e);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} + depth * ${i} +
          depth2 * ${o} + depth3 + ${b};
      vec2 uv = uvFromFlat(${g}, ${x}, index);
      return sampleTexture(${e}, uv);
    }
  `}function kj(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:i}=ei(t);if(o.length<t.length){const S=Rl(n,o),C=["row","col","depth","depth2","depth3","depth4"];return`
      ${Nl(S)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Al(C,i)});
      }
    `}const l=t[5],u=t[4]*l,c=t[3]*u,h=t[2]*c,f=t[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${f}, ${h}, ${c}, ${u})) +
          dot(
            vec2(depth3, depth4),
            vec2(${l}, 1)));
        ${El(n)}
      }
    `;const p=n.shapeInfo.flatOffset,g=n.shapeInfo.texShape,x=g[0],b=g[1];if(b===f&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${c}, ${u}, ${l})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${x}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(b===l&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${x}.0);
        return sampleTexture(${e}, uv);
      }
    `;const v=ur(e);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${f} + col * ${h} + depth * ${c} +
          depth2 * ${u} + depth3 * ${l} + depth4 + ${v};
      vec2 uv = uvFromFlat(${x}, ${b}, index);
      return sampleTexture(${e}, uv);
    }
  `}function El(n){const t=n.name,e=dt(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Ij(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),o="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,l=t.logicalShape.length,u=eR(n.shapeInfo.logicalShape,t.logicalShape),c=ye(l),h=l-i;let f;const p=["x","y","z","w","u","v"];i===0?f="":l<2&&u.length>=1?f="coords = 0;":f=u.map($=>`coords.${p[$+h]} = 0;`).join(`
`);let g="";l<2&&i>0?g="coords":g=n.shapeInfo.logicalShape.map(($,k)=>`coords.${p[k+h]}`).join(", ");let x="return outputValue;";const v=dt(n.shapeInfo.logicalShape)===1,C=dt(t.logicalShape)===1;if(i===1&&!v&&!C)x=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(v&&!C)l===1?x=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:x=`
        return vec4(outputValue.x);
      `;else if(u.length){const $=i-2,k=i-1;u.indexOf($)>-1&&u.indexOf(k)>-1?x="return vec4(outputValue.x);":u.indexOf($)>-1?x="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(k)>-1&&(x="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${c} coords = getOutputCoords();
      ${f}
      vec4 outputValue = get${s}(${g});
      ${x}
    }
  `}function Nj(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),o="get"+s+"AtOutCoords",i=t.texShape,l=n.shapeInfo.texShape,u=n.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!n.shapeInfo.isUniform&&u===c&&n.shapeInfo.flatOffset==null&&ce(l,i))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const h=ye(c),f=eR(n.shapeInfo.logicalShape,t.logicalShape),p=c-u;let g;const x=["x","y","z","w","u","v"];u===0?g="":c<2&&f.length>=1?g="coords = 0;":g=f.map(v=>`coords.${x[v+p]} = 0;`).join(`
`);let b="";return c<2&&u>0?b="coords":b=n.shapeInfo.logicalShape.map((v,S)=>`coords.${x[S+p]}`).join(", "),`
    float ${o}() {
      ${h} coords = getOutputCoords();
      ${g}
      return get${s}(${b});
    }
  `}function ye(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function u1(n,t,e){const{newShape:s,keptDims:o}=ei(t),i=t.length,l=n&&i===3&&t[0]===1,u=l?t.slice(1):s,c=!n&&i>1&&!ce(t,e)&&s.length<i||l;return{useSqueezeShape:c,uniformShape:c?u:t,keptDims:o}}function Rl(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Al(n,t){return t.map(e=>n[e]).join(", ")}function Ej(n,t,e,s){const o=e.map((f,p)=>{const g={logicalShape:f.shape,texShape:f.isUniform?null:f.texData.texShape,isUniform:f.isUniform,isPacked:f.isUniform?!1:f.texData.isPacked,flatOffset:null};return f.texData!=null&&f.texData.slice!=null&&f.texData.slice.flatOffset>0&&(g.flatOffset=f.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:g}}),i=o.map(f=>f.shapeInfo),l={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},u=j8(o,l,t),c=S8(n.gl,u),h=n.createProgram(c);return lt().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:u,webGLProgram:h,inShapeInfos:i,outShapeInfo:l,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:t,fragmentShader:c,source:u,webGLProgram:h,inShapeInfos:i,outShapeInfo:l},oR(n,t,h)))}function oR(n,t,e){const s=[],o=[];let i,l,u,c=null,h=null;h=n.getUniformLocation(e,"NAN",!1),lt().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(e,"INFINITY",!1));const f=!1;for(const p of t.variableNames){const g={name:p,uniform:n.getUniformLocation(e,p,f),offset:n.getUniformLocation(e,`offset${p}`,f)};t.enableShapeUniforms&&(g.shape=n.getUniformLocation(e,`${p}Shape`,f),g.texShape=n.getUniformLocation(e,`${p}TexShape`,f)),s.push(g)}if(t.enableShapeUniforms&&(i=n.getUniformLocation(e,"outShape",f),u=n.getUniformLocation(e,"outShapeStrides",f),l=n.getUniformLocation(e,"outTexShape",f)),t.customUniforms)for(const p of t.customUniforms)o.push(n.getUniformLocation(e,p.name,f));return{variablesLocations:s,customUniformLocations:o,infLoc:c,nanLoc:h,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:l}}function G2(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const o=e.logicalShape,i=t[s],l=i.shape;if(!ce(o,l))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${l} must match`);if(e.isUniform&&i.isUniform)return;const u=e.texShape,c=i.isUniform?null:i.texData.texShape;if(!ce(u,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${u} and ${c} must match`)})}function Rj(n,t,e,s,o){t.program.enableShapeUniforms||(G2(t.inShapeInfos,e),G2([t.outShapeInfo],[s]));const i=s.texData.texture,l=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,l[0],l[1]):n.setOutputMatrixTexture(i.texture,l[0],l[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),lt().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<e.length;++c){const h=e[c],{uniform:f,offset:p,shape:g,texShape:x}=t.variablesLocations[c];if(g){const{uniformShape:b}=u1(t.program.packedInputs,h.shape,h.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(g,new Int32Array(b));break;case 2:n.gl.uniform2iv(g,new Int32Array(b));break;case 3:n.gl.uniform3iv(g,new Int32Array(b));break;case 4:n.gl.uniform4iv(g,new Int32Array(b));break}}if(x&&n.gl.uniform2i(x,h.texData.texShape[0],h.texData.texShape[1]),f!=null){if(h.isUniform){if(dt(h.shape)<2)n.gl.uniform1f(f,h.uniformValues[0]);else{let b=h.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(f,b)}continue}h.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,f,c)}}const u=t.outShapeLocation;if(u)switch(s.shape.length){case 1:n.gl.uniform1iv(u,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(u,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(u,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(u,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const c=Rt(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(c));break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&o)for(let c=0;c<t.program.customUniforms.length;++c){const h=t.program.customUniforms[c],f=t.customUniformLocations[c],p=o[c];if(h.type==="float")n.gl.uniform1fv(f,p);else if(h.type==="vec2")n.gl.uniform2fv(f,p);else if(h.type==="vec3")n.gl.uniform3fv(f,p);else if(h.type==="vec4")n.gl.uniform4fv(f,p);else if(h.type==="int")n.gl.uniform1iv(f,p);else if(h.type==="ivec2")n.gl.uniform2iv(f,p);else if(h.type==="ivec3")n.gl.uniform3iv(f,p);else if(h.type==="ivec4")n.gl.uniform4iv(f,p);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function Aj(n,t,e){let s="";t.concat(e).forEach(l=>{const u=l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!l.isUniform){const c=l.texData.texShape,{useSqueezeShape:h,uniformShape:f,keptDims:p}=u1(n.packedInputs,l.shape,c);let g="",x="",b="";if(f.length===1&&n.packedInputs){const N=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];g=`${N[0]>1}_${N[1]>1}`}else if(f.length===2&&!n.packedInputs)x=`${f[0]>1}_${f[1]>1}`;else if(f.length>2&&!n.packedInputs){const N=Rt(f);b=`${N[0]===c[1]}_${N[N.length-1]===c[1]}`}const v=l.shape.length,S=f.length===2&&ce(l.shape,c),C=dt(l.shape)===1,$=cl(l.shape,e.shape),k=!n.packedInputs&&v===e.shape.length&&ce(c,e.texData.texShape),T=n.packedInputs||f.length>2?"":`${c[0]>1}_${c[1]>1}`;s+=`${v}_${k}_${h?p:""}_${f.length}_${C}_${$}_${S}_${g}_${x}_${b}_${T}_${u}`}else{const c=l.isUniform?"uniform":l.texData.texShape;s+=`${l.shape}_${c}_${u}`}});const o=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+o+`${lt().getNumber("WEBGL_VERSION")}`,i}function _n(n){return lt().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Dj{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Yu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Vn();this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?om(["r","c","d"],t):lr(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}class Oj{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Yu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Vn();this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?om(["r","c","d"],t):lr(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}class _j{constructor(t){this.variableNames=["A"],this.outTexUsage=Cs.DOWNLOAD;const e=Vn();this.outputShape=t,this.userCode=`
      ${tR}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class Fj{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Cs.DOWNLOAD;const e=Vn();this.outputShape=t,this.userCode=`
      ${tR}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}const Mj={R:0,G:1,B:2,A:3};class W2{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=Vn();this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let l="";for(let u=0;u<s.length;u++){const c=s[u];l+=`
          if(offset == ${u}) {
            result = values[${Mj[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?l1():r1(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${l}
        }
        ${o.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class zj{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Vn();this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length);let o="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let l=0;l<=1;l++)for(let u=0;u<=1;u++){const c=l*2+u;o+=`
          localCoords = coords;
          if(localCoords[2] + ${u} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${u};
          if (localCoords[1] + ${l} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${l};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?l1():r1(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${s.output} = ${i};
        }
    `}}function Lj(n){const t=Vn(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return w8(n,e)}function Bj(n){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return k8(n,t)}function Uj(n){const t=new Uint16Array([0,1,2,2,1,3]);return I8(n,t)}function mh(n,t,e,s,o,i){E8(t,e);const l=N8(n),u=n.TEXTURE_2D;return Ct(n,()=>n.bindTexture(u,l)),Ct(n,()=>n.texParameteri(u,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Ct(n,()=>n.texParameteri(u,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Ct(n,()=>n.texParameteri(u,n.TEXTURE_MIN_FILTER,n.NEAREST)),Ct(n,()=>n.texParameteri(u,n.TEXTURE_MAG_FILTER,n.NEAREST)),lt().getNumber("WEBGL_VERSION")===1?Ct(n,()=>n.texImage2D(u,0,s,t,e,0,o,i,null)):Ct(n,()=>n.texStorage2D(u,1,s,t,e)),Ct(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:l,texShape:[e,t]}}function aR(n){return n.internalFormatFloat}function Vj(n,t,e,s){const[o,i]=fh(t,e);return mh(n,o,i,aR(s),s.textureFormatFloat,n.FLOAT)}function iR(n){return n.internalFormatHalfFloat}function Pj(n,t,e,s){const[o,i]=fh(t,e);return mh(n,o,i,iR(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function rR(n){return n.downloadTextureFormat}function Gj(n,t,e,s){const[o,i]=fh(t,e);return mh(n,o,i,rR(s),n.RGBA,n.UNSIGNED_BYTE)}function lR(n){return n.internalFormatPackedFloat}function Wj(n,t,e,s){const[o,i]=Il(t,e);return mh(n,o,i,lR(s),n.RGBA,n.FLOAT)}function uR(n){return n.internalFormatPackedHalfFloat}function Hj(n,t,e,s){const[o,i]=Il(t,e);return mh(n,o,i,uR(s),n.RGBA,s.textureTypeHalfFloat)}function qj(n,t,e){return Ct(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),U2(n,t,"clipSpacePos",e,3,20,0)&&U2(n,t,"uv",e,2,20,12)}function jj(n,t,e,s,o,i){Ct(n,()=>n.bindTexture(n.TEXTURE_2D,t));let l,u,c;o instanceof Uint8Array?(l=new Uint8Array(e*s*4),u=n.UNSIGNED_BYTE,c=n.RGBA):(l=new Float32Array(e*s*4),u=n.FLOAT,c=i.internalFormatPackedFloat),l.set(o),lt().getNumber("WEBGL_VERSION")===2?Ct(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,u,l)):Ct(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,e,s,0,n.RGBA,u,l)),Ct(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Xj(n,t,e){Ct(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?lt().getNumber("WEBGL_VERSION")===2?Ct(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):Ct(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):lt().getNumber("WEBGL_VERSION")===2?Ct(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):Ct(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),Ct(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Kj(n,t,e,s){const o=n.createBuffer();Ct(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,o));const u=4*4*t*e;return Ct(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,u,n.STREAM_READ)),Ct(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),Ct(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),o}function Yj(n,t,e){const s=n,o=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,o),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),o}function Zj(n,t,e,s){const[o,i]=fh(t,e),l=4,u=new Uint8Array(p8(t*e,l));return Ct(n,()=>n.readPixels(0,0,o,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,u)),new Float32Array(u.buffer)}function Qj(n,t,e,s,o,i,l,u){const c=n,h=new Float32Array(m8(i,l));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,h),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),h}function Jj(n,t,e){const s=new Float32Array(t*e*4);return Ct(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}class jx{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=lt().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,h8(e,t)):this.gl=fo(e),t=this.gl,lt().getNumber("WEBGL_VERSION")===2){const i=t;this.createVertexArray=()=>Ct(i,()=>i.createVertexArray()),this.bindVertexArray=l=>Ct(i,()=>i.bindVertexArray(l)),this.deleteVertexArray=l=>Ct(i,()=>i.deleteVertexArray(l)),this.getVertexArray=()=>Ct(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(t!=null){const i=t.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ct(t,()=>i.createVertexArrayOES()),this.bindVertexArray=l=>Ct(t,()=>i.bindVertexArrayOES(l)),this.deleteVertexArray=l=>Ct(t,()=>i.deleteVertexArrayOES(l)),this.getVertexArray=()=>Ct(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),lt().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",l="OES_texture_half_float";if(this.textureFloatExtension=Vd(this.gl,i),Ws(this.gl,l))this.textureHalfFloatExtension=Vd(this.gl,l);else if(lt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Ws(this.gl,o))this.colorBufferHalfFloatExtension=Vd(this.gl,o);else if(lt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Ws(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Ws(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Bj(this.gl),this.indexBuffer=Uj(this.gl),this.framebuffer=R8(this.gl),this.textureConfig=i1(this.gl,this.textureHalfFloatExtension)}get debug(){return lt().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Ct(t,()=>t.finish()),Ct(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Ct(t,()=>t.deleteFramebuffer(this.framebuffer)),Ct(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Ct(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Ct(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),Vj(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),Pj(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),Gj(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),Xj(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,o){this.throwIfDisposed(),jj(this.gl,t,e,s,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),Hj(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),Wj(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(V2(this.gl,this.framebuffer),this.outputTexture=null),Ct(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>Zj(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,o,i,l){return Qj(this.gl,t,e,s,o,i,l,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return Yj(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const o=Kj(this.gl,e,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(lt().getBool("WEBGL_FENCE_API_ENABLED")){const o=t,i=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const l=o.clientWaitSync(i,0,0);return l===o.ALREADY_SIGNALED||l===o.CONDITION_SATISFIED},e=i}else lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>Jj(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=Lj(e));const s=$8(e);Ct(e,()=>e.attachShader(s,this.vertexShader)),Ct(e,()=>e.attachShader(s,t)),T8(e,s);const o=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Gx(e,o),o}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;Ct(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),qj(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(Ct(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&Gx(this.gl,this.program),Ct(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?D8(this.gl,t,e):O8(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Ct(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),_8(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[o,i]=Il(e,s);this.setOutputMatrixTextureDriver(t,o,i)}setOutputMatrixWriteRegion(t,e,s,o){this.setOutputMatrixWriteRegionDriver(s,t,o,e)}setOutputPackedMatrixWriteRegion(t,e,s,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Gx(this.gl,this.program),Pd(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ct(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ct(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Vd(this.gl,lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,o=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(o.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();e.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await CC(()=>this.disposed||this.isQueryAvailable(t,lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const s=this.gl,o=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),o=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=tX(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in lt().platform&&(s=lt().platform.setTimeoutCustom.bind(lt().platform)),CC(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Wx(this.gl,t,this.framebuffer),this.debug&&Pd(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Wx(this.gl,this.outputTexture,this.framebuffer),this.debug&&Pd(this.gl)):V2(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const o=this.gl;Wx(o,t,this.framebuffer),this.debug&&Pd(o),this.outputTexture=t,Ct(o,()=>o.viewport(0,0,e,s)),Ct(o,()=>o.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,o){this.throwIfDisposed(),Ct(this.gl,()=>this.gl.scissor(t,e,s,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function tX(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}const{addImpl:eX,bincountImpl:cR,bincountReduceImpl:nX,bitwiseAndImpl:sX,castImpl:oX,ceilImpl:aX,concatImpl:iX,equalImpl:rX,expImpl:lX,expm1Impl:uX,floorImpl:cX,gatherNdImpl:hX,gatherV2Impl:dX,greaterImpl:fX,greaterEqualImpl:pX,lessImpl:mX,lessEqualImpl:gX,linSpaceImpl:xX,logImpl:bX,maxImpl:yX,maximumImpl:vX,minimumImpl:wX,multiplyImpl:SX,negImpl:CX,notEqualImpl:$X,prodImpl:TX,raggedGatherImpl:kX,raggedRangeImpl:IX,raggedTensorToTensorImpl:NX,rangeImpl:EX,rsqrtImpl:RX,scatterImpl:AX,sigmoidImpl:DX,simpleAbsImpl:hR,sliceImpl:OX,sparseFillEmptyRowsImpl:_X,sparseReshapeImpl:FX,sparseSegmentReductionImpl:dR,sqrtImpl:MX,staticRegexReplaceImpl:zX,stridedSliceImpl:LX,stringNGramsImpl:BX,stringSplitImpl:UX,stringToHashBucketFastImpl:VX,subImpl:PX,tileImpl:GX,topKImpl:WX,transposeImpl:c1,uniqueImpl:HX}=XG;function fR(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function Ln(n,t){return t===1?[n]:fR(n,t)}function qX(n,t){if(n===1)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}class jX{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=_n(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=Ln("rc",this.rank),s=ye(this.rank),o=this.getOutOfBoundsCondition(e),i=this.getSetup(e),l=this.getOutput(e);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${l}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let o=0;o<=1;o++){let i=`${s===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let l=2;l<this.rank;l++)i=`${t[t.length-1-l]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}class pR{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length);let s="";for(let o=0;o<4;o++){let i="thisRC = rc;";o%2===1&&(i+="thisRC.z += 1;"),o>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${XX(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?l1():r1(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function XX(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?q8(["r","c","d"],"inputShape"):lr(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class KX{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const o=q2(e,s),i=j2(t,o,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const l=H2(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=l,this.log();const c=this.freeTextures[i].pop();return this.usedTextures[i].push(c),c}let u;return o===yn.PACKED_2X2_FLOAT32?u=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===yn.PACKED_2X2_FLOAT16?u=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===yn.UNPACKED_FLOAT32?u=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===yn.UNPACKED_FLOAT16?u=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===yn.PACKED_4X1_UNSIGNED_BYTE&&(u=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(u),this.numUsedTextures++,this._numBytesAllocated+=l,this.log(),u}releaseTexture(t,e,s,o){if(this.freeTextures==null)return;const i=q2(s,o),l=j2(e,i,o);l in this.freeTextures||(this.freeTextures[l]=[]);const u=H2(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,o),c=lt().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=u):(this.freeTextures[l].push(t),this.numFreeTextures++,this._numBytesFree+=u),this.numUsedTextures--;const h=this.usedTextures[l],f=h&&h.indexOf(t);if(f==null||f<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[f]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function YX(n,t){const e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function H2(n,t,e,s,o){const i=ZX(t,s);let l;if(o){const[c,h]=Il(n[0],n[1]);l=c*h}else{const[c,h]=fh(n[0],n[1]);l=c*h}const u=YX(e,i);return l*u}function ZX(n,t){switch(n){case yn.PACKED_2X2_FLOAT32:return lR(t);case yn.PACKED_2X2_FLOAT16:return uR(t);case yn.UNPACKED_FLOAT32:return aR(t);case yn.UNPACKED_FLOAT16:return iR(t);case yn.PACKED_4X1_UNSIGNED_BYTE:return rR(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function QX(n){return lt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?yn.PACKED_2X2_FLOAT32:yn.UNPACKED_FLOAT32:n?yn.PACKED_2X2_FLOAT16:yn.UNPACKED_FLOAT16}function q2(n,t){if(n===Cs.UPLOAD)return yn.PACKED_2X2_FLOAT32;if(n===Cs.RENDER||n==null)return QX(t);if(n===Cs.DOWNLOAD||n===Cs.PIXELS)return yn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function j2(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class ko{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ks="if (isnan(x)) return x;",JX="return x;",X2="return abs(x);",tK="return (x >= 0.0) ? x : (exp(x) - 1.0);",eK=Ks+`
  return (x < 0.0) ? 0.0 : x;
`,nK=Ks+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ua="return x;",sK="return 1.0 / (1.0 + exp(-1.0 * x));";const oK="return x;",aK=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,iK=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,rK=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lK="return 1.0 / (1.0 + exp(-1.0 * x));";class Wa{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class uK{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length);const e=t.length,s=Ln("rc",e),o=ye(e),i=qX(e,s),l=s.slice(-2),u=e<=1?"rc":`vec2(${l.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${u}));
      }
    `}}const cK=VT,hK=1e-7,dK=1e-4,Hd={};function fK(n){return n in Hd||(Hd[n]={}),Hd[n]}const pK=lt().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),mK=600;function gK(){return lt().global.screen==null?1024:lt().global.screen.height*lt().global.screen.width*window.devicePixelRatio*mK/1024/1024}class am extends _0{nextDataId(){return am.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!lt().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof jx)e=t;else{const s=fo(lt().getNumber("WEBGL_VERSION"),t);e=new jx(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=fo(lt().getNumber("WEBGL_VERSION"));e=new jx(s),this.binaryCache=fK(lt().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new KX(this.gpgpu),this.numMBBeforeWarning=gK(),this.texData=new p$(this,wo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,s,o,i,l){const u=this.makeTensorInfo(e,s),c=this.texData.get(u.dataId);c.isPacked=!1,c.texture={texture:t,texShape:[o,i]},c.texShape=[o,i];const h=Gd(e),f=new W2(h,!1,l),p=this.runWebGLProgram(f,[u],s,[[o,i]]);return p.shape=e,c.texture=null,this.disposeIntermediateTensorInfo(u),p.dataId}write(t,e,s){if((lt().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||lt().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:e,dtype:s,values:t,usage:Cs.UPLOAD,refCount:1}),o}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,s,o,i){if(lt().getBool("DEBUG")&&this.checkNumericalProblems(e),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:o,values:e,usage:Cs.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:s,dtype:o,complexTensorInfos:i,slice:l,shape:u,isPacked:c}=e;if(l!=null){let g;c?g=new Wa(u,Ua):g=new ko(u,Ua);const x=this.runWebGLProgram(g,[{dataId:t,shape:u,dtype:o}],o),b=this.readSync(x.dataId);return this.disposeIntermediateTensorInfo(x),b}if(s!=null)return this.convertAndCacheOnCPU(t);if(o==="string")return s;const h=this.activeTimers!=null;let f;h&&(f=Hn());let p;if(o==="complex64"){const g=this.readSync(i.real.dataId),x=this.readSync(i.imag.dataId);p=ca(g,x)}else p=this.getValuesFromTexture(t);return h&&(this.downloadWaitMs+=Hn()-f),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){const b=this.pendingRead.get(t);return new Promise(v=>b.push(v))}const e=this.texData.get(t),{values:s,shape:o,slice:i,dtype:l,complexTensorInfos:u,isPacked:c}=e;if(i!=null){let b;c?b=new Wa(o,Ua):b=new ko(o,Ua);const v=this.runWebGLProgram(b,[{dataId:t,shape:o,dtype:l}],l),S=this.read(v.dataId);return this.disposeIntermediateTensorInfo(v),S}if(s!=null)return this.convertAndCacheOnCPU(t);if(lt().getBool("DEBUG")&&!lt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&lt().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,f;if(l!=="complex64"&&lt().get("WEBGL_BUFFER_SUPPORTED")){f=this.decode(t);const b=this.texData.get(f.dataId);h=this.gpgpu.createBufferFromTexture(b.texture.texture,...Ud(o))}this.pendingRead.set(t,[]),l!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(l==="complex64"){const b=await Promise.all([this.read(u.real.dataId),this.read(u.imag.dataId)]),v=b[0],S=b[1];p=ca(v,S)}else if(h==null)p=this.getValuesFromTexture(t);else{const b=dt(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(h,b)}if(f!=null&&this.disposeIntermediateTensorInfo(f),h!=null){const b=this.gpgpu.gl;Ct(b,()=>b.deleteBuffer(h))}const g=this.convertAndCacheOnCPU(t,p),x=this.pendingRead.get(t);return this.pendingRead.delete(t),x.forEach(b=>b(g)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&wo().removeDataId(t,this),this.pendingDeletes--),g}readToGPU(t,e={}){const s=this.texData.get(t),{values:o,shape:i,slice:l,dtype:u,isPacked:c,texture:h}=s;if(u==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(l!=null){let x;c?x=new Wa(i,Ua):x=new ko(i,Ua);const b=this.runWebGLProgram(x,[{dataId:t,shape:i,dtype:u}],u),v=this.readToGPU(b,e);return this.disposeIntermediateTensorInfo(b),v}if(h==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const f=this.decode(t,e.customTexShape),p=wo().makeTensorFromTensorInfo(f),g=this.texData.get(f.dataId);return Object.assign({tensorRef:p},g.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(o=>Ka(o));return Ht(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ht(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const s=t[e];if(!y8(s))throw lt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:s,isPacked:o}=this.texData.get(t),i=dt(e);if(lt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const g=this.decode(t),x=this.texData.get(g.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(x.texture.texture,...Ud(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(g),b}const l=lt().getBool("WEBGL_PACK")&&o===!0,u=l?Gd(e):e,c=l?new Fj(u):new _j(u),h=this.runWebGLProgram(c,[{shape:u,dtype:s,dataId:t}],"float32"),f=this.texData.get(h.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(f.texture.texture,f.texShape[0],f.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(h),p}timerAvailable(){return lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,s=[];let o=!1;this.programTimersStack==null?(this.programTimersStack=s,o=!0):this.activeTimers.push(s),this.activeTimers=s,t();const i=Pi(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),l=Pi(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=e,o&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(i);u.kernelMs=_O(c),u.getExtraProfileInfo=()=>c.map((h,f)=>({name:l[f],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Hn(),endMs:null}}endTimer(t){return lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Hn(),t)}async getQueryTime(t){if(lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,e),this.disposeData(s.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:s,texShape:o,usage:i,isPacked:l,slice:u}=this.texData.get(t),c=u&&u.origDataId||t,h=this.dataRefCount.get(c);h>1?this.dataRefCount.set(c,h-1):(this.dataRefCount.delete(c),e!=null&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(e,o,i,l)));const f=this.texData.get(t);f.texture=null,f.texShape=null,f.isPacked=!1,f.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=pK){return lt().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&dt(s.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){Ss("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return cK(t.shape,e)}packedUnaryOp(t,e,s){const o=new Wa(t.shape,e),i=this.compileAndRun(o,[t],s);return wo().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const o=hR(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,o)}if(lt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,X2,t.dtype);const e=new ko(t.shape,X2),s=this.compileAndRun(e,[t]);return wo().makeTensorFromTensorInfo(s)}makeTensorInfo(t,e,s){let o;if(e==="string"&&s!=null&&s.length>0&&tc(s[0])){const i=s.map(l=>qa(l));o=this.write(i,t,e)}else o=this.write(s,t,e);return this.texData.get(o).usage=null,{dataId:o,shape:t,dtype:e}}makeOutput(t,e,s){return wo().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,s),this)}unpackTensor(t){const e=new uK(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new jX(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const s=[xl(t.shape),...bl(t.shape)],o={dtype:t.dtype,shape:s,dataId:t.dataId},i=[xl(e),...bl(e)],l=new pR(i,s),u=!0,c=[s],h=this.runWebGLProgram(l,[o],t.dtype,c,u);return{dataId:h.dataId,shape:e,dtype:h.dtype}}decode(t,e){const s=this.texData.get(t),{isPacked:o,shape:i,dtype:l}=s;if(e!=null){const g=dt(i),x=e[0]*e[1]*4;_(g<=x,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const u=Gd(i);let c;o?c=new Oj(u):c=new Dj(u);const h=!0,f=[e??Ud(u)],p=this.runWebGLProgram(c,[{shape:u,dtype:l,dataId:t}],l,f,h,e);return{dtype:l,shape:i,dataId:p.dataId}}runWebGLProgram(t,e,s,o,i=!1,l){const u=this.makeTensorInfo(t.outputShape,s),c=this.texData.get(u.dataId);if(t.packedOutput&&(c.isPacked=!0),t.outPackingScheme===Yu.DENSE){const C=l??Ud(t.outputShape);c.texShape=C.map($=>$*2)}if(t.outTexUsage!=null&&(c.usage=t.outTexUsage),dt(u.shape)===0)return c.values=En(u.dtype,0),u;const h=[],f=e.map(C=>{if(C.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let $=this.texData.get(C.dataId);if($.texture==null){if(!t.packedInputs&&dt(C.shape)<=lt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:C.shape,texData:null,isUniform:!0,uniformValues:$.values};t.packedInputs&&($.isPacked=!0,$.shape=C.shape)}if(this.uploadToGPU(C.dataId),!!$.isPacked!=!!t.packedInputs)C=$.isPacked?this.unpackTensor(C):this.packTensor(C),h.push(C),$=this.texData.get(C.dataId);else if($.isPacked&&!Rf($.shape,C.shape)){const k=C,T=C.shape;C.shape=$.shape,C=this.packedReshape(C,T),h.push(C),$=this.texData.get(C.dataId),k.shape=T}return{shape:C.shape,texData:$,isUniform:!1}});this.uploadToGPU(u.dataId);const p={shape:u.shape,texData:c,isUniform:!1},g=Aj(t,f,p),x=this.getAndSaveBinary(g,()=>Ej(this.gpgpu,t,f,p)),b=this.activeTimers!=null;let v;b&&(v=this.startTimer()),lt().get("ENGINE_COMPILE_ONLY")||Rj(this.gpgpu,x,f,p,o),h.forEach(C=>this.disposeIntermediateTensorInfo(C)),b&&(v=this.endTimer(v),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(v)}));const S=lt().getNumber("WEBGL_FLUSH_THRESHOLD");if(S>0){const C=Hn();C-this.lastGlFlushTime>S&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=C)}if(!lt().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&i===!1){const C=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),C}return u}compileAndRun(t,e,s,o,i=!1){return s=s||e[0].dtype,this.runWebGLProgram(t,e,s,o,i)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(lt().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=st(()=>{if(!lt().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=lt().getBool("DEBUG");lt().set("DEBUG",!1);const e=this.abs(ue(1e-8)).dataSync()[0];if(lt().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?hK:dK}uploadToGPU(t){const e=this.texData.get(t),{shape:s,dtype:o,values:i,texture:l,usage:u,isPacked:c}=e;if(l!=null)return;const h=this.activeTimers!=null;let f;h&&(f=Hn());let p=e.texShape;if(p==null&&(p=z8(s,c),e.texShape=p),i!=null){const g=Gd(s);let x,b=p[1],v=p[0];const S=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!S)&&([b,v]=Il(p[0],p[1])),c?x=new zj(g,S):x=new W2(g,S);const C=S?[v,b]:p,$=this.makeTensorInfo(C,o),k=this.texData.get($.dataId);S?k.usage=Cs.PIXELS:k.usage=Cs.UPLOAD,k.texShape=C,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture($.dataId),b,v,i);const T=[[v,b]],R=this.runWebGLProgram(x,[$],o,T,!0),D=this.texData.get(R.dataId);e.texShape=D.texShape,e.isPacked=D.isPacked,e.usage=D.usage,lt().get("ENGINE_COMPILE_ONLY")?this.disposeData(R.dataId):(e.texture=D.texture,e.values=null,this.texData.delete(R.dataId)),this.disposeIntermediateTensorInfo($),h&&(this.uploadWaitMs+=Hn()-f)}else{const g=this.acquireTexture(p,u,o,c);e.texture=g}}convertAndCacheOnCPU(t,e){const s=this.texData.get(t),{dtype:o}=s;return e!=null&&(s.values=xK(e,o)),s.values}acquireTexture(t,e,s,o){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,o)}computeBytes(t,e){return t[0]*t[1]*sf(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const s=new Promise(o=>{try{this.checkCompletion_(e),o(!0)}catch(i){throw i}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await sk(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(JE(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:s,infLoc:o,nanLoc:i,outShapeLocation:l,outShapeStridesLocation:u,outTexShapeLocation:c}=oR(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=s,t.infLoc=o,t.nanLoc=i,t.outShapeLocation=l,t.outShapeStridesLocation=u,t.outTexShapeLocation=c}}createTensorFromGPUData(t,e,s){t.channels=t.channels||"RGBA";const{texture:o,height:i,width:l,channels:u}=t,c=wo().backend;if(!c.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=c.writeTexture(o,e,s,i,l,u);return wo().makeTensorFromDataId(h,e,s,c)}}am.nextDataId=0;function xK(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}else throw new Error(`Unknown dtype ${t}`)}sT()&&iT("webgl",()=>new am,2);const h1=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class er{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=Ut(e,s),this.enableShapeUniforms=_n(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const cr=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Dl{constructor(t,e,s,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ut(e,s);const i=this.outputShape.length;this.enableShapeUniforms=_n(i);let l="";if(o)if(i===0||dt(this.outputShape)===1)l=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(l=`
          ${ye(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?l+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:l+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=Ln("coords",i);this.enableShapeUniforms?l+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:l+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${l}

        setOutput(result);
      }
    `}}function hs(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const bK={kernelName:wc,backendName:"webgl",kernelFunc:hs};function hi(n){const{inputs:t,backend:e}=n,{real:s,imag:o}=t,i=e.makeTensorInfo(s.shape,"complex64"),l=e.texData.get(i.dataId),u=hs({inputs:{x:s},backend:e}),c=hs({inputs:{x:o},backend:e});return l.complexTensorInfos={real:u,imag:c},i}const yK={kernelName:X0,backendName:"webgl",kernelFunc:hi};const mR="return (a < 0.) ? b * a : a;",gR=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function vK(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{alpha:i}=s,l=e.makeTensorInfo([],"float32",ni(i,"float32")),u=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Dl(gR,o.shape,l.shape):new er(mR,o.shape,l.shape),c=e.runWebGLProgram(u,[o,l],"float32");return e.disposeIntermediateTensorInfo(l),c}const wK={kernelName:tp,backendName:"webgl",kernelFunc:vK};const xR="return (a < 0.) ? b * a : a;",bR=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function SK(n){const{inputs:t,backend:e}=n,{x:s,alpha:o}=t,i=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Dl(bR,s.shape,o.shape):new er(xR,s.shape,o.shape);return e.runWebGLProgram(i,[s,o],"float32")}const CK={kernelName:yp,backendName:"webgl",kernelFunc:SK};const Ol="if (isnan(x)) return x;";function ee({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:o,backend:i})=>{const{x:l}=o,u=i,c=s||l.dtype;if(u.shouldExecuteOnCPU([l])&&e!=null){const p=u.texData.get(l.dataId),g=e(p.values,c);return u.makeTensorInfo(l.shape,c,g)}const h=lt().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let f;return h?f=new Wa(l.shape,t):f=new ko(l.shape,n),u.runWebGLProgram(f,[l],c)}}function Cn({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:o,dtype:i}){return({inputs:l,backend:u})=>{const{a:c,b:h}=l,f=u;if(s&&c.dtype==="complex64"){const b=f.texData.get(c.dataId),v=f.texData.get(h.dataId),[S,C]=[[b.complexTensorInfos.real,v.complexTensorInfos.real],[b.complexTensorInfos.imag,v.complexTensorInfos.imag]].map(k=>{const[T,N]=k,R={dataId:T.dataId,dtype:T.dtype,shape:c.shape},D={dataId:N.dataId,dtype:N.dtype,shape:h.shape},z=new er(n,c.shape,h.shape);return f.runWebGLProgram(z,[R,D],us(T.dtype,N.dtype))}),$=hi({inputs:{real:S,imag:C},backend:f});return f.disposeIntermediateTensorInfo(S),f.disposeIntermediateTensorInfo(C),$}const p=i||us(c.dtype,h.dtype);if((c.dtype==="string"||h.dtype==="string"||f.shouldExecuteOnCPU([c,h]))&&o!=null){const b=f.texData.get(c.dataId).values,v=f.texData.get(h.dataId).values,S=c.dtype==="string"?ha(b):b,C=c.dtype==="string"?ha(v):v,[$,k]=o(c.shape,h.shape,S,C,p),T=f.makeTensorInfo(k,p),N=f.texData.get(T.dataId);return N.values=$,T}const g=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let x;return g?x=new Dl(t,c.shape,h.shape,e):x=new er(n,c.shape,h.shape),f.runWebGLProgram(x,[c,h],p)}}function Zu(n,t=!1){if(n==="linear")return t?oK:JX;if(n==="relu")return t?iK:eK;if(n==="elu")return t?aK:tK;if(n==="relu6")return t?rK:nK;if(n==="prelu")return t?bR:xR;if(n==="leakyrelu")return t?gR:mR;if(n==="sigmoid")return t?lK:sK;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class yR{constructor(t,e,s,o=!1,i=!1,l=!1,u=null,c=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=_n(this.outputShape.length);const f=o?t[1]:t[2],p=Math.ceil(f/2),g=o?"i * 2, rc.y":"rc.y, i * 2",x=i?"rc.z, i * 2":"i * 2, rc.z",b=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],v=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let S="",C="";u&&(c?S=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${u}
        }`:h?S=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${u}
        }`:S=`vec4 activation(vec4 x) {
          ${u}
        }`,C="result = activation(result);");const $=l?"result += getBiasAtOutCoords();":"";l&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let k="rc.x",T="rc.x";t[0]<e[0]?k=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(T=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${S}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${k};
        int batchB = ${T};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${g});
          vec4 b = getMatrixB(batchB, ${x});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${v[0]});
          result += (${b[1]} * ${v[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${$}

        ${C}

        setOutput(result);
      }
    `}}const K2={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Y2{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ut(e,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const Z2="return a * b;";function d1(n){const{inputs:t,backend:e}=n,{a:s,b:o}=t,i=us(s.dtype,o.dtype);if(s.dtype==="complex64"){const u=e.texData.get(s.dataId),c=e.texData.get(o.dataId),h=new Y2(K2.REAL,s.shape,o.shape),f=new Y2(K2.IMAG,s.shape,o.shape),p=[{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:o.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:o.shape}],g=e.runWebGLProgram(h,p,"float32"),x=e.runWebGLProgram(f,p,"float32"),b=hi({inputs:{real:g,imag:x},backend:e});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),b}if(e.shouldExecuteOnCPU([s,o])){const u=e.texData.get(s.dataId),c=e.texData.get(o.dataId),[h,f]=SX(s.shape,o.shape,u.values,c.values,i),p=e.makeTensorInfo(f,i),g=e.texData.get(p.dataId);return g.values=h,p}let l;return lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?l=new Dl(Z2,s.shape,o.shape):l=new er(Z2,s.shape,o.shape),e.runWebGLProgram(l,[s,o],i)}const $K={kernelName:Rc,backendName:"webgl",kernelFunc:d1};function TK(n,t,e){const s=[xl(n.shape),...bl(n.shape)],o={dtype:n.dtype,shape:s,dataId:n.dataId},i=[xl(t),...bl(t)],l=new pR(i,s),u=!0,c=[s],h=e.runWebGLProgram(l,[o],n.dtype,c,u);return{dataId:h.dataId,shape:t,dtype:h.dtype}}function wt(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{shape:i}=s,l=e,u=dt(o.shape),c=g$(i,u),h=dt(c);_(u===h,()=>`The new shape (${c}) has ${h} elements and the old shape (${o.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`);const f=l.texData.get(o.dataId);return f.isPacked&&!Rf(o.shape,c)&&!(f.texture!==null&&Rf(f.shape,c))?TK(o,c,l):(l.incRef(o.dataId),{dataId:o.dataId,shape:c,dtype:o.dtype})}const kK={kernelName:wp,backendName:"webgl",kernelFunc:wt};class Q2{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:o,inSize:i,outSize:l}=t;this.outputShape=[o,l];const u=Math.floor(s/4)*4,c=s%4;let h="sumValue += dot(values, ones);";if(e!=null){const p=1/e;h=`sumValue += dot(values * ${rl(p)?p.toPrecision(2):p}, ones);`}let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}class IK{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:o,inSize:i,outSize:l}=t;this.outputShape=[o,l];let u="0.0",c="";e==="prod"?u="1.0":e==="min"?(u="1.0 / 1e-20",c="min"):e==="max"&&(u="-1.0 / 1e-20",c="max");let h=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?h="sumValue":e==="prod"?h="prodValue":e==="all"?h="allValue":e==="any"&&(h="anyValue");const f=Math.floor(s/4)*4,p=s%4;let g=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,x="vec4";e==="all"?(u="1.0",g=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,x="bvec4"):e==="any"&&(u="0.0",g=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,x="bvec4");let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${u};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${u});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${f}; i += 4) {
          int inIdx = inOffset + i;
          ${x} values = ${x}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${g}
        }

        int inIdx = inOffset + ${f};
        if (${p===1}) {
          ${x} values = ${x}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${g}
        } else if (${p===2}) {
          ${x} values = ${x}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${g}
        } else if (${p===3}) {
          ${x} values = ${x}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${g}
        }
        setOutput(${h});
      }
    `}}function NK(n){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:n[1],s=Gp(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}function hr(n,t,e,s){const o=NK(n.shape);let i=n;for(let l=0;l<o.length;l++){const{inSize:u,windowSize:c,outSize:h}=o[l];let f,p;e==="mean"?f=l===0?new Q2({windowSize:c,inSize:u,batchSize:n.shape[0],outSize:h},u):new Q2({windowSize:c,inSize:u,batchSize:n.shape[0],outSize:h}):f=new IK({windowSize:c,inSize:u,batchSize:n.shape[0],outSize:h},e),p=i,i=s.runWebGLProgram(f,[i],t),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return i}class EK{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let l=0;l<s.length;l++)s[l]=t[e[l]];this.outputShape=s,this.rank=s.length;const o=ye(this.rank),i=RK(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function RK(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let o=0;o<n.length;o++)s[n[o]]=e[o];return s.join()}class AK{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let f=0;f<s.length;f++)s[f]=t[e[f]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const o=ye(this.rank),i=fR("rc",this.rank),l=new Array(this.rank);for(let f=0;f<e.length;f++)l[e[f]]=i[f];const u=`vec2(${l.slice(-2).join()})`,c=`++${i[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${l.join()}), ${u})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${c}) {
        result[1] = ${h};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${c}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}function im(n,t,e){const s=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new AK(n.shape,t):new EK(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function DK(n,t,e,s){const o=t,i=n.shape.length,l=qt(o,n.shape);let u=l;const c=Be(u,i),h=c!=null;let f=n;h&&(f=im(n,c,s),u=qe(u.length,i)),Sn("sum",u,i);const[p,g]=gn(f.shape,u);let x=p;e&&(x=Qe(p,l));const b=dt(g),S=dt(n.shape)/b,C=wt({inputs:{x:f},attrs:{shape:[S,b]},backend:s}),$=Nb(n.dtype),k=hr(C,$,"sum",s),T=wt({inputs:{x:k},attrs:{shape:x},backend:s});return s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(k),h&&s.disposeIntermediateTensorInfo(f),T}function rm(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s;return DK(o,i,l,e)}const OK={kernelName:Ip,backendName:"webgl",kernelFunc:rm};function Un(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{perm:i}=s,l=e,u=o.shape.length,c=new Array(u);for(let f=0;f<c.length;f++)c[f]=o.shape[i[f]];let h;if(l.shouldExecuteOnCPU([o])){const p=l.texData.get(o.dataId).values,g=c1(p,o.shape,o.dtype,i,c);h=l.makeTensorInfo(c,o.dtype);const x=l.texData.get(h.dataId);x.values=g}else h=im(o,i,l);return h}const _K={kernelName:sl,backendName:"webgl",kernelFunc:Un};const vR=1e3;function Af({a:n,b:t,transposeA:e,transposeB:s,backend:o,bias:i=null,preluActivationWeights:l=null,leakyreluAlpha:u=0,activation:c=null}){const h=n.shape.length,f=t.shape.length,p=e?n.shape[h-2]:n.shape[h-1],g=s?t.shape[f-1]:t.shape[f-2],x=e?n.shape[h-1]:n.shape[h-2],b=s?t.shape[f-2]:t.shape[f-1],v=n.shape.slice(0,-2),S=t.shape.slice(0,-2),C=dt(v),$=dt(S),T=Ut(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([x,b]);_(p===g,()=>`Error in matMul: inner shapes (${p}) and (${g}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const N=e?[C,p,x]:[C,x,p],R=s?[$,b,g]:[$,g,b],D=wt({inputs:{x:n},backend:o,attrs:{shape:N}}),z=wt({inputs:{x:t},backend:o,attrs:{shape:R}}),O=[D,z],F=Math.max(C,$),E=e?D.shape[1]:D.shape[2],U=i!=null,Y=l!=null,X=c==="leakyrelu",q=c!=null?Zu(c,!0):null,L=U||Y||X||q!=null;let P;if((x===1||b===1)&&E>vR&&L===!1){let nt=D,it=z;e&&(nt=Un({inputs:{x:D},backend:o,attrs:{perm:[0,2,1]}}),O.push(nt)),s&&(it=Un({inputs:{x:z},backend:o,attrs:{perm:[0,2,1]}}),O.push(it));const M=b!==1,G=b===1;let Q=nt;M&&(Q=wt({inputs:{x:nt},backend:o,attrs:{shape:[F,E,1]}}),O.push(Q));const ut=b===1?2:1;let ft=it;G&&(ft=wt({inputs:{x:it},backend:o,attrs:{shape:[F,1,E]}}),O.push(ft));const gt=d1({inputs:{a:Q,b:ft},backend:o});P=rm({inputs:{x:gt},backend:o,attrs:{axis:ut,keepDims:!0}}),O.push(gt)}else{const nt=us(n.dtype,t.dtype),it=new yR(N,R,[F,x,b],e,s,U,q,Y,X),M=[D,z];if(i!=null&&M.push(i),Y&&M.push(l),X){const G=o.makeTensorInfo([],"float32",ni(u,"float32"));M.push(G),O.push(G)}P=o.runWebGLProgram(it,M,nt)}const W=wt({inputs:{x:P},backend:o,attrs:{shape:T}});O.push(P);for(const nt of O)o.disposeIntermediateTensorInfo(nt);return W}function FK(n){const{inputs:t,backend:e,attrs:s}=n,{a:o,b:i,bias:l,preluActivationWeights:u}=t,{transposeA:c,transposeB:h,activation:f,leakyreluAlpha:p}=s;return Af({a:o,b:i,transposeA:c,transposeB:h,backend:e,bias:l,preluActivationWeights:u,leakyreluAlpha:p,activation:f})}const MK={kernelName:of,backendName:"webgl",kernelFunc:FK};const J2="return abs(x);";function zK(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=e.texData.get(s.dataId),l=hR(i.values);return e.makeTensorInfo(s.shape,s.dtype,l)}let o;return lt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Wa(s.shape,J2):o=new ko(s.shape,J2),e.runWebGLProgram(o,[s],s.dtype)}const LK={kernelName:_f,backendName:"webgl",kernelFunc:zK};const BK=Ks+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,UK=ee({opSnippet:BK}),VK={kernelName:ec,backendName:"webgl",kernelFunc:UK};const PK=Ks+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,GK=ee({opSnippet:PK}),WK={kernelName:nc,backendName:"webgl",kernelFunc:GK};const t$="return a + b;",HK=Cn({opSnippet:t$,packedOpSnippet:t$,supportsComplex:!0,cpuKernelImpl:eX}),qK={kernelName:wl,backendName:"webgl",kernelFunc:HK};class jK{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,l)=>`T${l}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const o=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}}class XK{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,l)=>`T${l}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const o=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}}function nf(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return hs({inputs:{x:s[0]},backend:e});if(s.length>lt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(s.length/2),h=nf({inputs:s.slice(0,c),backend:e}),f=nf({inputs:s.slice(c),backend:e});return nf({inputs:[h,f],backend:e})}const o=s.map(c=>c.dtype).reduce((c,h)=>us(c,h)),i=s.map(c=>c.shape),u=lt().getBool("WEBGL_PACK")?new XK(s[0].shape,i):new jK(s[0].shape,i);return e.runWebGLProgram(u,s,o)}const KK={kernelName:V0,backendName:"webgl",kernelFunc:nf};function YK(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s,u=o.shape.length,c=qt(i,o.shape);let h=c;const f=Be(h,u);let p=o;f!=null&&(p=Un({inputs:{x:o},backend:e,attrs:{perm:f}}),h=qe(h.length,u)),Sn("all",h,u);const[g,x]=gn(p.shape,h),b=dt(x),v=wt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),S=hr(v,v.dtype,"all",e);let C;if(l){const $=Qe(g,c);C=wt({inputs:{x:S},backend:e,attrs:{shape:$}})}else C=wt({inputs:{x:S},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(S),f!=null&&e.disposeIntermediateTensorInfo(p),C}const ZK={kernelName:P0,backendName:"webgl",kernelFunc:YK};function QK(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s,u=o.shape.length,c=qt(i,o.shape);let h=c;const f=Be(h,u);let p=o;f!=null&&(p=Un({inputs:{x:o},backend:e,attrs:{perm:f}}),h=qe(h.length,u)),Sn("any",h,u);const[g,x]=gn(p.shape,h),b=dt(x),v=wt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),S=hr(v,v.dtype,"any",e);let C;if(l){const $=Qe(g,c);C=wt({inputs:{x:S},backend:e,attrs:{shape:$}})}else C=wt({inputs:{x:S},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(S),f!=null&&e.disposeIntermediateTensorInfo(p),C}const JK={kernelName:G0,backendName:"webgl",kernelFunc:QK};class t7{constructor(t,e,s){this.variableNames=["A"];const{windowSize:o,batchSize:i,outSize:l}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,l];const u=e==="max"?">":"<",c=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${u} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class e7{constructor(t,e,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,_(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=t[t.length-1],l=Math.ceil(i/e);this.outputShape=t.slice(0,-1),l>1&&this.outputShape.push(l),o||this.variableNames.push("bestIndicesA");const u=this.outputShape,c=u.length,h=ye(c),f=Ln("coords",c);let p,g;if(l===1){g=c+1;const z=ye(g);p=`
        ${z} sourceLocR = ${z}(${f.join()}, 0);
        ++${f[c-1]};
        ${z} sourceLocG = ${z}(${f.join()}, 0);
        ++${f[c-2]};
        ${z} sourceLocA = ${z}(${f.join()}, 0);
        --${f[c-1]};
        ${z} sourceLocB = ${z}(${f.join()}, 0);
        --${f[c-2]};`}else g=c,p=`
        ${h} sourceLocR = coords;
        ++${f[c-1]};
        ${h} sourceLocG = coords;
        ++${f[c-2]};
        ${h} sourceLocA = coords;
        --${f[c-1]};
        ${h} sourceLocB = coords;
        --${f[c-2]};`;const x=["x","y","z","w","u","v"].slice(0,g),b="."+x[g-1],v=x.map(z=>"int "+z),S=Ln("sourceLocR",g-1).concat("inIdx.r"),C=Ln("sourceLocG",g-1).concat("inIdx.g"),$=Ln("sourceLocB",g-1).concat("inIdx.b"),k=Ln("sourceLocA",g-1).concat("inIdx.a"),T=s==="max"?"greaterThan":"lessThan",N=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${C.join()}),
                             getBestIndicesAChannel(${$.join()}),
                             getBestIndicesAChannel(${k.join()})));`,R=`vec4(
            getAChannel(${S.join()}),
            hasNextCol ? getAChannel(${C.join()}) : 0.,
            hasNextRow ? getAChannel(${$.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`,D=o?"":`
      float getBestIndicesAChannel(${v.join()}) {
        return getChannel(getBestIndicesA(${x.join()}),
                                          vec2(${x.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${v.join()}) {
        return getChannel(getA(${x.join()}),
                               vec2(${x.slice(-2).join()}));
      }
      ${D}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${f[c-1]} < ${u[c-1]-1};
        bool hasNextRow = ${f[c-2]} < ${u[c-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${R};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${N}
          vec4 candidate = ${R};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${T}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function wR(n,t,e,s=null){let o=t.shape[0],i=t.shape[1];s!=null&&(o=s.shape[0],i=s.shape[1]);const l=Gp(i),u={windowSize:l,inSize:i,batchSize:o,outSize:Math.ceil(i/l)},c=new t7(u,e,s==null),h=[t];s!=null&&h.push(s);const f=n.runWebGLProgram(c,h,"int32");if(f.shape[1]===1)return f;const p=wR(n,t,e,f);return n.disposeIntermediateTensorInfo(f),p}function SR(n,t,e,s=null){const o=s!=null?s.shape:t.shape,i=o[o.length-1],l=Gp(i),u=new e7(o,l,e,s==null),c=s==null?[t]:[t,s],h=n.runWebGLProgram(u,c,"int32");if(h.shape.length===t.shape.length){const f=SR(n,t,e,h);return n.disposeIntermediateTensorInfo(h),f}return h}function CR(n,t,e,s){const o=[e];if(Sn("arg"+s.charAt(0).toUpperCase()+s.slice(1),o,t.shape.length),!lt().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],l=n.texData.get(t.dataId),u=l!==null&&l.isPacked;let c=t;u&&(c=n.unpackTensor(t),i.push(c));const[h,f]=gn(c.shape,o),p=dt(f),g=wt({inputs:{x:c},backend:n,attrs:{shape:[-1,p]}});i.push(g);const x=wR(n,g,s);i.push(x);const b=wt({inputs:{x},backend:n,attrs:{shape:h}});return i.forEach(v=>n.disposeIntermediateTensorInfo(v)),b}return SR(n,t,s)}function n7(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i}=s;let l=qt(i,o.shape);const u=Be(l,o.shape.length);let c=o;const h=[];u!=null&&(c=Un({inputs:{x:o},backend:e,attrs:{perm:u}}),h.push(c),l=qe(l.length,c.shape.length)),Sn("argMax",[l[0]],c.shape.length);const f=CR(e,c,l[0],"max");return h.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}const s7={kernelName:Ff,backendName:"webgl",kernelFunc:n7};function o7(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i}=s;let l=qt(i,o.shape);const u=Be(l,o.shape.length);let c=o;const h=[];u!=null&&(c=Un({inputs:{x:o},backend:e,attrs:{perm:u}}),h.push(c),l=qe(l.length,c.shape.length)),Sn("argMin",[l[0]],c.shape.length);const f=CR(e,c,l[0],"min");return h.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}const a7={kernelName:Mf,backendName:"webgl",kernelFunc:o7};const i7=Ks+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,r7=ee({opSnippet:i7}),l7={kernelName:sc,backendName:"webgl",kernelFunc:r7};const u7=Ks+"return log(x + sqrt(x * x + 1.0));",c7=ee({opSnippet:u7}),h7={kernelName:oc,backendName:"webgl",kernelFunc:c7};const d7=Ks+`
  return atan(x);
`,f7=ee({opSnippet:d7}),p7={kernelName:ac,backendName:"webgl",kernelFunc:f7};const m7=h1+`
  return atan(a, b);
`,g7=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cr+`
  return result;
`,x7=Cn({opSnippet:m7,packedOpSnippet:g7}),b7={kernelName:rc,backendName:"webgl",kernelFunc:x7};const y7=Ks+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,v7=ee({opSnippet:y7}),w7={kernelName:ic,backendName:"webgl",kernelFunc:v7};class Qu{constructor(t,e,s,o=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const l=t.filterWidth,u=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,f=t.dilationWidth,p=t.effectiveFilterHeight,g=t.effectiveFilterWidth,x=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const v=e==="avg",S=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,C=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let $="0.0";if(v||($="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${u}, ${c});
        const ivec2 pads = ivec2(${x}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g};
                wC += ${f}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?i?S:C:`wR * ${g} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const k="max";let T=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(T="avgValue / max(count, 1.0)");const N=Math.floor(l/4)*4,R=l%4,D=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${u}, ${c});
      const ivec2 pads = ivec2(${x}, ${b});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${N}; wC += 4) {
            int xC = xCCorner + wC * ${f};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              getValue(batch, xR, xC + 2 * ${f}, d),
              getValue(batch, xR, xC + 3 * ${f}, d)
            );

            ${D}
          }

          int xC = xCCorner + ${N};
          if (${R===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${D}
          } else if (${R===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              initializationValue,
              initializationValue
            );

            ${D}
          } else if (${R===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              getValue(batch, xR, xC + 2 * ${f}, d),
              initializationValue
            );

            ${D}
          }
        }
        setOutput(${T});
      }
    `}}class f1{constructor(t,e,s,o=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const l=t.filterWidth,u=t.strideDepth,c=t.strideHeight,h=t.strideWidth,f=t.dilationDepth,p=t.dilationHeight,g=t.dilationWidth,x=t.effectiveFilterDepth,b=t.effectiveFilterHeight,v=t.effectiveFilterWidth,S=t.padInfo.front,C=t.padInfo.top,$=t.padInfo.left;this.outputShape=t.outShape;const k=e==="avg";let T="0.0";if(k||(T="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${u}, ${c}, ${h});
        const ivec3 pads = ivec3(${S}, ${C}, ${$});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${x};
              wD += ${f}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${v};
                  wC += ${g}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${b} * ${v} +
                      wR * ${v} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let R=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(R="avgValue / max(count, 1.0)");const D=Math.floor(l/4)*4,z=l%4,O=`
      if (${k}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${u}, ${c}, ${h});
      const ivec3 pads = ivec3(${S}, ${C}, ${$});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${x};
            wD += ${f}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${D}; wC += 4) {
              int xC = xCCorner + wC * ${g};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${g}, ch),
                getValue(batch, xD, xR, xC + 2 * ${g}, ch),
                getValue(batch, xD, xR, xC + 3 * ${g}, ch)
              );

              ${O}
            }

            int xC = xCCorner + ${D};
            if (${z===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${O}
            } else if (${z===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${g}, ch),
                initializationValue,
                initializationValue
              );

              ${O}
            } else if (${z===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${g}, ch),
                getValue(batch, xD, xR, xC + 2 * ${g}, ch),
                initializationValue
              );

              ${O}
            }
          }
        }
        setOutput(${R});
      }
    `}}function S7(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t;ph(o,"avgPool");const{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,h=1;_(Dn(l,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${h}'`);const f=js(o.shape,i,l,h,u,c);if(f.filterWidth===1&&f.filterHeight===1&&ce(f.inShape,f.outShape))return hs({inputs:{x:o},backend:e});const p=new Qu(f,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}const C7={kernelName:zf,backendName:"webgl",kernelFunc:S7};function $7(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{filterSize:i,strides:l,pad:u,dimRoundingMode:c,dataFormat:h}=s,f=[1,1,1],p=fa(o.shape,i,l,f,u,c,h),g=new f1(p,"avg",!1);return e.runWebGLProgram(g,[o],"float32")}const T7={kernelName:Lf,backendName:"webgl",kernelFunc:$7};class k7{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,o=t.strideHeight,i=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=c-1-t.padInfo.top,p=h-1-t.padInfo.left,g=1/(e*s);this.userCode=`
      const ivec2 pads = ivec2(${f}, ${p});
      const float avgMultiplier = float(${g});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${u}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class I7{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,o=t.filterWidth,i=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,f=t.dilationWidth,p=t.effectiveFilterDepth,g=t.effectiveFilterHeight,x=t.effectiveFilterWidth,b=p-1-t.padInfo.front,v=g-1-t.padInfo.top,S=x-1-t.padInfo.left,C=1/(e*s*o);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${v}, ${S});
      const float avgMultiplier = float(${C});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${g};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${l}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${x};
                wC += ${f}) {
              float dyC = float(dyCCorner + wC) / ${u}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function N7(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,input:i}=t,l=i,{filterSize:u,strides:c,pad:h,dimRoundingMode:f}=s,p=[1,1,1],g=fa(l.shape,u,c,p,h,f),x=new I7(g);return e.runWebGLProgram(x,[o],l.dtype)}const E7={kernelName:H0,backendName:"webgl",kernelFunc:N7};function R7(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,input:i}=t,l=i;ph([o,i],"avgPoolGrad");const{filterSize:u,strides:c,pad:h}=s,f=js(l.shape,u,c,1,h),p=new k7(f);return e.runWebGLProgram(p,[o],l.dtype)}const A7={kernelName:W0,backendName:"webgl",kernelFunc:R7};function D7(n){const{inputs:t,backend:e,attrs:s}=n,{a:o,b:i}=t,{transposeA:l,transposeB:u}=s;return Af({a:o,b:i,transposeA:l,transposeB:u,backend:e})}const O7={kernelName:Bf,backendName:"webgl",kernelFunc:D7};class _7{constructor(t,e,s,o,i,l){this.outputShape=[],this.variableNames=["x","mean","variance"],Ut(t,e),Ut(t,s);let u="0.0";o!=null&&(Ut(t,o),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let c="1.0";i!=null&&(Ut(t,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${u};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${l}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class F7{constructor(t,e,s,o,i,l){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ut(t,e),Ut(t,s);let u="vec4(0.0)";o!=null&&(Ut(t,o),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let c="vec4(1.0)";i!=null&&(Ut(t,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${u};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${l}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const M7=({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:o,variance:i,offset:l,scale:u}=n;_(o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),_(l==null||o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),_(u==null||o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=e;c==null&&(c=.001);const h=[s,o,i];let f=null;l!=null&&(f=l.shape,h.push(l));let p=null;u!=null&&(p=u.shape,h.push(u));const g=lt().getBool("WEBGL_PACK_NORMALIZATION")?new F7(s.shape,o.shape,i.shape,f,p,c):new _7(s.shape,o.shape,i.shape,f,p,c);return t.runWebGLProgram(g,h,h[0].dtype)},z7={kernelName:Zf,backendName:"webgl",kernelFunc:M7};class L7{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=ye(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=B7(this.rank);let o;const i=t.map((l,u)=>`sourceLoc.${R0[u]} = start[${u}] + coords.${R0[u]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${s}));
      }
    `}}const R0=["x","y","z","w","u","v"];function B7(n){if(n===1)return"sourceLoc";if(n<=6)return R0.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class U7{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=ye(this.rank),s=Ln("coords",this.rank),o=Ln("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,l=`getChannel(getSource(${o.join()}), ${i})`,u=`
      result.x = ${l};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${l};
        --${o[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${l};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${l};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((f,p)=>`start[${p}]`).join()});`:t.map((f,p)=>`${o[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${u}
        ${c}
        setOutput(result);
      }
    `}}function V7(n,t,e,s){const o=s.texData.get(n.dataId),i=s.makeTensorInfo(e,n.dtype),l=s.texData.get(i.dataId);Object.assign(l,o),l.refCount=1,l.shape=e,l.dtype=n.dtype;let u=ek(t,Rt(n.shape));o.slice&&(u+=o.slice.flatOffset),l.slice={flatOffset:u,origDataId:o.slice&&o.slice.origDataId||n.dataId};const c=s.dataRefCount.get(l.slice.origDataId)||1;return s.dataRefCount.set(l.slice.origDataId,c+1),i}function _l(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{begin:i,size:l}=s,[u,c]=uy(o,i,l);if(QT(o,u,c),dt(c)===0)return e.makeTensorInfo(c,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){const p=e.texData.get(o.dataId),g=OX(p.values,u,c,o.shape,o.dtype);return e.makeTensorInfo(c,o.dtype,g)}const{isPacked:h}=e.texData.get(o.dataId),f=tk(o.shape,u,c);if(h||!f){const p=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new U7(c):new L7(c),g=[u];return e.runWebGLProgram(p,[o],o.dtype,g)}return e.uploadToGPU(o.dataId),V7(o,u,c,e)}const P7={kernelName:kp,backendName:"webgl",kernelFunc:_l};const G7=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{blockShape:i,crops:l}=s;_(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const u=i.reduce(($,k)=>$*k),c=eh(o.shape,i,u),h=nh(c.length,i.length),f=sh(o.shape,i,u),p=fy(l,i.length),g=py(f,l,i.length),x=[],b=wt({inputs:{x:o},backend:e,attrs:{shape:c}}),v=Un({inputs:{x:b},backend:e,attrs:{perm:h}}),S=wt({inputs:{x:v},backend:e,attrs:{shape:f}}),C=_l({inputs:{x:S},backend:e,attrs:{begin:p,size:g}});return x.push(b),x.push(v),x.push(S),x.forEach($=>e.disposeIntermediateTensorInfo($)),C},W7={kernelName:Uf,backendName:"webgl",kernelFunc:G7};function H7(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,weights:i}=t,{size:l}=s,u=e.readSync(o.dataId),c=e.readSync(i.dataId),h=cR(u,c,i.dtype,i.shape,l);return e.makeTensorInfo([l],i.dtype,h)}const q7={kernelName:q0,backendName:"webgl",kernelFunc:H7};const j7=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,X7=`
  return float(int(a.r) & int(b.r));
`;function K7(n){const{inputs:t,backend:e}=n,{a:s,b:o}=t,i=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS"),l=lt().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,o])||l===1){const c=e.texData.get(s.dataId).values,h=e.texData.get(o.dataId).values,[f,p]=sX(s.shape,o.shape,c,h,s.dtype),g=e.makeTensorInfo(p,s.dtype),x=e.texData.get(g.dataId);return x.values=f,g}let u;return i?u=new Dl(j7,s.shape,o.shape,!1):u=new er(X7,s.shape,o.shape),e.runWebGLProgram(u,[s,o],s.dtype)}const Y7={kernelName:j0,backendName:"webgl",kernelFunc:K7};function Z7(n){const{inputs:t,backend:e}=n,{s0:s,s1:o}=t,i=e.readSync(s.dataId),l=e.readSync(o.dataId),u=Ut(Array.from(i),Array.from(l));return e.makeTensorInfo([u.length],"int32",Int32Array.from(u))}const Q7={kernelName:S$,backendName:"webgl",kernelFunc:Z7};const J7="return float(a != b);",$R=Cn({opSnippet:J7,cpuKernelImpl:$X,dtype:"bool"}),t9={kernelName:pp,backendName:"webgl",kernelFunc:$R};function gh(n){const{inputs:t,backend:e}=n,{input:s}=t,o=e.texData.get(s.dataId);return hs({inputs:{x:o.complexTensorInfos.real},backend:e})}const e9={kernelName:bb,backendName:"webgl",kernelFunc:gh};const n9="return float(int(x));";function s9(n,t){const e=new ko(n.shape,n9),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function A0(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{dtype:i}=s;if(i==="complex64"){if(o.dtype==="complex64")return hs({inputs:{x:o},backend:e});const l=pn(o.shape),u=A0({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),c=hi({inputs:{real:u,imag:l},backend:e});return l.dispose(),e.disposeIntermediateTensorInfo(u),c}if(o.dtype==="complex64"){const l=gh({inputs:{input:o},backend:e}),u=A0({inputs:{x:l},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(l),u}if(!x$(o.dtype,i)){const l=hs({inputs:{x:o},backend:e});return{dataId:l.dataId,shape:l.shape,dtype:i}}if(e.shouldExecuteOnCPU([o])){const l=e.texData.get(o.dataId).values,[u,c,h]=oX(l,o.shape,o.dtype,i);return e.makeTensorInfo(u,c,h)}if(i==="int32")return s9(o,e);if(i==="bool"){const l=e.makeTensorInfo([],"bool",En("bool",1)),c=$R({inputs:{a:o,b:l},backend:e});return e.disposeIntermediateTensorInfo(l),c}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${i}`)}const o9={kernelName:lc,backendName:"webgl",kernelFunc:A0};const e$="return ceil(x);",a9=ee({opSnippet:e$,packedOpSnippet:e$,cpuKernelImpl:aX}),i9={kernelName:uc,backendName:"webgl",kernelFunc:a9};class r9{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class l9{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function u9(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{clipValueMin:i,clipValueMax:l}=s;let u;lt().getBool("WEBGL_PACK_CLIP")?u=new l9(o.shape):u=new r9(o.shape);const c=[[i],[l]];return e.runWebGLProgram(u,[o],o.dtype,c)}const c9={kernelName:cc,backendName:"webgl",kernelFunc:u9};class h9{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function n$(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function d9(n){const{inputs:t,backend:e}=n,{x:s}=t,o=e.texData.get(s.dataId),i=new h9(s.shape),l=[n$(s,o.complexTensorInfos.real),n$(s,o.complexTensorInfos.imag)];return e.runWebGLProgram(i,l,l[0].dtype)}const f9={kernelName:Vf,backendName:"webgl",kernelFunc:d9};class p9{constructor(t){this.outputShape=[],this.outputShape=Eo(t,1),this.variableNames=t.map((l,u)=>`T${u}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let l=1;l<e.length;l++)e[l]=e[l-1]+t[l][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let l=1;l<e.length;l++){const u=e[l-1];s.push(`else if (yC < ${e[l]}) setOutput(getT${l}(yR, yC-${u}));`)}const o=e.length,i=e[e.length-1];s.push(`else setOutput(getT${o}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class m9{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Eo(t,e);const s=this.outputShape,o=s.length,i=ye(o),l=Ln("coords",o),u=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((v,S)=>`T${S}`);const c=new Array(t.length-1);c[0]=t[0][e];for(let v=1;v<c.length;v++)c[v]=c[v-1]+t[v][e];const h=u[e],f=u.slice(-2),p=u.join();let g=`if (${h} < ${c[0]}) {
        return getChannel(
            getT0(${p}), vec2(${f.join()}));
        }`;for(let v=1;v<c.length;v++){const S=c[v-1];g+=`
        if (${h} < ${c[v]}  && ${h} >= ${c[v-1]}) {
          return getChannel(
            getT${v}(${qd(u,h,S)}),
            vec2(${qd(f,h,S)}));
        }`}const x=c.length,b=c[c.length-1];g+=`
        return getChannel(
          getT${x}(${qd(u,h,b)}),
          vec2(${qd(f,h,b)}));`,this.userCode=`
      float getValue(${u.map(v=>"int "+v)}) {
        ${g}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${l}), 0., 0., 0.);

        ${l[o-1]} = ${l[o-1]} + 1;
        if (${l[o-1]} < ${s[o-1]}) {
          result.g = getValue(${l});
        }

        ${l[o-2]} = ${l[o-2]} + 1;
        if (${l[o-2]} < ${s[o-2]}) {
          result.a = getValue(${l});
        }

        ${l[o-1]} = ${l[o-1]} - 1;
        if (${l[o-2]} < ${s[o-2]} &&
            ${l[o-1]} < ${s[o-1]}) {
          result.b = getValue(${l});
        }
        setOutput(result);
      }
    `}}function qd(n,t,e){const s=n.indexOf(t);return n.map((i,l)=>l===s?`${i} - ${e}`:i).join()}function lm(n){const{inputs:t,backend:e}=n,{input:s}=t,o=e.texData.get(s.dataId);return hs({inputs:{x:o.complexTensorInfos.imag},backend:e})}const g9={kernelName:cb,backendName:"webgl",kernelFunc:lm};function Lu(n,t,e){const s=n[0].dtype;if(s==="complex64"){const x=n.map($=>gh({inputs:{input:$},backend:e})),b=n.map($=>lm({inputs:{input:$},backend:e})),v=Lu(x,t,e),S=Lu(b,t,e),C=hi({inputs:{real:v,imag:S},backend:e});return x.forEach($=>e.disposeIntermediateTensorInfo($)),b.forEach($=>e.disposeIntermediateTensorInfo($)),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(S),C}let o=e.shouldExecuteOnCPU(n);if(s==="string"&&(o=!0),o){const x=n.map(T=>{const R=[-1,dt(T.shape.slice(t))];return wt({inputs:{x:T},backend:e,attrs:{shape:R}})}),b=x.map(T=>({vals:e.readSync(T.dataId),shape:T.shape})),v=Eo(x.map(T=>T.shape),1),S=x[0].shape[0]===1,C=iX(b,v,s,S),$=Eo(n.map(T=>T.shape),t),k=e.makeTensorInfo($,s,C);return x.forEach(T=>e.disposeIntermediateTensorInfo(T)),k}const i=n.filter(x=>dt(x.shape)>0),l=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const x=l?new ko(n[0].shape,Ua):new Wa(n[0].shape,Ua);return e.runWebGLProgram(x,n,s)}const u=lt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>u){const x=[];for(let v=0;v<i.length;v+=u){const S=i.slice(v,v+u);x.push(Lu(S,t,e))}const b=Lu(x,t,e);for(const v of x)e.disposeIntermediateTensorInfo(v);return b}if(l){const x=new m9(i.map(b=>b.shape),t);return e.runWebGLProgram(x,i,s)}const{tensors2D:c,outShape:h}=x9(i,t,e),f=new p9(c.map(x=>x.shape)),p=e.runWebGLProgram(f,c,s);c.forEach(x=>e.disposeIntermediateTensorInfo(x));const g=wt({inputs:{x:p},attrs:{shape:h},backend:e});return e.disposeIntermediateTensorInfo(p),g}function x9(n,t,e){const s=Eo(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>wt({inputs:{x:i},attrs:{shape:[-1,dt(i.shape.slice(t))]},backend:e})),outShape:s}}function TR(n){const{inputs:t,backend:e,attrs:s}=n,{axis:o}=s,i=qt(o,t[0].shape)[0],l=t.map(h=>h.shape);cy(l,i);const u=Eo(t.map(h=>h.shape),i);if(dt(u)===0)return e.makeTensorInfo(u,t[0].dtype,[]);const c=t.filter(h=>dt(h.shape)>0);return c.length===1?hs({inputs:{x:c[0]},backend:e}):Lu(c,i,e)}const b9={kernelName:Pf,backendName:"webgl",kernelFunc:TR};class kR{constructor(t,e=!1,s=null,o=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const l=t.padInfo.top,u=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,f=t.dilationHeight,p=t.dilationWidth,g=t.filterHeight,x=t.filterWidth,b=Math.floor(t.inChannels/4)*4,v=t.inChannels%4,S=t.dataFormat==="channelsLast",C=S?1:2,$=S?2:3,k=S?3:1;let T="",N="";s&&(o?T=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?T=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:T=`
          float activation(float x) {
            ${s}
          }
        `,N="result = activation(result);");const R=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${T}

      const ivec2 strides = ivec2(${c}, ${h});
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${k}];

        ivec2 xRCCorner =
            ivec2(coords[${C}], coords[${$}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${g}; wR++) {
          int xR = xRCorner + wR * ${f};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${S}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${v===1}) {

              if (${S}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${v===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${S}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${v===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${S}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${R}
        ${N}
        setOutput(result);
      }
    `}}class y9{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,o=t.padInfo.left,i=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,f=t.dilationWidth,p=t.filterDepth,g=t.filterHeight,x=t.filterWidth,b=Math.floor(t.inChannels/4)*4,v=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${l}, ${u});
      const ivec3 pads = ivec3(${e}, ${s}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${x}; wC++) {
              int xC = xCCorner + wC * ${f};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${v===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${v===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${v===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class IR{constructor(t,e=!1,s=null,o=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=_n(this.outputShape.length);const l=t.padInfo.left,u=t.strideWidth,c=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,p=f;let g=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<f;S++)g+=`
           vec4 xTexelC${S*2};
           int xTexelC${S*2}Ready;
           vec4 xTexelC${S*2+1};
           int xTexelC${S*2+1}Ready;
           vec4 xC${S};`;g+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let S=0;S<f;S++)g+=`
           xTexelC${S*2} = vec4(0.0);
           xTexelC${S*2}Ready = 0;
           xTexelC${S*2+1} = vec4(0.0);
           xTexelC${S*2+1}Ready = 0;
           xC${S} = vec4(0.0);`;g+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let S=0;S<(p+1)/2;S++){const C=S*2;if(g+=`
           xC = xCCorner + ${C*c};
           `,u===1){if(C<f&&(l%2===1?(g+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                   xTexelC${C} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${C}.zw = vec2(0.0);
                   }
                   xTexelC${C}Ready = 1;
                 }
               `,c===1&&C>0?g+=`
                 xC${C} = vec4(xTexelC${C-2}.zw, xTexelC${C}.xy);
                 `:g+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${C} = vec4(previous.zw, xTexelC${C}.xy);
                   } else {
                     xC${C} = vec4(0.0, 0.0, xTexelC${C}.xy);
                   }
                   `):g+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                   xTexelC${C} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${C}.zw = vec2(0.0);
                   }
                   xTexelC${C}Ready = 1;
                 }

                 xC${C} = xTexelC${C};
                 `,C+1<f)){const $=l%2===0?M0(c):c;c%2===0&&l%2===1||c%2!==0&&l%2!==1?(g+=`
                   xCOffset = xC + imod(pads[1], 2) + ${$};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                     xTexelC${C+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${C+1}.zw = vec2(0.0);
                     }
                     xTexelC${C+1}Ready = 1;
                   }
                   `,c>1?g+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${C+1} = vec4(previous.zw, xTexelC${C+1}.xy);
                     } else {
                      xC${C+1} = vec4(0.0, 0.0, xTexelC${C+1}.xy);
                     }
                     `:g+=`
                     xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.xy);
                     `):$===1?g+=`
                     xC${C+1} = xTexelC${C};
                     `:g+=`
                     xCOffset = xC + ${$};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                       xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${C+1}.zw = vec2(0.0);
                       }
                       xTexelC${C+1}Ready = 1;
                     }

                     xC${C+1} = xTexelC${C+1};
                     `}}else C<f&&(l%2===1?(g+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                   xTexelC${C} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${C}.zw = vec2(0.0);
                   }
                   xTexelC${C}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${C+1}Ready == 0) {
                   xTexelC${C+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${C+1}.zw = vec2(0.0);
                   }
                   xTexelC${C+1}Ready = 1;
                 }

                 xC${C} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
               `,C+1<f&&(g+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${C+1} = vec4(xTexelC${C+1}.xy, final.xy);
                 `)):(g+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                   xTexelC${C} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${C}.zw = vec2(0.0);
                   }
                   xTexelC${C}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                   xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${C+1}.zw = vec2(0.);
                   }
                   xTexelC${C+1}Ready = 1;
                 }

                 xC${C} = vec4(
                   xTexelC${C}.xy, xTexelC${C+1}.xy);
               `,C+1<f&&(g+=`
                   xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
                 `)));C<f&&(g+=`
             wTexel = getW(r, ${C}, d1, d2);
             dotProd += xC${C}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${C}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,C+1<f&&(g+=`
               wTexel = getW(r, ${C+1}, d1, d2);
               dotProd += xC${C+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${C+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}g+=`
     }
   `,g+=`
     }
   `,g+=`
     }
   `;let x="",b="";s&&(o?x=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?x=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:x=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const v=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${x}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${g}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${v}
         ${b}
         setOutput(result);
       }
     `}}class v9{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=_n(this.outputShape.length);const{dataFormat:s}=e,o=Vn(),i=s==="channelsLast",l=i?1:2,u=i?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let h="";for(let f=0;f<=1;f++)for(let p=0;p<=1;p++)h+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${f};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${l}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${u}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${f*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${f*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${o.output} = result;
      }
    `}}function Df(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function NR({x:n,filter:t,convInfo:e,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:l=0,activation:u=null}){const c=n.shape,h=s.texData.get(n.dataId),f=e.inChannels,p=c[0]*c[1]*c[2],g=e.outChannels,x=e.dataFormat==="channelsLast",b=!1,v=!1;let S;const C=[];if(i!=null){const T=Df(i.shape,x);T!=null&&(i=wt({inputs:{x:i},backend:s,attrs:{shape:T}}),C.push(i))}if(o!=null){const T=Df(o.shape,x);T!=null&&(o=wt({inputs:{x:o},backend:s,attrs:{shape:T}}),C.push(o))}if(!((p===1||g===1)&&f>vR)&&h.isPacked&&x&&h.texture!=null&&c[2]%2!==0&&ce(h.shape.slice(-3),c.slice(-3))){const T=c[0]*c[1]*(c[2]+1),N={dataId:n.dataId,shape:[1,T,e.inChannels],dtype:n.dtype},R=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,_(Rf(h.shape,N.shape),()=>`packed reshape ${h.shape} to ${N.shape} isn't free`);const D=wt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});C.push(D);const z=Af({a:N,b:D,backend:s,transposeA:b,transposeB:v,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:l}),O=s.texData.get(z.dataId);_(O.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=R,O.shape=e.outShape,S=hs({inputs:{x:z},backend:s}),S.shape=e.outShape,C.push(z)}else{const T=e.outHeight*e.outWidth,N=wt({inputs:{x:n},backend:s,attrs:{shape:x?[e.batchSize,T,e.inChannels]:[e.batchSize,e.inChannels,T]}}),R=wt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),D=Af({a:x?N:R,b:x?R:N,transposeA:!x,transposeB:v,backend:s,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:l});S=wt({inputs:{x:D},backend:s,attrs:{shape:e.outShape}}),C.push(N),C.push(R),C.push(D)}for(const T of C)s.disposeIntermediateTensorInfo(T);return S}function ER({x:n,filter:t,convInfo:e,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:l=0,activation:u=null}){const{filterWidth:c,filterHeight:h,inChannels:f,outWidth:p,outHeight:g,dataFormat:x}=e,b=x==="channelsLast",v=c*h*f,S=g*p,C=[e.batchSize,v,S],$=!0,k=!1,T=[];if(i!=null){const W=Df(i.shape,b);W!=null&&(i=wt({inputs:{x:i},backend:s,attrs:{shape:W}}),T.push(i))}if(o!=null){const W=Df(o.shape,b);W!=null&&(o=wt({inputs:{x:o},backend:s,attrs:{shape:W}}),T.push(o))}const N=wt({inputs:{x:t},backend:s,attrs:{shape:[1,v,dt(t.shape)/v]}});T.push(N);const R=new v9(C,e),D=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],z=s.runWebGLProgram(R,[n],"float32",D),O=wt({inputs:{x:z},backend:s,attrs:{shape:C}});T.push(z),T.push(O);const F=o!=null,E=i!=null,U=u==="leakyrelu",Y=u?Zu(u,!0):null,X=new yR(b?O.shape:N.shape,b?N.shape:O.shape,b?[e.batchSize,S,e.outChannels]:[e.batchSize,e.outChannels,S],$,k,F,Y,E,U),q=b?[O,N]:[N,O];if(o&&q.push(o),E&&q.push(i),U){const W=s.makeTensorInfo([],"float32",ni(l,"float32"));q.push(W),T.push(W)}const L=s.runWebGLProgram(X,q,"float32"),P=wt({inputs:{x:L},backend:s,attrs:{shape:e.outShape}});T.push(L);for(const W of T)s.disposeIntermediateTensorInfo(W);return P}function w9(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:f}=s,p=pa(c),g=wn(o.shape,i.shape,l,h,u,f,!1,p);let x;if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=NR({x:o,filter:i,convInfo:g,backend:e});else if(g.strideWidth<=2&&p==="channelsLast"&&lt().getBool("WEBGL_EXP_CONV")){const v=new IR(g),S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]];x=e.runWebGLProgram(v,[o,i],"float32",S)}else if(lt().getBool("WEBGL_CONV_IM2COL"))x=ER({x:o,filter:i,convInfo:g,backend:e});else{const v=new kR(g);x=e.runWebGLProgram(v,[o,i],"float32")}const b=wt({inputs:{x},backend:e,attrs:{shape:g.outShape}});return e.disposeIntermediateTensorInfo(x),b}const S9={kernelName:Gf,backendName:"webgl",kernelFunc:w9};class C9{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,o=t.padInfo.top,i=t.padInfo.left,l=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${l?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $9{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,o=t.strideHeight,i=t.strideWidth,l=t.dataFormat==="channelsLast",u=e-1-t.padInfo.top,c=s-1-t.padInfo.left,h=l?1:2,f=l?2:3,p=l?3:1;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${f}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${l}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class T9{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.padInfo.front,l=t.padInfo.top,u=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${l};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${u};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class k9{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,o=t.filterWidth,i=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=e-1-t.padInfo.front,h=s-1-t.padInfo.top,f=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${h}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${l}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${u}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function I9(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,dy:i}=t,{strides:l,pad:u,dataFormat:c,dimRoundingMode:h,filterShape:f}=s,p=pa(c),g=wn(o.shape,f,l,1,u,h,!1,p),x=new C9(g);return e.runWebGLProgram(x,[o,i],"float32")}const N9={kernelName:K0,backendName:"webgl",kernelFunc:I9};class E9{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=_n(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth,o=e-1-t.padInfo.top,i=s-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function R9(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,filter:i}=t,{inputShape:l,strides:u,pad:c,dataFormat:h,dimRoundingMode:f}=s,p=pa(h),g=wn(l,i.shape,u,1,c,f,!1,p);if(lt().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const x=[[g.strideHeight,g.strideWidth]],b=new E9(g);return e.runWebGLProgram(b,[o,i],"float32",x)}else{const x=new $9(g);return e.runWebGLProgram(x,[o,i],"float32")}}const A9={kernelName:Wf,backendName:"webgl",kernelFunc:R9};function D9(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i}=t,{strides:l,pad:u,dilations:c}=s,h=oi(o.shape,i.shape,l,c,u),f=new y9(h);return e.runWebGLProgram(f,[o,i],"float32")}const O9={kernelName:Hf,backendName:"webgl",kernelFunc:D9};function _9(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,dy:i}=t,{strides:l,pad:u,filterShape:c}=s,h=oi(o.shape,c,l,1,u),f=new T9(h);return e.runWebGLProgram(f,[o,i],"float32")}const F9={kernelName:Y0,backendName:"webgl",kernelFunc:_9};function M9(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,filter:i}=t,{pad:l,strides:u,inputShape:c}=s,h=oi(c,i.shape,u,1,l),f=new k9(h);return e.runWebGLProgram(f,[o,i],"float32")}const z9={kernelName:Z0,backendName:"webgl",kernelFunc:M9};const L9=Ol+`
  return cos(x);
`,B9=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${cr}
  return result;
`,U9=ee({opSnippet:L9,packedOpSnippet:B9}),V9={kernelName:hc,backendName:"webgl",kernelFunc:U9};const P9=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,G9=ee({opSnippet:P9}),W9={kernelName:dc,backendName:"webgl",kernelFunc:G9};class H9{constructor(t,e,s,o,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[l,u,c,h]=t,[f]=e,[p,g]=s;this.outputShape=[f,p,g,h];const x=o==="bilinear"?1:0,[b,v]=[`${u-1}.0`,`${c-1}.0`],[S,C,$]=p>1?[`${(u-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[k,T,N]=g>1?[`${(c-1)/(g-1)}`,"(x2-x1) * width_ratio",`x1*${v} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${v}`];this.userCode=`
      const float height_ratio = float(${S});
      const float width_ratio = float(${k});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${l}) {
          return;
        }

        float height_scale = ${C};
        float width_scale = ${T};

        float in_y = ${$};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${N};
        if( in_x < 0.0 || in_x > ${v} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${x} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const q9=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:o,boxes:i,boxInd:l}=t,{cropSize:u,method:c,extrapolationValue:h}=s,f=new H9(o.shape,i.shape,u,c,h);return e.runWebGLProgram(f,[o,i,l],"float32")},j9={kernelName:J0,backendName:"webgl",kernelFunc:q9};var Ju;(function(n){n.Prod="*",n.Sum="+"})(Ju||(Ju={}));class s${constructor(t,e,s,o){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,l=this.op===Ju.Prod?"1.0":"0.0",u=s?l:`getX(${o$(i,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let h="",f="";s?(h=o?`end != ${c-1}`:"end != 0",f=o?"end + 1":"end - 1"):(h=o?`end + pow2 < ${c}`:"end >= pow2",f=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ye(i)} coords = getOutputCoords();
        int end = ${a$(i,"coords",this.op)};
        float val = ${u};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${f};
          ${a$(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${o$(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function o$(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function a$(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function RR(n,t,e,s,o,i){const l=t.shape.length,u=Be([s],l);let c=t;u!=null&&(c=Un({inputs:{x:t},backend:e,attrs:{perm:u}}));const h=qe(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const f=c.shape[h];let p=hs({inputs:{x:c},backend:e});for(let g=0;g<=Math.ceil(Math.log2(f))-1;g++){const x=new s$(n,c.shape,!1,i),b=[[g]],v=p;p=e.runWebGLProgram(x,[p],p.dtype,b),e.disposeIntermediateTensorInfo(v)}if(o){const g=new s$(n,c.shape,o,i),x=p;p=e.runWebGLProgram(g,[p],p.dtype),e.disposeIntermediateTensorInfo(x)}if(u!=null){const g=ai(u),x=Un({inputs:{x:p},backend:e,attrs:{perm:g}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(c),x}return p}function X9(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,exclusive:l,reverse:u}=s;return RR(Ju.Prod,o,e,i,l,u)}const K9={kernelName:Q0,backendName:"webgl",kernelFunc:X9};function Y9(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,exclusive:l,reverse:u}=s;return RR(Ju.Sum,o,e,i,l,u)}const Z9={kernelName:qf,backendName:"webgl",kernelFunc:Y9};function Q9(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,weights:i}=t,{size:l,binaryOutput:u}=s;if(o.shape.length===1){const c=e.readSync(o.dataId),h=e.readSync(i.dataId),f=cR(c,h,i.dtype,i.shape,l);return e.makeTensorInfo([l],i.dtype,f)}else if(o.shape.length===2){const c=e.bufferSync(o),h=e.bufferSync(i),f=nX(c,h,l,u);return e.makeTensorInfo(f.shape,i.dtype,f.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}const J9={kernelName:tb,backendName:"webgl",kernelFunc:Q9};class tY{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function eY(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{blockSize:i,dataFormat:l}=s,u=o.shape[0],c=l==="NHWC"?o.shape[1]:o.shape[2],h=l==="NHWC"?o.shape[2]:o.shape[3],f=l==="NHWC"?o.shape[3]:o.shape[1],p=c*i,g=h*i,x=f/(i*i),b=l==="NHWC"?[u,p,g,x]:[u,x,p,g],v=new tY(b,i,l);return e.runWebGLProgram(v,[o],o.dtype)}const nY={kernelName:eb,backendName:"webgl",kernelFunc:eY};class AR{constructor(t,e=!1,s=null,o=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=_n(this.outputShape.length);const l=t.filterHeight,u=t.filterWidth,c=t.outChannels/t.inChannels;let h="",f="";s&&(o?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,f="result = activation(result);");const p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${l}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${u}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${f}
        setOutput(result);
      }
    `}}class DR{constructor(t,e=!1,s=null,o=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=_n(this.outputShape.length);const l=t.outChannels/t.inChannels,u=t.padInfo.left,c=t.strideWidth,h=t.dilationWidth,f=t.filterHeight,p=t.filterWidth,g=p;let x=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let C=0;C<p;C++)x+=`
          vec4 xTexelC${C*2};
          int xTexelC${C*2}Ready;
          vec4 xTexelC${C*2+1};
          int xTexelC${C*2+1}Ready;
          vec4 xC${C};`;x+=`
    for (int r = 0; r < ${f}; r++) {
      `;for(let C=0;C<p;C++)x+=`
          xTexelC${C*2} = vec4(0.0);
          xTexelC${C*2}Ready = 0;
          xTexelC${C*2+1} = vec4(0.0);
          xTexelC${C*2+1}Ready = 0;
          xC${C} = vec4(0.0);`;x+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let C=0;C<(g+1)/2;C++){const $=C*2;if(x+=`
          xC = xCCorner + ${$*h};
          `,c===1){if($<p&&(u%2===1?(x+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,h===1&&$>0?x+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:x+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):x+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<p)){const k=u%2===0?M0(h):h;h%2===0&&u%2===1||h%2!==0&&u%2!==1?(x+=`
                  xCOffset = xC + imod(pads[1], 2) + ${k};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,h>1?x+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${$+1} = vec4(previous.zw, xTexelC${$+1}.xy);
                    } else {
                     xC${$+1} = vec4(0.0, 0.0, xTexelC${$+1}.xy);
                    }
                    `:x+=`
                    xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                    `):k===1?x+=`
                    xC${$+1} = xTexelC${$};
                    `:x+=`
                    xCOffset = xC + ${k};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<p&&(u%2===1?(x+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<p&&(x+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(x+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<p&&(x+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<p&&(x+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<p&&(x+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}x+=`
    }
  `,x+=`
      }
    `;let b="",v="";s&&(o?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,v="result = activation(result);");const S=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${x}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${S}
        ${v}
        setOutput(result);
      }
    `}}function sY(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h}=s;let f=c;f==null&&(f=[1,1]),_(Dn(l,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`);const p=wn(o.shape,i.shape,l,f,u,h,!0);let g;lt().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?g=new DR(p):g=new AR(p);const x=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(g,[o,i],"float32",x)}const oY={kernelName:jf,backendName:"webgl",kernelFunc:sY};class aY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,o=t.padInfo.top,i=t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${l} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class iY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,o=t.strideHeight,i=t.strideWidth,l=e-1-t.padInfo.top,u=s-1-t.padInfo.left,c=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function rY(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,dy:i}=t,{strides:l,dilations:u,pad:c,dimRoundingMode:h,filterShape:f}=s,p=wn(o.shape,f,l,u,c,h,!0),g=new aY(p);return e.runWebGLProgram(g,[o,i],"float32")}const lY={kernelName:nb,backendName:"webgl",kernelFunc:rY};function uY(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,filter:i}=t,{strides:l,dilations:u,pad:c,dimRoundingMode:h,inputShape:f}=s,p=wn(f,i.shape,l,u,c,h,!0),g=new iY(p);return e.runWebGLProgram(g,[o,i],"float32")}const cY={kernelName:sb,backendName:"webgl",kernelFunc:uY};class hY{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function dY(n){const{inputs:t,backend:e}=n,{x:s}=t,o=[...s.shape,...s.shape],i=dt(s.shape),l=wt({inputs:{x:s},backend:e,attrs:{shape:[i]}}),u=new hY(i),c=e.runWebGLProgram(u,[l],l.dtype),h=wt({inputs:{x:c},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),h}const fY={kernelName:C$,backendName:"webgl",kernelFunc:dY};class pY{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:o,strideHeight:i,strideWidth:l,filterHeight:u,filterWidth:c,dilationHeight:h,dilationWidth:f}=t,{top:p,left:g}=o;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${p}, ${g});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${u}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${f};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function mY(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i}=t,{strides:l,pad:u,dilations:c}=s,h=Yc(o.shape,i.shape,l,u,"NHWC",c);let f;const p=new pY(h);f=e.runWebGLProgram(p,[o,i],"float32");const g=wt({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),g}const gY={kernelName:Xf,backendName:"webgl",kernelFunc:mY};function xY(n){const{inputs:t,backend:e,attrs:s}=n,{equation:o}=s,i=t,{allDims:l,summedDims:u,idDims:c}=Sy(o,i.length);$y(l.length,c,i);const{path:h,steps:f}=Ty(u,c),p=f.length;let g=null,x=l.length;const b=[];for(let v=0;v<p;++v){for(const S of f[v]){const{permutationIndices:C,expandDims:$}=Cy(x,c[S]);let k;ky(C)?k=i[S]:(k=Un({inputs:{x:i[S]},backend:e,attrs:{perm:C}}),b.push(k));const T=k.shape.slice();for(let N=0;N<$.length;++N)T.splice($[N],0,1);ce(k.shape,T)||(k=wt({inputs:{x:k},backend:e,attrs:{shape:T}}),b.push(k)),g===null?g=k:(g=d1({inputs:{a:k,b:g},backend:e}),b.push(g))}v<p-1&&(h[v]>=0&&(g=rm({inputs:{x:g},backend:e,attrs:{axis:h[v]-(l.length-x),keepDims:!1}}),b.push(g)),x--)}for(const v of b)v!==g&&e.disposeIntermediateTensorInfo(v);return g}const bY={kernelName:ob,backendName:"webgl",kernelFunc:xY};const yY="return (x >= 0.0) ? x : (exp(x) - 1.0);",vY=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,wY=ee({opSnippet:yY,packedOpSnippet:vY}),SY={kernelName:pc,backendName:"webgl",kernelFunc:wY};const CY="return (b >= 0.0) ? a : a * (b + 1.0);",$Y=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,TY=n=>{const{inputs:t,backend:e}=n,{dy:s,y:o}=t,i=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Dl($Y,s.shape,o.shape):new er(CY,s.shape,o.shape);return e.runWebGLProgram(i,[s,o],s.dtype)},kY={kernelName:ab,backendName:"webgl",kernelFunc:TY};const IY=`
  return vec4(equal(a, b));
`,NY="return float(a == b);",EY=Cn({opSnippet:NY,packedOpSnippet:IY,dtype:"bool",cpuKernelImpl:rX}),RY={kernelName:Kf,backendName:"webgl",kernelFunc:EY};const AY=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${my};
  float a1 = ${gy};
  float a2 = ${xy};
  float a3 = ${by};
  float a4 = ${yy};
  float a5 = ${vy};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,DY=ee({opSnippet:AY}),OY={kernelName:mc,backendName:"webgl",kernelFunc:DY};const _Y=Ol+`
  return exp(x);
`,FY=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,OR=ee({opSnippet:_Y,packedOpSnippet:FY,cpuKernelImpl:lX,dtype:"float32"}),MY={kernelName:gc,backendName:"webgl",kernelFunc:OR};function D0(n){const{inputs:t,attrs:e,backend:s}=n,{dim:o}=e,{input:i}=t,l=i.shape.length,u=i.shape.slice();let c=o;return o<0&&(_(-(l+1)<=o,()=>`Axis must be in the interval [${-(l+1)}, ${l}]`),c=l+o+1),u.splice(c,0,1),wt({inputs:{x:i},backend:s,attrs:{shape:u}})}const zY={kernelName:Yf,backendName:"webgl",kernelFunc:D0};const i$="return exp(x) - 1.0;",LY=ee({opSnippet:i$,packedOpSnippet:i$,cpuKernelImpl:uX}),BY={kernelName:xc,backendName:"webgl",kernelFunc:LY};class r${constructor(t,e,s){this.variableNames=["real","imag"];const o=e[1];this.outputShape=e;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,l=s?`${o}.0`:"1.0";let u;if(t==="real")u="return real * expR - imag * expI;";else if(t==="imag")u="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${u}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${l};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function _R(n,t,e){const s=e.texData.get(n.dataId),o=dt(n.shape),i=n.shape[n.shape.length-1],l=o/i,u=wt({inputs:{x:n},backend:e,attrs:{shape:[l,i]}}),c=u.shape,h=new r$("real",c,t),f=new r$("imag",c,t),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],g=e.runWebGLProgram(h,p,"float32"),x=e.runWebGLProgram(f,p,"float32"),b=hi({inputs:{real:g,imag:x},backend:e});e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x);const v=wt({inputs:{x:b},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(b),v}function UY(n){const{inputs:t,backend:e}=n,{input:s}=t;return _R(s,!1,e)}const VY={kernelName:ib,backendName:"webgl",kernelFunc:UY};class PY{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function xh(n){const{backend:t,attrs:e}=n,{shape:s,value:o}=e;let{dtype:i}=e;if(i=i||yl(o),i==="string"){const l=Ge(i,dt(s));return l.fill(o),t.makeTensorInfo(s,i,l)}else{const l=new PY(s,o),u=[[o]];return t.runWebGLProgram(l,[],i,u)}}const GY={kernelName:rb,backendName:"webgl",kernelFunc:xh};class WY{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const HY={kernelName:lb,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,o=new WY(e.shape);return s.runWebGLProgram(o,[e],e.dtype)}};const l$="return floor(x);",qY=ee({opSnippet:l$,packedOpSnippet:l$,cpuKernelImpl:cX}),jY={kernelName:bc,backendName:"webgl",kernelFunc:qY};const XY=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,KY=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,YY=Cn({opSnippet:XY,packedOpSnippet:KY,dtype:"int32"}),ZY={kernelName:yc,backendName:"webgl",kernelFunc:YY};class QY{constructor(t){this.variableNames=["A"];const e=Vn(),[s,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class JY{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Vn(),[s,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}const tZ={kernelName:KO,backendName:"webgl",kernelFunc:eZ};let Qr,Xx=lt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function eZ(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:o}=t;const{numChannels:i}=s,l=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,u=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[c,h]=l?[o.videoWidth,o.videoHeight]:[o.width,o.height],f=[h,c],p=[h,c,i];if(u||l){const v=lt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Qr==null||v!==Xx)&&(Xx=v,Qr=document.createElement("canvas").getContext("2d",{willReadFrequently:Xx})),Qr.canvas.width=c,Qr.canvas.height=h,Qr.drawImage(o,0,0,c,h),o=Qr.canvas}const g=e.makeTensorInfo(f,"int32");e.texData.get(g.dataId).usage=Cs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(g.dataId),o);const x=lt().getBool("WEBGL_PACK")?new JY(p):new QY(p),b=e.runWebGLProgram(x,[g],"int32");return e.disposeData(g.dataId),b}function nZ(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i,bias:l,preluActivationWeights:u}=t,{strides:c,pad:h,dataFormat:f,dilations:p,dimRoundingMode:g,activation:x,leakyreluAlpha:b}=s,v=pa(f),S=wn(o.shape,i.shape,c,p,h,g,!1,v);let C;const $=[],k=l!=null,T=u!=null,N=x==="leakyrelu",R=()=>{const z=[o,i],O=(F,E)=>{if(E==="NCHW"&&F.shape.length===1&&F.shape[0]!==1){const U=wt({inputs:{x:F},backend:e,attrs:{shape:[F.shape[0],1,1]}});return $.push(U),U}return F};if(k&&z.push(O(l,f)),T&&z.push(O(u,f)),N){const F=e.makeTensorInfo([],"float32",ni(b,"float32"));z.push(F),$.push(F)}return z};if(S.filterHeight===1&&S.filterWidth===1&&S.dilationHeight===1&&S.dilationWidth===1&&S.strideHeight===1&&S.strideWidth===1&&(S.padInfo.type==="SAME"||S.padInfo.type==="VALID"))C=NR({x:o,filter:i,convInfo:S,backend:e,bias:l,activation:x,preluActivationWeights:u,leakyreluAlpha:b});else if(S.strideWidth<=2&&v==="channelsLast"&&lt().getBool("WEBGL_EXP_CONV")){const z=x?Zu(x,!0):null,O=new IR(S,k,z,T,N),F=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],E=R();C=e.runWebGLProgram(O,E,"float32",F)}else if(lt().getBool("WEBGL_CONV_IM2COL"))C=ER({x:o,filter:i,convInfo:S,backend:e,bias:l,activation:x,preluActivationWeights:u,leakyreluAlpha:b});else{const z=x?Zu(x,!1):null,O=new kR(S,k,z,T,N),F=R();C=e.runWebGLProgram(O,F,"float32")}const D=wt({inputs:{x:C},backend:e,attrs:{shape:S.outShape}});return $.push(C),$.forEach(z=>e.disposeIntermediateTensorInfo(z)),D}const sZ={kernelName:af,backendName:"webgl",kernelFunc:nZ};function oZ(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,filter:i,bias:l,preluActivationWeights:u}=t,{strides:c,pad:h,dilations:f,dimRoundingMode:p,activation:g,leakyreluAlpha:x}=s,b=[];let v=f;v==null&&(v=[1,1]),_(Dn(c,v),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${v}'`);const S=wn(o.shape,i.shape,c,v,h,p,!0),C=lt().getBool("WEBGL_PACK_DEPTHWISECONV")&&S.strideWidth<=2&&S.outChannels/S.inChannels===1,$=g?Zu(g,C):null,k=[o,i],T=l!=null,N=u!=null,R=g==="leakyrelu";if(T&&k.push(l),N&&k.push(u),R){const F=e.makeTensorInfo([],"float32",ni(x,"float32"));k.push(F),b.push(F)}let D;C?D=new DR(S,T,$,N,R):D=new AR(S,T,$,N,R);const z=[[S.padInfo.top,S.padInfo.left],[S.strideHeight,S.strideWidth],[S.dilationHeight,S.dilationWidth],[S.inHeight,S.inWidth]],O=e.runWebGLProgram(D,k,"float32",z);return b.forEach(F=>e.disposeIntermediateTensorInfo(F)),O}const aZ={kernelName:P$,backendName:"webgl",kernelFunc:oZ};class iZ{constructor(t,e,s,o){this.sliceDim=t,this.strides=e,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=s;const i=ye(s.length);let l=`
    int index;`;for(let u=0;u<this.sliceDim;u++)l+=`
          index = round(getIndices(coords[0], ${u}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[u]};
          flattenIndex += index * ${this.strides[u]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${l}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function rZ(n){const{inputs:t,backend:e}=n,{params:s,indices:o}=t,i=o.shape,l=i[i.length-1],u=dt(s.shape),[c,h,f,p]=ly(s,o),g=wt({inputs:{x:o},backend:e,attrs:{shape:[h,l]}}),x=wt({inputs:{x:s},backend:e,attrs:{shape:[dt(s.shape)/f,f]}});if(e.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const C=e.readSync(o.dataId),$=e.bufferSync(s),k=hX(C,$,s.dtype,h,l,f,p,s.shape,u);return e.makeTensorInfo(c,s.dtype,k.values)}const b=new iZ(l,p,[h,f],s.shape),v=e.runWebGLProgram(b,[x,g],x.dtype),S=wt({inputs:{x:v},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(v),S}const lZ={kernelName:$$,backendName:"webgl",kernelFunc:rZ};class uZ{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=ye(this.rank),o=cZ(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}}function cZ(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let o=0;o<n.length;o++)o===2?s.push("index"):s.push(`${e[o]}`);return s.join()}function FR(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,indices:i}=t,{axis:l,batchDims:u}=s,c=qt(l,o.shape)[0];if(lt().get("DEBUG")){const $=e.readSync(i.dataId),k=o.shape[c];for(let T=0;T<$.length;++T){const N=$[T];_(N<=k-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${k-1}]`)}}const h=Tk(o,i,c,u),f=dt(i.shape),p=[],g=wt({inputs:{x:o},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),x=wt({inputs:{x:i},backend:e,attrs:{shape:[h.batchSize,f/h.batchSize]}});p.push(g),p.push(x);const b=[h.batchSize,h.outerSize,f/h.batchSize,h.sliceSize];if(e.shouldExecuteOnCPU([o,i])||o.dtype==="string"){const $=e.bufferSync(x),k=e.bufferSync(g),T=dX(k,$,b);return p.forEach(N=>e.disposeIntermediateTensorInfo(N)),e.makeTensorInfo(h.outputShape,T.dtype,T.values)}const v=new uZ(g.shape,b),S=e.runWebGLProgram(v,[g,x],g.dtype);p.push(S);const C=wt({inputs:{x:S},backend:e,attrs:{shape:h.outputShape}});return p.forEach($=>e.disposeIntermediateTensorInfo($)),C}const hZ={kernelName:Qf,backendName:"webgl",kernelFunc:FR};const dZ="return float(a > b);",fZ=`
  return vec4(greaterThan(a, b));
`,pZ=Cn({opSnippet:dZ,packedOpSnippet:fZ,cpuKernelImpl:fX,dtype:"bool"}),mZ={kernelName:Jf,backendName:"webgl",kernelFunc:pZ};const gZ="return float(a >= b);",xZ=`
  return vec4(greaterThanEqual(a, b));
`,bZ=Cn({opSnippet:gZ,packedOpSnippet:xZ,dtype:"bool",cpuKernelImpl:pX}),yZ={kernelName:vc,backendName:"webgl",kernelFunc:bZ};function vZ(n){const{inputs:t,backend:e}=n,{input:s}=t;return _R(s,!0,e)}const wZ={kernelName:ub,backendName:"webgl",kernelFunc:vZ};const SZ="return float(!isnan(x) && !isinf(x));",CZ=ee({opSnippet:SZ,dtype:"bool"}),$Z={kernelName:Sc,backendName:"webgl",kernelFunc:CZ};const TZ="return float(isinf(x));",kZ=ee({opSnippet:TZ,dtype:"bool"}),IZ={kernelName:Cc,backendName:"webgl",kernelFunc:kZ};const NZ="return float(isnan(x));",EZ=ee({opSnippet:NZ,dtype:"bool"}),RZ={kernelName:$c,backendName:"webgl",kernelFunc:EZ};const AZ="return float(a < b);",DZ=`
  return vec4(lessThan(a, b));
`,OZ=Cn({opSnippet:AZ,packedOpSnippet:DZ,cpuKernelImpl:mX,dtype:"bool"}),_Z={kernelName:ep,backendName:"webgl",kernelFunc:OZ};const FZ="return float(a <= b);",MZ=`
  return vec4(lessThanEqual(a, b));
`,zZ=Cn({opSnippet:FZ,packedOpSnippet:MZ,cpuKernelImpl:gX,dtype:"bool"}),LZ={kernelName:np,backendName:"webgl",kernelFunc:zZ};function BZ(n){const{backend:t,attrs:e}=n,{start:s,stop:o,num:i}=e,l=xX(s,o,i);return t.makeTensorInfo([l.length],"float32",l)}const UZ={kernelName:T$,backendName:"webgl",kernelFunc:BZ};const VZ=Ol+`
  return x < 0.0 ? 0./0. : log(x);
`,PZ=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,GZ=ee({opSnippet:VZ,packedOpSnippet:PZ,cpuKernelImpl:bX}),WZ={kernelName:Tc,backendName:"webgl",kernelFunc:GZ};const HZ=Ol+`
  return log(1.0 + x);
`,qZ=ee({opSnippet:HZ}),jZ={kernelName:kc,backendName:"webgl",kernelFunc:qZ};const XZ="return float(a >= 1.0 && b >= 1.0);",KZ=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,YZ=Cn({opSnippet:XZ,packedOpSnippet:KZ,dtype:"bool"}),ZZ={kernelName:sp,backendName:"webgl",kernelFunc:YZ};const QZ="return float(!(x >= 1.0));",JZ=ee({opSnippet:QZ}),tQ={kernelName:op,backendName:"webgl",kernelFunc:JZ};const eQ="return float(a >= 1.0 || b >= 1.0);",nQ=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,sQ=Cn({opSnippet:eQ,packedOpSnippet:nQ,dtype:"bool"}),oQ={kernelName:ap,backendName:"webgl",kernelFunc:sQ};class aQ{constructor(t,e,s,o,i){this.variableNames=["x"],this.outputShape=[];const l=e,u=t[3]-1;this.outputShape=t;let c;const h=`float(${s}) + float(${o}) * sum`;i===.5?c=`inversesqrt(${h})`:i===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${l}; j <= ${l}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${u}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}class iQ{constructor(t,e,s,o,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const l=e,u=t[3]-1;this.outputShape=t;let c;const h=`float(${s}) + float(${o}) * sum`;i===.5?c=`inversesqrt(${h})`:i===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${l};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${l}; j <= ${l}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${u}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}const rQ=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=s,h=lt().getBool("WEBGL_PACK_NORMALIZATION")?new iQ(o.shape,i,l,u,c):new aQ(o.shape,i,l,u,c);return e.runWebGLProgram(h,[o],o.dtype)},lQ={kernelName:ip,backendName:"webgl",kernelFunc:rQ};class uQ{constructor(t,e,s,o,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=o,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const cQ=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:o,y:i,dy:l}=t,{depthRadius:u,bias:c,alpha:h,beta:f}=s,p=new uQ(o.shape,u,c,h,f);return e.runWebGLProgram(p,[o,i,l],o.dtype)},hQ={kernelName:hb,backendName:"webgl",kernelFunc:cQ};function dQ(n,t,e,s){const o=dt(t),l=dt(n.shape)/o,u=wt({inputs:{x:n},attrs:{shape:[l,o]},backend:s}),c=hr(u,n.dtype,"max",s),h=wt({inputs:{x:c},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(u),s.disposeIntermediateTensorInfo(c),h}function MR(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{reductionIndices:i,keepDims:l}=s,u=o.shape.length,c=qt(i,o.shape);let h=c;const f=Be(h,u),p=f!=null,g=e.shouldExecuteOnCPU([o]);let x=o;if(p){if(g){const k=e.texData.get(x.dataId).values,T=new Array(u);for(let D=0;D<T.length;D++)T[D]=o.shape[f[D]];const N=c1(k,o.shape,o.dtype,f,T);x=e.makeTensorInfo(T,o.dtype);const R=e.texData.get(x.dataId);R.values=N}else x=im(o,f,e);h=qe(h.length,u)}Sn("max",h,u);const[b,v]=gn(x.shape,h);let S=b;l&&(S=Qe(b,c));let C;if(g){const k=e.texData.get(x.dataId).values,T=yX(k,dt(v),S,o.dtype);C=e.makeTensorInfo(S,o.dtype);const N=e.texData.get(C.dataId);N.values=T}else C=dQ(x,v,S,e);return p&&e.disposeIntermediateTensorInfo(x),C}const fQ={kernelName:rp,backendName:"webgl",kernelFunc:MR};const pQ=h1+`
  return max(a, b);
`,mQ=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cr+`
  return result;
`,gQ=Cn({opSnippet:pQ,packedOpSnippet:mQ,cpuKernelImpl:vX}),xQ={kernelName:Ic,backendName:"webgl",kernelFunc:gQ};function bQ(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t;ph(o,"maxPool");const{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,h=1;_(Dn(l,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${h}'`);const f=js(o.shape,i,l,h,u,c);if(f.filterWidth===1&&f.filterHeight===1&&ce(f.inShape,f.outShape))return hs({inputs:{x:o},backend:e});const p=new Qu(f,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}const yQ={kernelName:lp,backendName:"webgl",kernelFunc:bQ};function vQ(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{filterSize:i,strides:l,pad:u,dataFormat:c,dimRoundingMode:h}=s,f=[1,1,1],p=fa(o.shape,i,l,f,u,h,c),g=new f1(p,"max",!1);return e.runWebGLProgram(g,[o],o.dtype)}const wQ={kernelName:up,backendName:"webgl",kernelFunc:vQ};class SQ{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,s=t.strideWidth,o=t.dilationHeight,i=t.effectiveFilterHeight,l=t.effectiveFilterWidth,u=i-1-t.padInfo.top,c=l-1-t.padInfo.left,h=i*l-1;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${l} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class CQ{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,s=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth,p=c-1-t.padInfo.front,g=h-1-t.padInfo.top,x=f-1-t.padInfo.left,b=c*h*f-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${g}, ${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${f} +
                  wR * ${f} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function $Q(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,input:i}=t,l=i,{filterSize:u,strides:c,pad:h,dimRoundingMode:f}=s,p=[1,1,1],g=fa(l.shape,u,c,p,h,f),x=new f1(g,"max",!0),b=e.runWebGLProgram(x,[l],l.dtype),v=new CQ(g),S=e.runWebGLProgram(v,[o,b],l.dtype);return e.disposeIntermediateTensorInfo(b),S}const TQ={kernelName:fb,backendName:"webgl",kernelFunc:$Q};function kQ(n){const{inputs:t,backend:e,attrs:s}=n,{dy:o,input:i,output:l}=t,u=i;ph([i,l],"maxPoolGrad");const{filterSize:c,strides:h,pad:f,dimRoundingMode:p}=s,g=js(u.shape,c,h,1,f,p),x=!0,b=new Qu(g,"max",x),v=e.runWebGLProgram(b,[u],u.dtype),S=new SQ(g),C=e.runWebGLProgram(S,[o,v],u.dtype);return e.disposeIntermediateTensorInfo(v),C}const IQ={kernelName:db,backendName:"webgl",kernelFunc:kQ};function NQ(n,t,e,s){let o=new Qu(e,"max",!1);const i=s.runWebGLProgram(o,[n],"float32");o=new Qu(e,"max",!0,!0,t);const l=s.runWebGLProgram(o,[n],"float32");return[i,l]}const EQ={kernelName:k$,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:o,strides:i,pad:l,includeBatchInIndex:u}=t,c=e;_(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];_(Dn(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const f=js(s.shape,o,i,h,l),[p,g]=NQ(s,u,f,c);return[p,g]}};function RQ(n,t,e,s){const o=dt(t),l=dt(n.shape)/o,u=wt({inputs:{x:n},attrs:{shape:[l,o]},backend:s}),c=hr(u,"float32","mean",s),h=wt({inputs:{x:c},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(u),s.disposeIntermediateTensorInfo(c),h}const AQ={kernelName:cp,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:o,axis:i}=t,l=e,u=s.shape.length,c=qt(i,s.shape);let h=c;const f=Be(h,u),p=f!=null,g=l.shouldExecuteOnCPU([s]),x=[];let b=s;if(p){if(g){const T=l.texData.get(b.dataId).values,N=new Array(u);for(let z=0;z<N.length;z++)N[z]=s.shape[f[z]];const R=c1(T,s.shape,s.dtype,f,N);b=l.makeTensorInfo(N,s.dtype);const D=l.texData.get(b.dataId);D.values=R}else b=im(s,f,l);x.push(b),h=qe(h.length,u)}Sn("sum",h,u);const[v,S]=gn(b.shape,h);let C=v;o&&(C=Qe(v,c));const $=RQ(b,S,C,l);for(const k of x)l.disposeIntermediateTensorInfo(k);return $}};function DQ(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s,u=o.shape.length,c=qt(i,o.shape);let h=c;const f=Be(h,u);let p=o;f!=null&&(p=Un({inputs:{x:o},backend:e,attrs:{perm:f}}),h=qe(h.length,o.shape.length)),Sn("min",h,u);const[g,x]=gn(p.shape,h),b=dt(x),v=wt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),S=hr(v,v.dtype,"min",e);let C;if(l){const $=Qe(g,c);C=wt({inputs:{x:S},backend:e,attrs:{shape:$}})}else C=wt({inputs:{x:S},backend:e,attrs:{shape:g}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(S),f!=null&&e.disposeIntermediateTensorInfo(p),C}const OQ={kernelName:hp,backendName:"webgl",kernelFunc:DQ};const _Q=h1+`
  return min(a, b);
`,FQ=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+cr+`
  return result;
`,MQ=Cn({opSnippet:_Q,packedOpSnippet:FQ,cpuKernelImpl:wX}),zQ={kernelName:Nc,backendName:"webgl",kernelFunc:MQ};class LQ{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((f,p)=>f[0]+t[p]+f[1]);const o=t.length,i=ye(o),l=e.map(f=>f[0]).join(","),u=e.map((f,p)=>f[0]+t[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),h=s==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${l};
        int end = ${u};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${l});
      ${i} end = ${i}(${u});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}class BQ{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((b,v)=>b[0]+t[v]+b[1]);const o=t.length,i=ye(o),l=e.map(b=>b[0]).join(","),u=e.map((b,v)=>b[0]+t[v]).join(","),c=Ln("rc",o),h=Ln("source",o),f=`${c[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${h.slice(-2).join()})`,g=s==="reflect"?0:1;let x="";if(o===1){const b=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${g};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${g};
        }
        source -= start;
      `;x=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[o-1]} += 1;
        if(${f}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
      `}else{const b=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${g}) +
                gte * ((end - 1) * 2 - source + ${g});
        source -= start;
      `;x=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[o-1]} += 1;
        if(${f}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
        rc = outputLoc;
        ${c[o-2]} += 1;
        if(${c[o-2]} < ${this.outputShape[o-2]}) {
          ${b}
          result[2] = getChannel(getX(${h.join()}), ${p});
          ${c[o-1]} += 1;
          if(${f}) {
            ${b}
            result[3] = getChannel(getX(${h.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${l});
      const ${i} end = ${i}(${u});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${x}
        setOutput(result);
      }
    `}}const UQ=({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:o,mode:i}=e,l=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new BQ(s.shape,o,i):new LQ(s.shape,o,i);return t.runWebGLProgram(l,[s],s.dtype)},VQ={kernelName:dp,backendName:"webgl",kernelFunc:UQ};const PQ=`if (b == 0.0) return NAN;
  return mod(a, b);`,GQ=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+cr+`
  return result;
`,WQ=Cn({opSnippet:PQ,packedOpSnippet:GQ}),HQ={kernelName:Ec,backendName:"webgl",kernelFunc:WQ};class qQ{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}const jQ=`
if (a == b) {
  return 1.0;
};
return a / b;`,XQ=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,zR=Cn({opSnippet:jQ,packedOpSnippet:XQ,checkOutOfBounds:!0}),KQ={kernelName:fc,backendName:"webgl",kernelFunc:zR};const u$="return a - b;",LR=Cn({opSnippet:u$,packedOpSnippet:u$,supportsComplex:!0,cpuKernelImpl:PX}),YQ={kernelName:Hc,backendName:"webgl",kernelFunc:LR};function BR(n){const{inputs:t,backend:e,attrs:s}=n,{logits:o}=t,{dim:i}=s,l=qt([i],o.shape),u=MR({inputs:{x:o},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=Qe(u.shape,l),h=wt({inputs:{x:u},backend:e,attrs:{shape:c}}),f=LR({inputs:{a:o,b:h},backend:e}),p=OR({inputs:{x:f},backend:e}),g=rm({inputs:{x:p},backend:e,attrs:{axis:l,keepDims:!1}}),x=wt({inputs:{x:g},backend:e,attrs:{shape:c}}),b=zR({inputs:{a:p,b:x},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),b}const ZQ={kernelName:Rp,backendName:"webgl",kernelFunc:BR};function QQ(n){const{inputs:t,backend:e,attrs:s}=n,{logits:o}=t,{numSamples:i,seed:l,normalized:u}=s,c=u?o:BR({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),h=c.shape[0],f=c.shape[1],p=new qQ(h,f,i),g=[[l]],x=e.runWebGLProgram(p,[c],"int32",g);return u||e.disposeIntermediateTensorInfo(c),x}const JQ={kernelName:I$,backendName:"webgl",kernelFunc:QQ};const tJ=Ks+`
  return -x;
`,eJ=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function nJ(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId),[l,u]=CX(i.values,s.shape,s.dtype);return e.makeTensorInfo(u,s.dtype,l)}let o;return lt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Wa(s.shape,eJ):o=new ko(s.shape,tJ),e.runWebGLProgram(o,[s],s.dtype)}const sJ={kernelName:fp,backendName:"webgl",kernelFunc:nJ};const oJ=ny;function aJ(n){Ss("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:o,scores:i}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=s,h=e.readSync(o.dataId),f=e.readSync(i.dataId),{selectedIndices:p}=oJ(h,f,l,u,c);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}const iJ={kernelName:pb,backendName:"webgl",kernelFunc:aJ};const rJ=sy;function lJ(n){Ss("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:o,scores:i}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:c,padToMaxOutputSize:h}=s,f=e.readSync(o.dataId),p=e.readSync(i.dataId),{selectedIndices:g,validOutputs:x}=rJ(f,p,l,u,c,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([],"int32",new Int32Array([x]))]}const uJ={kernelName:mb,backendName:"webgl",kernelFunc:lJ};const cJ=oy;function hJ(n){Ss("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:o,scores:i}=t,{maxOutputSize:l,iouThreshold:u,scoreThreshold:c,softNmsSigma:h}=s,f=e.readSync(o.dataId),p=e.readSync(i.dataId),g=l,x=u,b=c,v=h,{selectedIndices:S,selectedScores:C}=cJ(f,p,g,x,b,v);return[e.makeTensorInfo([S.length],"int32",new Int32Array(S)),e.makeTensorInfo([C.length],"float32",new Float32Array(C))]}const dJ={kernelName:gb,backendName:"webgl",kernelFunc:hJ};class fJ{constructor(t,e,s,o){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const pJ=n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:o}=t,{dtype:i,depth:l,onValue:u,offValue:c}=s,h=dt(o.shape),f=new fJ(h,l,u,c),p=wt({inputs:{x:o},backend:e,attrs:{shape:[h]}}),g=e.runWebGLProgram(f,[p],i);e.disposeIntermediateTensorInfo(p);const x=[...o.shape,l],b=wt({inputs:{x:g},backend:e,attrs:{shape:x}});return e.disposeIntermediateTensorInfo(g),b},mJ={kernelName:gp,backendName:"webgl",kernelFunc:pJ};function Of(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const o=gh({inputs:{input:s},backend:e}),i=Of({inputs:{x:o},backend:e}),l=lm({inputs:{input:s},backend:e}),u=Of({inputs:{x:l},backend:e}),c=hi({inputs:{real:i,imag:u},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),c}else return xh({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const gJ={kernelName:Op,backendName:"webgl",kernelFunc:Of};function UR(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const o=gh({inputs:{input:s},backend:e}),i=UR({inputs:{x:o},backend:e}),l=lm({inputs:{input:s},backend:e}),u=Of({inputs:{x:l},backend:e}),c=hi({inputs:{real:i,imag:u},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),c}else return xh({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const xJ={kernelName:mp,backendName:"webgl",kernelFunc:UR};function bJ(n){const{inputs:t,backend:e,attrs:s}=n,{axis:o}=s;if(t.length===1)return D0({inputs:{input:t[0]},backend:e,attrs:{dim:o}});const i=t[0].shape,l=t[0].dtype;t.forEach(f=>{z0(i,f.shape,"All tensors passed to stack must have matching shapes"),_(l===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],c=t.map(f=>{const p=D0({inputs:{input:f},backend:e,attrs:{dim:o}});return u.push(p),p}),h=TR({inputs:c,backend:e,attrs:{axis:o}});return u.forEach(f=>e.disposeIntermediateTensorInfo(f)),h}const yJ={kernelName:xp,backendName:"webgl",kernelFunc:bJ};class vJ{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,f)=>h[0]+t[f]+h[1]);const o=t.length,i=ye(o),l=e.map(h=>h[0]).join(","),u=e.map((h,f)=>h[0]+t[f]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${l};
        int end = ${u};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${l});
      ${i} end = ${i}(${u});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}class wJ{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((v,S)=>v[0]+t[S]+v[1]);const o=t.length,i=ye(o),l=e.map(v=>v[0]).join(","),u=e.map((v,S)=>v[0]+t[S]).join(","),c=Ln("rc",o),h=Ln("source",o),f=`${c[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${h.slice(-2).join()})`,g=[`${i} rc = outputLoc;`,`${c[o-1]} += 1;
       if(${f}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${c[o-2]} += 1;
       if(${c[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${c[o-1]} += 1;
         if(${f}) {`],x=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let v=0,S=o===1?2:4;v<S;v++)b+=`
        ${g[v]}
        if (${x}) {
          result[${v}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${v}] = getChannel(getX(${h.join()}), ${p});
        }
      `;b+=o===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${l});
      const ${i} end = ${i}(${u});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const VR=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{paddings:i,constantValue:l}=s;if(dt(o.shape)===0){const h=i.map((f,p)=>f[0]+o.shape[p]+f[1]);return xh({backend:e,attrs:{shape:h,value:l,dtype:o.dtype}})}const u=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wJ(o.shape,i,l):new vJ(o.shape,i,l),c=[[l]];return e.runWebGLProgram(u,[o],o.dtype,c)},SJ={kernelName:bp,backendName:"webgl",kernelFunc:VR};const CJ=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,$J=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+cr+`
  return result;
`,TJ=Cn({opSnippet:CJ,packedOpSnippet:$J}),kJ={kernelName:Ac,backendName:"webgl",kernelFunc:TJ};function IJ(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{axis:i,keepDims:l}=s,u=o.shape.length,c=[],h=qt(i,o.shape);let f=h;const p=Be(f,u);let g=o;p!=null&&(g=Un({inputs:{x:o},backend:e,attrs:{perm:p}}),f=qe(f.length,u),c.push(g)),Sn("prod",f,u);let x;if(e.shouldExecuteOnCPU([g])){const b=e.texData.get(g.dataId).values,{outVals:v,outShape:S,outDtype:C}=TX(g.shape,g.dtype,b,f);x=e.makeTensorInfo(S,C,v)}else{const[b,v]=gn(g.shape,f),S=dt(v),C=wt({inputs:{x:g},backend:e,attrs:{shape:[-1,S]}}),$=Nb(o.dtype),k=hr(C,$,"prod",e);x=wt({inputs:{x:k},backend:e,attrs:{shape:b}}),c.push(C),c.push(k)}if(l){c.push(x);const b=Qe(x.shape,h);x=wt({inputs:{x},backend:e,attrs:{shape:b}})}return c.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}const NJ={kernelName:vp,backendName:"webgl",kernelFunc:IJ};function EJ(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:o,paramsDenseValues:i,indices:l}=t,{outputRaggedRank:u}=s,c=o.map(C=>e.readSync(C.dataId)),h=o.map(C=>C.shape),f=e.readSync(i.dataId),p=e.readSync(l.dataId),[g,x,b]=kX(c,h,f,i.shape,i.dtype,p,l.shape,u),v=g.map(C=>e.makeTensorInfo([C.length],"int32",C)),S=e.makeTensorInfo(b,i.dtype,x);return v.concat([S])}const RJ={kernelName:N$,backendName:"webgl",kernelFunc:EJ};function AJ(n){const{inputs:t,backend:e}=n,{starts:s,limits:o,deltas:i}=t,l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=e.readSync(i.dataId),[h,f]=IX(l,s.shape,s.dtype,u,o.shape,c,i.shape),p=e.makeTensorInfo([h.length],"int32",h),g=e.makeTensorInfo([f.length],s.dtype,f);return[p,g]}const DJ={kernelName:E$,backendName:"webgl",kernelFunc:AJ};function OJ(n){const{inputs:t,backend:e,attrs:s}=n,{shape:o,values:i,defaultValue:l,rowPartitionTensors:u}=t,{rowPartitionTypes:c}=s,h=e.readSync(o.dataId),f=e.readSync(i.dataId),p=e.readSync(l.dataId),g=u.map(S=>e.readSync(S.dataId)),x=u.map(S=>S.shape),[b,v]=NX(h,o.shape,f,i.shape,i.dtype,p,l.shape,g,x,c);return e.makeTensorInfo(b,i.dtype,v)}const _J={kernelName:R$,backendName:"webgl",kernelFunc:OJ};const PR=n=>{const{backend:t,attrs:e}=n,{start:s,stop:o,step:i,dtype:l}=e,u=EX(s,o,i,l);return t.makeTensorInfo([u.length],l,u)},FJ={kernelName:xb,backendName:"webgl",kernelFunc:PR};const MJ="return 1.0 / x;",zJ=ee({opSnippet:MJ}),LJ={kernelName:Dc,backendName:"webgl",kernelFunc:zJ};const BJ=Ks+`
  return (x < 0.0) ? 0.0 : x;
`,UJ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,VJ=ee({opSnippet:BJ,packedOpSnippet:UJ}),PJ={kernelName:Oc,backendName:"webgl",kernelFunc:VJ};const GJ=Ks+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,WJ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HJ=ee({opSnippet:GJ,packedOpSnippet:WJ}),qJ={kernelName:_c,backendName:"webgl",kernelFunc:HJ};class jJ{constructor(t,e,s,o,i){this.variableNames=["A"],this.outputShape=[];const[l,u,c,h]=t;this.outputShape=[l,e,s,h];const f=[o&&e>1?u-1:u,o&&s>1?c-1:c],p=[o&&e>1?e-1:e,o&&s>1?s-1:s];let g;i?g="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0]/p[0]},
          ${f[1]/p[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class XJ{constructor(t,e,s,o,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[l,u,c,h]=t;this.outputShape=[l,e,s,h];const f=[o&&e>1?u-1:u,o&&s>1?c-1:c],p=[o&&e>1?e-1:e,o&&s>1?s-1:s];let g;i?g="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0]/p[0]},
          ${f[1]/p[1]},
          ${f[1]/p[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function KJ(n){const{inputs:t,backend:e,attrs:s}=n,{images:o}=t,{alignCorners:i,halfPixelCenters:l,size:u}=s,[c,h]=u,f=lt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new XJ(o.shape,c,h,i,l):new jJ(o.shape,c,h,i,l);return e.runWebGLProgram(f,[o],"float32")}const YJ={kernelName:Cp,backendName:"webgl",kernelFunc:KJ};class ZJ{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,o,i]=e,[,l,u]=t,c=[s&&l>1?o-1:o,s&&u>1?i-1:i],h=[s&&l>1?l-1:l,s&&u>1?u-1:u],f=c[0]/h[0],p=c[1]/h[1],g=1/f,x=1/p,b=Math.ceil(g)*2+2,v=Math.ceil(x)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${p});

        const float invHeightScale = float(${g});
        const float invWidthScale = float(${x});

        const int winHeight = int(${b});
        const int winWidth = int(${v});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${l}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${u}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function QJ(n){const{inputs:t,backend:e,attrs:s}=n,{images:o,dy:i}=t,{alignCorners:l}=s,u=new ZJ(i.shape,o.shape,l);return e.runWebGLProgram(u,[i],i.dtype)}const JJ={kernelName:vb,backendName:"webgl",kernelFunc:QJ};class ttt{constructor(t,e,s,o,i){this.variableNames=["A"],this.outputShape=[];const[l,u,c,h]=t;this.outputShape=[l,e,s,h];const f=[o&&e>1?u-1:u,o&&s>1?c-1:c],p=[o&&e>1?e-1:e,o&&s>1?s-1:s],g=o?"0.5":"0.0";let x;i?x="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":x="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0]/p[0]},
          ${f[1]/p[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${x};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${g})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class ett{constructor(t,e,s,o,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[l,u,c,h]=t;this.outputShape=[l,e,s,h];const f=[o&&e>1?u-1:u,o&&s>1?c-1:c],p=[o&&e>1?e-1:e,o&&s>1?s-1:s],g=o?"0.5":"0.0";let x;i?x="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":x="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0]/p[0]},
          ${f[1]/p[1]},
          ${f[1]/p[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${x};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${g})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function ntt(n){const{inputs:t,backend:e,attrs:s}=n,{images:o}=t,{alignCorners:i,halfPixelCenters:l,size:u}=s,[c,h]=u,f=lt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ett(o.shape,c,h,i,l):new ttt(o.shape,c,h,i,l);return e.runWebGLProgram(f,[o],o.dtype)}const stt={kernelName:Sp,backendName:"webgl",kernelFunc:ntt};class ott{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,o,i]=e,[,l,u]=t,c=[s&&l>1?o-1:o,s&&u>1?i-1:i],h=[s&&l>1?l-1:l,s&&u>1?u-1:u],f=c[0]/h[0],p=c[1]/h[1],g=1/f,x=1/p,b=Math.ceil(g)*2+2,v=Math.ceil(x)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${p});

        const float invHeightScale = float(${g});
        const float invWidthScale = float(${x});

        const int winHeight = int(${b});
        const int winWidth = int(${v});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${l}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${u}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function att(n){const{inputs:t,backend:e,attrs:s}=n,{images:o,dy:i}=t,{alignCorners:l}=s,u=new ott(i.shape,o.shape,l);return e.runWebGLProgram(u,[i],i.dtype)}const itt={kernelName:yb,backendName:"webgl",kernelFunc:att};class rtt{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const o=u=>e.indexOf(u)!==-1&&t[u]!==1?`${t[u]} - coords[${u}] - 1`:`coords[${u}]`,i=t.map((u,c)=>o(c)).join(","),l=ye(s);this.userCode=`
      void main() {
        ${l} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class ltt{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const o=Ln("rc",s),i=`${o[s-1]} + 1 < ${this.outputShape[s-1]}`,l=`${o[s-2]} + 1 < ${this.outputShape[s-2]}`,u=ye(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${u} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(o.slice())};
          if(${i}){
            result.g = ${h(o.slice())};
          }
          if(${l}) {
            result.b = ${f(o.slice())};
            if(${i}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(b){return g(b)}function h(b){return b[s-1]="("+b[s-1]+" + 1)",g(b)}function f(b){return b[s-2]="("+b[s-2]+" + 1)",g(b)}function p(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",g(b)}function g(b){const v=t.map(($,k)=>x(k,b)),S=v.join(","),C=v.slice(-2).join(",");return`getChannel(getX(${S}), vec2(${C}))`}function x(b,v){return e.indexOf(b)!==-1&&t[b]!==1?`${t[b]} - ${v[b]} - 1`:`${v[b]}`}}}function utt(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{dims:i}=s,l=o.shape.length,u=qt(i,o.shape);if(l===0)return hs({inputs:{x:o},backend:e});const c=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ltt(o.shape,u):new rtt(o.shape,u);return e.runWebGLProgram(c,[o],o.dtype)}const ctt={kernelName:$p,backendName:"webgl",kernelFunc:utt};class htt{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],o=t[2];this.outputShape=t;let i="";typeof e=="number"?i=`float outputValue = ${e.toFixed(2)};`:i=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const dtt={kernelName:Ib,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:o,fillValue:i,center:l}=t,u=e,c=new htt(s.shape,i),[h,f]=dy(l,s.shape[1],s.shape[2]),p=[[h,f,Math.sin(o),Math.cos(o)]];return u.runWebGLProgram(c,[s],s.dtype,p)}};const ftt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,ptt=ee({opSnippet:ftt}),mtt={kernelName:Fc,backendName:"webgl",kernelFunc:ptt};const gtt="return inversesqrt(x);",xtt=ee({opSnippet:gtt,cpuKernelImpl:RX}),btt={kernelName:Mc,backendName:"webgl",kernelFunc:xtt};class p1{constructor(t,e,s,o,i,l,u=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=l;const h=ye(i.length),f=ye(l.length);let p="";s===1?p="i":s===2&&(p="i, j");const g=`getIndices(${p})`;let x="";o===1?x="i":o===2&&(x="i, coords[1]");const b=`getUpdates(${x})`;let v="";c&&(v="coords[0], coords[1]");const S=`getDefaultValue(${v})`,C=e>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${f} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${g});
              flattenedIndex += index * ${C};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${S}, sum, float(found)));
        }
      `}}class ytt{constructor(t,e,s,o,i,l,u=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=l;const h=ye(i.length),f=ye(l.length);let p="";s===1?p="i":s===2&&(p="i, j");const g=`getIndices(${p})`;let x="";o===1?x="i":o===2&&(x="i, coords[1]");const b=`getUpdates(${x})`;let v="";c&&(v="coords[0], coords[1]");const S=`getDefaultValue(${v})`,C=e>1?"strides[j]":"strides",$=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${f} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${g});
              flattenedIndex += index.xz * ${C};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${$};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${S}, sum, found));
        }
      `}}function vtt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:o,updates:i}=t,{shape:l}=s,{sliceRank:u,numUpdates:c,sliceSize:h,strides:f,outputSize:p}=ar(i,o,l),g=[p/h,h];if(p===0)return e.makeTensorInfo(l,o.dtype);const x=wt({inputs:{x:o},backend:e,attrs:{shape:[c,u]}}),b=wt({inputs:{x:i},backend:e,attrs:{shape:[c,h]}}),v=e.makeTensorInfo([],"float32",new Float32Array([0]));let S;lt().getBool("WEBGL_PACK")?S=new ytt(c,u,x.shape.length,b.shape.length,f,g):S=new p1(c,u,x.shape.length,b.shape.length,f,g);const C=e.runWebGLProgram(S,[b,x,v],b.dtype),$=wt({inputs:{x:C},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(v),$}const wtt={kernelName:A$,backendName:"webgl",kernelFunc:vtt};class Stt{constructor(t,e,s,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const i="while (left < right) {",l=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,u=lt().getNumber("WEBGL_VERSION")===2?i:l,c=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${u}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function Ctt(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:o,values:i}=t,{side:l}=s,u=new Stt(o.shape[0],o.shape[1],i.shape[1],l),c=[[o.shape[1]]];return e.runWebGLProgram(u,[o,i],"int32",c)}const $tt={kernelName:O$,backendName:"webgl",kernelFunc:Ctt};class Ttt{constructor(t,e,s){this.variableNames=["c","a","b"],this.outputShape=e;let o,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",o="resRC";else{const u=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],h=[];for(let f=0;f<e.length;f++)h.push(`${u[f]}`),f<t&&c.push(`${u[f]}`);o=c.join(),i=h.join()}const l=ye(s);this.userCode=`
      void main() {
        ${l} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function ktt(n){const{inputs:t,backend:e}=n,{condition:s,t:o,e:i}=t,l=new Ttt(s.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(l,[s,o,i],us(o.dtype,i.dtype))}const Itt={kernelName:Tp,backendName:"webgl",kernelFunc:ktt};const Ntt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Wp};
  float scale = ${Hp};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Ett=ee({opSnippet:Ntt}),Rtt={kernelName:zc,backendName:"webgl",kernelFunc:Ett};const Att=Ol+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Dtt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ott=ee({opSnippet:Att,packedOpSnippet:Dtt,cpuKernelImpl:DX}),_tt={kernelName:Vc,backendName:"webgl",kernelFunc:Ott};const Ftt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Mtt=ee({opSnippet:Ftt}),ztt={kernelName:Uc,backendName:"webgl",kernelFunc:Mtt};const Ltt=Ol+`
  return sin(x);
`,Btt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${cr}
  return result;
`,Utt=ee({opSnippet:Ltt,packedOpSnippet:Btt}),Vtt={kernelName:Lc,backendName:"webgl",kernelFunc:Utt};const Ptt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Gtt=ee({opSnippet:Ptt}),Wtt={kernelName:Bc,backendName:"webgl",kernelFunc:Gtt};const Htt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,qtt=ee({opSnippet:Htt}),jtt={kernelName:Pc,backendName:"webgl",kernelFunc:qtt};const Xtt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{blockShape:i,paddings:l}=s;_(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const u=i.reduce((C,$)=>C*$),c=[[0,0]];c.push(...l);for(let C=1+i.length;C<o.shape.length;++C)c.push([0,0]);const h=[],f=VR({inputs:{x:o},backend:e,attrs:{paddings:c,constantValue:0}}),p=eh(f.shape,i,u,!1),g=nh(p.length,i.length,!1),x=sh(f.shape,i,u,!1),b=wt({inputs:{x:f},backend:e,attrs:{shape:p}}),v=Un({inputs:{x:b},backend:e,attrs:{perm:g}}),S=wt({inputs:{x:v},backend:e,attrs:{shape:x}});return h.push(f),h.push(b),h.push(v),h.forEach(C=>e.disposeIntermediateTensorInfo(C)),S},Ktt={kernelName:Np,backendName:"webgl",kernelFunc:Xtt};function Ytt(n){const{inputs:t,backend:e}=n,{indices:s,values:o,denseShape:i,defaultValue:l}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(l.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${l.shape}`);const u=e.readSync(s.dataId),c=e.readSync(o.dataId),h=e.readSync(i.dataId),f=e.readSync(l.dataId)[0],[p,g,x,b,v]=_X(u,s.shape,s.dtype,c,o.dtype,h,f);return[e.makeTensorInfo(g,s.dtype,p),e.makeTensorInfo([g[0]],o.dtype,x),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(S=>Number(S)))),e.makeTensorInfo([v.length],s.dtype,new Int32Array(v))]}const Ztt={kernelName:_$,backendName:"webgl",kernelFunc:Ytt};function Qtt(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:o,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const l=Array.from(e.readSync(o.dataId)),u=e.readSync(s.dataId),c=Array.from(e.readSync(i.dataId)),[h,f,p]=FX(u,s.shape,s.dtype,l,c);return[e.makeTensorInfo(f,s.dtype,h),e.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const Jtt={kernelName:F$,backendName:"webgl",kernelFunc:Qtt};function tet(n){const{inputs:t,backend:e}=n,{data:s,indices:o,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=e.readSync(i.dataId),[h,f]=dR(l,s.shape,s.dtype,u,c,!0);return e.makeTensorInfo(f,s.dtype,h)}const eet={kernelName:M$,backendName:"webgl",kernelFunc:tet};function net(n){const{inputs:t,backend:e}=n,{data:s,indices:o,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const l=e.readSync(s.dataId),u=e.readSync(o.dataId),c=e.readSync(i.dataId),[h,f]=dR(l,s.shape,s.dtype,u,c);return e.makeTensorInfo(f,s.dtype,h)}const set={kernelName:z$,backendName:"webgl",kernelFunc:net};function oet(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:o,sparseValues:i,defaultValue:l}=t,{outputShape:u}=s,{sliceRank:c,numUpdates:h,sliceSize:f,strides:p,outputSize:g}=ar(i,o,u),x=!1;if(i.dtype==="string"){const C=e.bufferSync(o),$=e.bufferSync(i),k=Ka(e.readSync(l.dataId)[0]),T=AX(C,$,u,g,f,h,c,p,k,x);return e.makeTensorInfo(u,T.dtype,T.values)}const b=new p1(h,c,o.shape.length,i.shape.length,p,[g,1],x),v=e.runWebGLProgram(b,[i,o,l],i.dtype),S=wt({inputs:{x:v},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(v),S}const aet={kernelName:L$,backendName:"webgl",kernelFunc:oet};function iet(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{numOrSizeSplits:i,axis:l}=s,u=qt(l,o.shape)[0],c=Iy(o,i,u),h=o.shape.length,f=new Array(h).fill(0),p=o.shape.slice();return c.map(g=>{const x=[...p];x[u]=g;const b=_l({inputs:{x:o},backend:e,attrs:{begin:f,size:x}});return f[u]+=g,b})}const ret={kernelName:Ep,backendName:"webgl",kernelFunc:iet};const c$="return sqrt(x);",uet=ee({opSnippet:c$,packedOpSnippet:c$,cpuKernelImpl:MX}),cet={kernelName:Gc,backendName:"webgl",kernelFunc:uet};const het="return x * x;",det=ee({opSnippet:het}),fet={kernelName:wb,backendName:"webgl",kernelFunc:det};const h$="return (a - b) * (a - b);",pet=Cn({opSnippet:h$,packedOpSnippet:h$}),met={kernelName:Wc,backendName:"webgl",kernelFunc:pet};function get(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t;if(o.dtype!=="string")throw new Error("Input must be of datatype string");const i=e.readSync(o.dataId),l=ha(i),u=zX(l,"string",s);return e.makeTensorInfo(o.shape,"string",u)}const xet={kernelName:Sb,backendName:"webgl",kernelFunc:get};function bet({inputs:n,attrs:t,backend:e}){const{x:s}=n,o=Ks+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new ko(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const yet={kernelName:Kc,backendName:"webgl",kernelFunc:bet};class vet{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const o=s.length,i=ye(s.length),l=ye(s.length);let u="";if(o===1)u="coords * strides + begin";else{let c=0;u=s.map((h,f)=>(c++,s.length===1?`coords * strides[${f}] + begin[${f}]`:`coords[${c-1}] * strides[${f}] + begin[${f}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${e});

      void main() {
        ${l} coords = getOutputCoords();
        setOutput(getX(${u}));
      }
    `}}function wet(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{begin:i,end:l,strides:u,beginMask:c,endMask:h,ellipsisMask:f,newAxisMask:p,shrinkAxisMask:g}=s,{finalShapeSparse:x,finalShape:b,isIdentity:v,sliceDim0:S,isSimpleSlice:C,begin:$,end:k,strides:T}=nk(o.shape,i,l,u,c,h,f,p,g);let N;if(v)N=wt({inputs:{x:o},backend:e,attrs:{shape:b}});else if(S||C){_(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);const D=JT($,k,T),z=_l({inputs:{x:o},backend:e,attrs:{begin:$,size:D}});N=wt({inputs:{x:z},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(z)}else if(e.shouldExecuteOnCPU([o])){const z=e.readSync(o.dataId),O=Ht(o.shape,o.dtype,z),F=LX(x,O,T,$);N=e.makeTensorInfo(b,o.dtype,F.values)}else{const z=new vet($,T,x);N=e.runWebGLProgram(z,[o],o.dtype)}const R=wt({inputs:{x:N},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(N),R}const Cet={kernelName:Cb,backendName:"webgl",kernelFunc:wet};function $et(n){const{inputs:t,backend:e,attrs:s}=n,{separator:o,nGramWidths:i,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:h}=s,{data:f,dataSplits:p}=t,g=e.readSync(f.dataId),x=e.readSync(p.dataId),[b,v]=BX(g,x,o,i,l,u,c,h);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",v)]}const Tet={kernelName:B$,backendName:"webgl",kernelFunc:$et};function ket(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:o}=s,{input:i,delimiter:l}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(l.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${l.shape}`);const u=e.readSync(i.dataId),c=e.readSync(l.dataId)[0],[h,f,p]=UX(u,c,o),g=f.length;return[e.makeTensorInfo([g,2],"int32",h),e.makeTensorInfo([g],"string",f),e.makeTensorInfo([2],"int32",new Int32Array(p))]}const Iet={kernelName:U$,backendName:"webgl",kernelFunc:ket};function Net(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:o}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");const l=e.readSync(i.dataId),u=VX(l,o);return e.makeTensorInfo(i.shape,"int32",u)}const Eet={kernelName:V$,backendName:"webgl",kernelFunc:Net};const Ret="return tan(x);",Aet=ee({opSnippet:Ret}),Det={kernelName:qc,backendName:"webgl",kernelFunc:Aet};const Oet=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,_et=ee({opSnippet:Oet}),Fet={kernelName:jc,backendName:"webgl",kernelFunc:_et};function Met(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:o,indices:i,updates:l}=t,{sliceRank:u,numUpdates:c,sliceSize:h,strides:f,outputSize:p}=ar(l,i,o.shape),g=[p/h,h];if(p===0)return e.makeTensorInfo(o.shape,i.dtype);const x=wt({inputs:{x:i},backend:e,attrs:{shape:[c,u]}}),b=wt({inputs:{x:l},backend:e,attrs:{shape:[c,h]}}),v=wt({inputs:{x:o},backend:e,attrs:{shape:g}}),S=new p1(c,u,x.shape.length,b.shape.length,f,g,!1,!0),C=e.runWebGLProgram(S,[b,x,v],v.dtype),$=wt({inputs:{x:C},backend:e,attrs:{shape:o.shape}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(C),$}const zet={kernelName:D$,backendName:"webgl",kernelFunc:Met};class Let{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let l=0;l<s.length;l++)s[l]=t[l]*e[l];this.outputShape=s,this.rank=s.length;const o=ye(this.rank),i=Bet(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function Bet(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let o=0;o<n.length;o++)s.push(`imod(${e[o]}, ${n[o]})`);return s.join()}function GR(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{reps:i}=s;if(o.dtype==="string"||o.shape.length>5){const c=e.readSync(o.dataId),h=o.dtype==="string"?c.map(g=>Ka(g)):c,f=Ht(o.shape,o.dtype,h),p=GX(f,i);return e.makeTensorInfo(p.shape,p.dtype,p.values)}const l=new Let(o.shape,i);return e.runWebGLProgram(l,[o],o.dtype)}const Uet={kernelName:Xc,backendName:"webgl",kernelFunc:GR};class Vet{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Pet{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function Di(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function d$(n){let t=1;for(;t<n;)t*=2;return t}function Get(n){const{inputs:t,backend:e,attrs:s}=n,{x:o}=t,{k:i,sorted:l}=s,u=lt().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=lt().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=o.shape,f=h[h.length-1];if(e.shouldExecuteOnCPU([o])||f<u||i>c){const F=e.readSync(o.dataId),[E,U]=WX(F,h,o.dtype,i,l);return[e.makeTensorInfo(E.shape,E.dtype,E.values),e.makeTensorInfo(U.shape,U.dtype,U.values)]}if(i===0)return h[h.length-1]=0,[e.makeTensorInfo(h,o.dtype,[]),e.makeTensorInfo(h,"int32",[])];if(f===1)return[o,xh({attrs:{shape:h,dtype:"int32",value:0},backend:e})];const p=e.texData.get(o.dataId),g=p!==null&&p.isPacked,x=g?e.unpackTensor(o):o,v=dt(h)/f,S=wt({inputs:{x},attrs:{shape:[v,f]},backend:e});g&&Di(e,x);const C=d$(i),$=d$(f);let k=null;const T=()=>k===null?[S,S]:[S,k],N=(F,E,U)=>{const Y=T(),X=new Vet(U),L=[[f],[k===null?1:0],[Number.NEGATIVE_INFINITY],[F],[E]],P=k;k=e.runWebGLProgram(X,Y,"int32",L),Di(e,P)};for(let F=1;F<C;F*=2){const E=F*2;for(let U=F;U>=1;U/=2)N(E,U,[v,$])}for(let F=$;F>C;F/=2){const E=T(),U=new Pet([v,F/2]),X=[[f],[k===null?1:0],[C]],q=k;k=e.runWebGLProgram(U,E,"int32",X),Di(e,q);const L=C/2,P=L*2;for(let W=L;W>=1;W/=2)N(P,W,k.shape)}let R=k;k=_l({inputs:{x:k},backend:e,attrs:{begin:0,size:[v,i]}}),Di(e,R);let D=FR({inputs:{x:S,indices:k},backend:e,attrs:{axis:1,batchDims:1}});Di(e,S);const z=h.slice(0,-1);z.push(i),R=k,k=wt({inputs:{x:k},attrs:{shape:z},backend:e}),Di(e,R);const O=D;return D=wt({inputs:{x:D},attrs:{shape:z},backend:e}),Di(e,O),[D,k]}const Wet={kernelName:$b,backendName:"webgl",kernelFunc:Get};class Het{constructor(t,e,s,o,i,l){this.variableNames=["Image","Transforms"],this.outputShape=l;const u=s==="nearest"?1:2;let c;switch(o){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${u} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function qet(n){const{inputs:t,backend:e,attrs:s}=n,{image:o,transforms:i}=t,{interpolation:l,fillMode:u,fillValue:c,outputShape:h}=s,[f,p,g,x]=o.shape,[b,v]=h??[p,g],S=[f,b,v,x],C=new Het(p,g,l,u,c,S);return e.runWebGLProgram(C,[o,i],"float32")}const jet={kernelName:Tb,backendName:"webgl",kernelFunc:qet};function Xet(n){const{inputs:t,attrs:e,backend:s}=n,{axis:o}=e,{x:i}=t;ph(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const l=s.readSync(i.dataId),{outputValues:u,outputShape:c,indices:h}=HX(l,o,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,u),s.makeTensorInfo([h.length],"int32",h)]}const Ket={kernelName:kb,backendName:"webgl",kernelFunc:Xet};function Yet(n){const{inputs:t,backend:e,attrs:s}=n,{value:o}=t;let{axis:i}=s;i<0&&(i+=o.shape.length);const l=o,u=l.shape.length,c=o.shape[i],h=new Array(u-1);let f=0;for(let v=0;v<u;v++)v!==i&&(h[f++]=l.shape[v]);const p=[],g=new Array(u).fill(0),x=l.shape.slice();x[i]=1;const b=new Array(c);for(let v=0;v<b.length;v++){g[i]=v;const S=_l({inputs:{x:l},backend:e,attrs:{begin:g,size:x}}),C=wt({inputs:{x:S},backend:e,attrs:{shape:h}});b[v]=C,p.push(S)}return p.forEach(v=>e.disposeIntermediateTensorInfo(v)),b}const Zet={kernelName:Ap,backendName:"webgl",kernelFunc:Yet};class Qet{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,o=t.batchSize,i=t.inSize,l=t.numSegments,u=l*Math.ceil(i/s);this.outputShape=[o,u];const c="0.0",h="sumValue",f=Math.floor(s/4)*4,p=s%4,g=`
        sumValue += dot(values, segFilter);
    `;let x="";i%s>0&&(x=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${x}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${l})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${l})));

        float sumValue = 0.0;

        for (int i = 0; i < ${f}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${g}
        }

        int inIdx = inOffset + ${f};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${g}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${g}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${g}
        }
        setOutput(${h});
      }
    `}}function Jet(n){const{inputs:t,backend:e,attrs:s}=n,{x:o,segmentIds:i}=t,{numSegments:l}=s,u=o.shape.length,c=[];let h=0;const f=Be([h],u);let p=o;f!=null&&(p=Un({inputs:{x:o},backend:e,attrs:{perm:f}}),c.push(p),h=qe(1,u)[0]);const g=D4(p.shape,h,l),x=dt([p.shape[h]]),b=wt({inputs:{x:p},backend:e,attrs:{shape:[-1,x]}});c.push(b);const v=Nb(o.dtype),S=(T,N,R,D,z)=>{const O=T.shape[0],F=T.shape[1],E=A4(F,z),U={windowSize:E,inSize:F,batchSize:O,numSegments:z},Y=new Qet(U,N),X=e.compileAndRun(Y,[T,R],D);if(c.push(X),X.shape[1]===z)return X;const q=PR({backend:e,attrs:{start:0,stop:z,step:1,dtype:"float32"}}),L=GR({inputs:{x:q},backend:e,attrs:{reps:[F/E]}});return c.push(q),c.push(L),S(X,N,L,D,z)},C=S(b,"unsortedSegmentSum",i,v,l),$=wt({inputs:{x:C},backend:e,attrs:{shape:g}});let k=$;if(f!=null){c.push($);const T=ai(f);k=Un({inputs:{x:k},backend:e,attrs:{perm:T}})}return c.forEach(T=>e.disposeIntermediateTensorInfo(T)),k}const tnt={kernelName:Dp,backendName:"webgl",kernelFunc:Jet};const ent=[MK,LK,VK,WK,qK,KK,ZK,JK,s7,a7,l7,h7,p7,b7,w7,C7,T7,E7,A7,O7,z7,W7,q7,Y7,Q7,o9,i9,c9,yK,f9,b9,S9,N9,A9,O9,F9,z9,V9,W9,j9,K9,Z9,J9,nY,oY,lY,cY,fY,gY,bY,SY,kY,RY,OY,MY,zY,BY,VY,GY,HY,jY,ZY,tZ,sZ,aZ,lZ,hZ,mZ,yZ,bK,wZ,g9,$Z,IZ,RZ,wK,_Z,LZ,UZ,WZ,jZ,ZZ,tQ,oQ,lQ,hQ,fQ,xQ,yQ,wQ,TQ,IQ,EQ,AQ,OQ,zQ,VQ,HQ,JQ,$K,sJ,iJ,uJ,dJ,t9,mJ,xJ,yJ,SJ,kJ,CK,NJ,RJ,DJ,_J,FJ,e9,KQ,LJ,PJ,qJ,kK,YJ,JJ,stt,itt,ctt,dtt,mtt,btt,wtt,$tt,Itt,Rtt,_tt,ztt,Vtt,Wtt,P7,ZQ,jtt,Ktt,Ztt,Jtt,eet,set,aet,ret,cet,fet,met,xet,yet,Cet,Tet,Iet,Eet,YQ,OK,Det,Fet,zet,Uet,Wet,jet,_K,Ket,Zet,tnt,gJ];for(const n of ent)G$(n);class nnt{constructor(){this.inputSize=11,this.outputSize=4,this.replayBuffer=[],this.bufferSize=5e4,this.batchSize=64,this.gamma=.95,this.epsilon=1,this.epsilonMin=.01,this.epsilonDecay=.995,this.learningRate=.001,this.model=this._buildModel(),this.disposed=!1}_buildModel(){const t=xP();return t.add(Px({inputShape:[this.inputSize],units:256,activation:"relu"})),t.add(Px({units:64,activation:"relu"})),t.add(Px({units:this.outputSize,activation:"linear"})),t.compile({optimizer:oa.adam(this.learningRate),loss:"meanSquaredError"}),t}act(t){return Math.random()<this.epsilon?Math.floor(Math.random()*this.outputSize):this.actGreedy(t)}actGreedy(t){return st(()=>{const e=Va([t]);return this.model.predict(e).argMax(1).dataSync()[0]})}remember(t,e,s,o,i){this.replayBuffer.push({state:t,action:e,reward:s,nextState:o,done:i}),this.replayBuffer.length>this.bufferSize&&this.replayBuffer.shift()}async train(){if(this.replayBuffer.length<this.batchSize)return;const t=[];for(let f=0;f<this.batchSize;f++)t.push(this.replayBuffer[Math.floor(Math.random()*this.replayBuffer.length)]);const e=t.map(f=>f.state),s=t.map(f=>f.nextState),[o,i]=st(()=>{const f=Va(e),p=Va(s);return[this.model.predict(f).arraySync(),this.model.predict(p).arraySync()]}),l=[],u=[];for(let f=0;f<this.batchSize;f++){const{action:p,reward:g,done:x}=t[f],b=[...o[f]];b[p]=x?g:g+this.gamma*Math.max(...i[f]),l.push(e[f]),u.push(b)}const c=Va(l),h=Va(u);await this.model.fit(c,h,{epochs:1,verbose:0}),c.dispose(),h.dispose()}decayEpsilon(){this.epsilon>this.epsilonMin&&(this.epsilon*=this.epsilonDecay)}async save(){await this.model.save("localstorage://snake-dqn"),localStorage.setItem("snake-dqn-meta",JSON.stringify({epsilon:this.epsilon}))}async load(){try{this.model=await T2("localstorage://snake-dqn"),this.model.compile({optimizer:oa.adam(this.learningRate),loss:"meanSquaredError"});const t=JSON.parse(localStorage.getItem("snake-dqn-meta")||"{}");return this.epsilon=t.epsilon??this.epsilonMin,!0}catch{return!1}}async exportToFile(){let t,e;return await this.model.save($4(async s=>(t=s.modelTopology,s.weightSpecs,e=Array.from(new Uint8Array(s.weightData)),{modelArtifactsInfo:{dateSaved:new Date}}))),JSON.stringify({modelTopology:t,weightSpecs:this.model.getWeights().map(s=>({name:s.name,shape:s.shape,dtype:s.dtype})),weightData:e,meta:{epsilon:this.epsilon}})}async importFromFile(t){const e=JSON.parse(t),s=new Uint8Array(e.weightData).buffer,o={modelTopology:e.modelTopology,weightSpecs:e.weightSpecs,weightData:s};this.model.dispose(),this.model=await T2(S4(o)),this.model.compile({optimizer:oa.adam(this.learningRate),loss:"meanSquaredError"}),this.epsilon=e.meta?.epsilon??this.epsilonMin}dispose(){this.model.dispose(),this.disposed=!0}}const Kx={UP:{x:0,y:-1},RIGHT:{x:1,y:0},DOWN:{x:0,y:1},LEFT:{x:-1,y:0}},snt={UP:{straight:"UP",right:"RIGHT",left:"LEFT"},RIGHT:{straight:"RIGHT",right:"DOWN",left:"UP"},DOWN:{straight:"DOWN",right:"LEFT",left:"RIGHT"},LEFT:{straight:"LEFT",right:"UP",left:"DOWN"}};function Yx(n,t,e){return n<0||n>=e.gridSize||t<0||t>=e.gridSize?!0:e.snake.some(s=>s.x===n&&s.y===t)}function jd(n){const t=n.snake[0],e=n.direction,s=snt[e],o=Kx[s.straight],i=Kx[s.right],l=Kx[s.left],u=Yx(t.x+o.x,t.y+o.y,n)?1:0,c=Yx(t.x+i.x,t.y+i.y,n)?1:0,h=Yx(t.x+l.x,t.y+l.y,n)?1:0,f=e==="UP"?1:0,p=e==="RIGHT"?1:0,g=e==="DOWN"?1:0,x=e==="LEFT"?1:0,b=n.food.y<t.y?1:0,v=n.food.x>t.x?1:0,S=n.food.y>t.y?1:0,C=n.food.x<t.x?1:0;return[u,c,h,f,p,g,x,b,v,S,C]}const f$=[{label:"Slow",ms:200},{label:"Normal",ms:120},{label:"Fast",ms:70}];function ont(){const n=ae.useMemo(()=>new wC,[]),t=ae.useRef(null),e=ae.useRef(null),s=ae.useRef(!1),[o,i]=ae.useState(0),[l,u]=ae.useState(1),[c,h]=ae.useState("human"),[f,p]=ae.useState(null),[g,x]=ae.useState({episode:0,epsilon:1,avgReward:0,bestScore:0}),[b,v]=ae.useState(!1);function S(){return(!e.current||e.current.disposed)&&(e.current=new nnt,e.current.load().then(X=>{X&&(v(!0),x(q=>({...q,epsilon:e.current.epsilon})))})),e.current}ae.useEffect(()=>{S()},[]);const C=ae.useCallback(()=>{n.reset(),i(0)},[n]),$=ae.useCallback(()=>{h("training"),s.current=!0;const X=S(),q=new wC,L=[];let P=0,W=g.bestScore,nt=q.reset(),it=jd(nt),M=0,G=0;function Q(){if(!s.current)return;const ut=performance.now()+12;for(G=0;performance.now()<ut&&s.current;){const gt=X.act(it),yt=q.step(gt),Tt=jd(yt.state);X.remember(it,gt,yt.reward,Tt,yt.done),M+=yt.reward,it=Tt,nt=yt.state,yt.done&&(P++,G++,X.decayEpsilon(),L.push(M),L.length>100&&L.shift(),nt.score>W&&(W=nt.score),nt=q.reset(),it=jd(nt),M=0)}if(!s.current)return;const ft=L.length>0?L.reduce((gt,yt)=>gt+yt,0)/L.length:0;x({episode:P,epsilon:X.epsilon,avgReward:ft,bestScore:W}),G>0?X.train().then(()=>{k.current=requestAnimationFrame(Q)}).catch(gt=>{console.error("train error:",gt),k.current=requestAnimationFrame(Q)}):k.current=requestAnimationFrame(Q)}k.current=requestAnimationFrame(Q)},[g.bestScore]),k=ae.useRef(null),T=ae.useCallback(()=>{s.current=!1,k.current&&(cancelAnimationFrame(k.current),k.current=null),h("human"),e.current&&!e.current.disposed&&e.current.save().then(()=>v(!0)).catch(()=>{})},[]),N=ae.useRef(null),R=ae.useCallback(()=>{const X=S();n.reset(),i(0),h("playing"),N.current=setInterval(()=>{n.gameOver&&(n.reset(),i(0));const q=n.getState(),L=jd(q),P=X.actGreedy(L);p(P)},50)},[n]),D=ae.useCallback(()=>{N.current&&(clearInterval(N.current),N.current=null),p(null),h("human"),n.reset(),i(0)},[n]);ae.useEffect(()=>()=>{s.current=!1,N.current&&clearInterval(N.current),e.current&&e.current.dispose()},[]);const z=ae.useCallback(()=>$(),[$]),O=ae.useCallback(()=>T(),[T]),F=ae.useCallback(()=>{c==="playing"?D():R()},[c,D,R]),E=ae.useCallback(async()=>{const q=await S().exportToFile(),L=new Blob([q],{type:"application/json"}),P=URL.createObjectURL(L),W=document.createElement("a");W.href=P,W.download="snake-dqn-model.json",W.click(),URL.revokeObjectURL(P)},[]),U=ae.useCallback(()=>{const X=document.createElement("input");X.type="file",X.accept=".json",X.onchange=async q=>{const L=q.target.files[0];if(!L)return;const P=await L.text(),W=S();await W.importFromFile(P),await W.save(),v(!0),x(nt=>({...nt,epsilon:W.epsilon}))},X.click()},[]),Y=c==="human"?"Human":c==="training"?"Training...":"AI Playing";return $e.jsxs("div",{className:"app",children:[$e.jsx("h1",{children:"Snake"}),$e.jsxs("div",{className:"toolbar",children:[$e.jsxs("span",{className:"score",children:["Score: ",o]}),$e.jsx("button",{onClick:C,disabled:c!=="human",children:"New Game"}),$e.jsx("span",{className:"mode-badge",children:Y}),$e.jsx("div",{className:"speed-control",children:f$.map((X,q)=>$e.jsx("button",{className:q===l?"active":"",onClick:()=>u(q),children:X.label},X.label))})]}),$e.jsx(EO,{ref:t,engine:n,tickInterval:f$[l].ms,onScoreChange:i,aiAction:f}),$e.jsx(RO,{aiMode:c,stats:g,onTrain:z,onWatch:F,onStop:O,onExport:E,onImport:U,modelLoaded:b}),$e.jsx("p",{className:"hint",children:c==="human"?"Arrow keys to move":c==="training"?"Training in background...":"AI is playing"})]})}bO.createRoot(document.getElementById("root")).render($e.jsx(ae.StrictMode,{children:$e.jsx(ont,{})}));
